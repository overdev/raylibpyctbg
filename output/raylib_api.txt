
import sys
import re
import os
import platform
import ctypes
from enum import IntEnum
from ctypes import (
    CDLL, wintypes,
    c_bool, c_char, c_byte, c_short, c_long, c_ubyte, c_ushort, c_ulong, c_ulong, c_float, c_double, c_char_p, c_void_p,
    Structure, POINTER, CFUNCTYPE, byref
) 


__all__ = [
    'rlapi',
    'Bool',
    'BoolPtr',
    'Byte',
    'BytePtr',
    'Char',
    'CharPtr',
    'Short',
    'ShortPtr',
    'Int',
    'IntPtr',
    'Long',
    'LongPtr',
    'UByte',
    'UBytePtr',
    'UShort',
    'UShortPtr',
    'UInt',
    'UIntPtr',
    'ULong',
    'ULongPtr',
    'Float',
    'FloatPtr',
    'Double',
    'DoublePtr',
    'VoidPtr',
    'VoidPtrPtr',
    'Vector2',
    'Vector2Ptr',
    'Vector3',
    'Vector3Ptr',
    'Quaternion',
    'QuaternionPtr',
    'Vector4',
    'Vector4Ptr',
    'Matrix',
    'MatrixPtr',
    'Color',
    'ColorPtr',
    'Rectangle',
    'RectanglePtr',
    'Image',
    'ImagePtr',
    'Texture2D',
    'Texture2DPtr',
    'TextureCubemap',
    'TextureCubemapPtr',
    'Texture',
    'TexturePtr',
    'RenderTexture2D',
    'RenderTexture2DPtr',
    'RenderTexture',
    'RenderTexturePtr',
    'NPatchInfo',
    'NPatchInfoPtr',
    'GlyphInfo',
    'GlyphInfoPtr',
    'Font',
    'FontPtr',
    'Camera',
    'CameraPtr',
    'Camera3D',
    'Camera3DPtr',
    'Camera2D',
    'Camera2DPtr',
    'Mesh',
    'MeshPtr',
    'Shader',
    'ShaderPtr',
    'MaterialMap',
    'MaterialMapPtr',
    'Material',
    'MaterialPtr',
    'Transform',
    'TransformPtr',
    'BoneInfo',
    'BoneInfoPtr',
    'Model',
    'ModelPtr',
    'ModelAnimation',
    'ModelAnimationPtr',
    'Ray',
    'RayPtr',
    'RayCollision',
    'RayCollisionPtr',
    'BoundingBox',
    'BoundingBoxPtr',
    'Wave',
    'WavePtr',
    'AudioStream',
    'AudioStreamPtr',
    'Sound',
    'SoundPtr',
    'Music',
    'MusicPtr',
    'VrDeviceInfo',
    'VrDeviceInfoPtr',
    'VrStereoConfig',
    'VrStereoConfigPtr',
    'FilePathList',
    'FilePathListPtr',
    'RAYLIB_VERSION',
    'PI',
    'DEG2RAD',
    'RAD2DEG',
    'LIGHTGRAY',
    'GRAY',
    'DARKGRAY',
    'YELLOW',
    'GOLD',
    'ORANGE',
    'PINK',
    'RED',
    'MAROON',
    'GREEN',
    'LIME',
    'DARKGREEN',
    'SKYBLUE',
    'BLUE',
    'DARKBLUE',
    'PURPLE',
    'VIOLET',
    'DARKPURPLE',
    'BEIGE',
    'BROWN',
    'DARKBROWN',
    'WHITE',
    'BLACK',
    'BLANK',
    'MAGENTA',
    'RAYWHITE',
    'ConfigFlags',
    'FLAG_VSYNC_HINT',
    'FLAG_FULLSCREEN_MODE',
    'FLAG_WINDOW_RESIZABLE',
    'FLAG_WINDOW_UNDECORATED',
    'FLAG_WINDOW_HIDDEN',
    'FLAG_WINDOW_MINIMIZED',
    'FLAG_WINDOW_MAXIMIZED',
    'FLAG_WINDOW_UNFOCUSED',
    'FLAG_WINDOW_TOPMOST',
    'FLAG_WINDOW_ALWAYS_RUN',
    'FLAG_WINDOW_TRANSPARENT',
    'FLAG_WINDOW_HIGHDPI',
    'FLAG_WINDOW_MOUSE_PASSTHROUGH',
    'FLAG_MSAA_4X_HINT',
    'FLAG_INTERLACED_HINT',
    'TraceLogLevel',
    'LOG_ALL',
    'LOG_TRACE',
    'LOG_DEBUG',
    'LOG_INFO',
    'LOG_WARNING',
    'LOG_ERROR',
    'LOG_FATAL',
    'LOG_NONE',
    'KeyboardKey',
    'KEY_NULL',
    'KEY_APOSTROPHE',
    'KEY_COMMA',
    'KEY_MINUS',
    'KEY_PERIOD',
    'KEY_SLASH',
    'KEY_ZERO',
    'KEY_ONE',
    'KEY_TWO',
    'KEY_THREE',
    'KEY_FOUR',
    'KEY_FIVE',
    'KEY_SIX',
    'KEY_SEVEN',
    'KEY_EIGHT',
    'KEY_NINE',
    'KEY_SEMICOLON',
    'KEY_EQUAL',
    'KEY_A',
    'KEY_B',
    'KEY_C',
    'KEY_D',
    'KEY_E',
    'KEY_F',
    'KEY_G',
    'KEY_H',
    'KEY_I',
    'KEY_J',
    'KEY_K',
    'KEY_L',
    'KEY_M',
    'KEY_N',
    'KEY_O',
    'KEY_P',
    'KEY_Q',
    'KEY_R',
    'KEY_S',
    'KEY_T',
    'KEY_U',
    'KEY_V',
    'KEY_W',
    'KEY_X',
    'KEY_Y',
    'KEY_Z',
    'KEY_LEFT_BRACKET',
    'KEY_BACKSLASH',
    'KEY_RIGHT_BRACKET',
    'KEY_GRAVE',
    'KEY_SPACE',
    'KEY_ESCAPE',
    'KEY_ENTER',
    'KEY_TAB',
    'KEY_BACKSPACE',
    'KEY_INSERT',
    'KEY_DELETE',
    'KEY_RIGHT',
    'KEY_LEFT',
    'KEY_DOWN',
    'KEY_UP',
    'KEY_PAGE_UP',
    'KEY_PAGE_DOWN',
    'KEY_HOME',
    'KEY_END',
    'KEY_CAPS_LOCK',
    'KEY_SCROLL_LOCK',
    'KEY_NUM_LOCK',
    'KEY_PRINT_SCREEN',
    'KEY_PAUSE',
    'KEY_F1',
    'KEY_F2',
    'KEY_F3',
    'KEY_F4',
    'KEY_F5',
    'KEY_F6',
    'KEY_F7',
    'KEY_F8',
    'KEY_F9',
    'KEY_F10',
    'KEY_F11',
    'KEY_F12',
    'KEY_LEFT_SHIFT',
    'KEY_LEFT_CONTROL',
    'KEY_LEFT_ALT',
    'KEY_LEFT_SUPER',
    'KEY_RIGHT_SHIFT',
    'KEY_RIGHT_CONTROL',
    'KEY_RIGHT_ALT',
    'KEY_RIGHT_SUPER',
    'KEY_KB_MENU',
    'KEY_KP_0',
    'KEY_KP_1',
    'KEY_KP_2',
    'KEY_KP_3',
    'KEY_KP_4',
    'KEY_KP_5',
    'KEY_KP_6',
    'KEY_KP_7',
    'KEY_KP_8',
    'KEY_KP_9',
    'KEY_KP_DECIMAL',
    'KEY_KP_DIVIDE',
    'KEY_KP_MULTIPLY',
    'KEY_KP_SUBTRACT',
    'KEY_KP_ADD',
    'KEY_KP_ENTER',
    'KEY_KP_EQUAL',
    'KEY_BACK',
    'KEY_MENU',
    'KEY_VOLUME_UP',
    'KEY_VOLUME_DOWN',
    'MouseButton',
    'MOUSE_BUTTON_LEFT',
    'MOUSE_BUTTON_RIGHT',
    'MOUSE_BUTTON_MIDDLE',
    'MOUSE_BUTTON_SIDE',
    'MOUSE_BUTTON_EXTRA',
    'MOUSE_BUTTON_FORWARD',
    'MOUSE_BUTTON_BACK',
    'MouseCursor',
    'MOUSE_CURSOR_DEFAULT',
    'MOUSE_CURSOR_ARROW',
    'MOUSE_CURSOR_IBEAM',
    'MOUSE_CURSOR_CROSSHAIR',
    'MOUSE_CURSOR_POINTING_HAND',
    'MOUSE_CURSOR_RESIZE_EW',
    'MOUSE_CURSOR_RESIZE_NS',
    'MOUSE_CURSOR_RESIZE_NWSE',
    'MOUSE_CURSOR_RESIZE_NESW',
    'MOUSE_CURSOR_RESIZE_ALL',
    'MOUSE_CURSOR_NOT_ALLOWED',
    'GamepadButton',
    'GAMEPAD_BUTTON_UNKNOWN',
    'GAMEPAD_BUTTON_LEFT_FACE_UP',
    'GAMEPAD_BUTTON_LEFT_FACE_RIGHT',
    'GAMEPAD_BUTTON_LEFT_FACE_DOWN',
    'GAMEPAD_BUTTON_LEFT_FACE_LEFT',
    'GAMEPAD_BUTTON_RIGHT_FACE_UP',
    'GAMEPAD_BUTTON_RIGHT_FACE_RIGHT',
    'GAMEPAD_BUTTON_RIGHT_FACE_DOWN',
    'GAMEPAD_BUTTON_RIGHT_FACE_LEFT',
    'GAMEPAD_BUTTON_LEFT_TRIGGER_1',
    'GAMEPAD_BUTTON_LEFT_TRIGGER_2',
    'GAMEPAD_BUTTON_RIGHT_TRIGGER_1',
    'GAMEPAD_BUTTON_RIGHT_TRIGGER_2',
    'GAMEPAD_BUTTON_MIDDLE_LEFT',
    'GAMEPAD_BUTTON_MIDDLE',
    'GAMEPAD_BUTTON_MIDDLE_RIGHT',
    'GAMEPAD_BUTTON_LEFT_THUMB',
    'GAMEPAD_BUTTON_RIGHT_THUMB',
    'GamepadAxis',
    'GAMEPAD_AXIS_LEFT_X',
    'GAMEPAD_AXIS_LEFT_Y',
    'GAMEPAD_AXIS_RIGHT_X',
    'GAMEPAD_AXIS_RIGHT_Y',
    'GAMEPAD_AXIS_LEFT_TRIGGER',
    'GAMEPAD_AXIS_RIGHT_TRIGGER',
    'MaterialMapIndex',
    'MATERIAL_MAP_ALBEDO',
    'MATERIAL_MAP_METALNESS',
    'MATERIAL_MAP_NORMAL',
    'MATERIAL_MAP_ROUGHNESS',
    'MATERIAL_MAP_OCCLUSION',
    'MATERIAL_MAP_EMISSION',
    'MATERIAL_MAP_HEIGHT',
    'MATERIAL_MAP_CUBEMAP',
    'MATERIAL_MAP_IRRADIANCE',
    'MATERIAL_MAP_PREFILTER',
    'MATERIAL_MAP_BRDF',
    'ShaderLocationIndex',
    'SHADER_LOC_VERTEX_POSITION',
    'SHADER_LOC_VERTEX_TEXCOORD01',
    'SHADER_LOC_VERTEX_TEXCOORD02',
    'SHADER_LOC_VERTEX_NORMAL',
    'SHADER_LOC_VERTEX_TANGENT',
    'SHADER_LOC_VERTEX_COLOR',
    'SHADER_LOC_MATRIX_MVP',
    'SHADER_LOC_MATRIX_VIEW',
    'SHADER_LOC_MATRIX_PROJECTION',
    'SHADER_LOC_MATRIX_MODEL',
    'SHADER_LOC_MATRIX_NORMAL',
    'SHADER_LOC_VECTOR_VIEW',
    'SHADER_LOC_COLOR_DIFFUSE',
    'SHADER_LOC_COLOR_SPECULAR',
    'SHADER_LOC_COLOR_AMBIENT',
    'SHADER_LOC_MAP_ALBEDO',
    'SHADER_LOC_MAP_METALNESS',
    'SHADER_LOC_MAP_NORMAL',
    'SHADER_LOC_MAP_ROUGHNESS',
    'SHADER_LOC_MAP_OCCLUSION',
    'SHADER_LOC_MAP_EMISSION',
    'SHADER_LOC_MAP_HEIGHT',
    'SHADER_LOC_MAP_CUBEMAP',
    'SHADER_LOC_MAP_IRRADIANCE',
    'SHADER_LOC_MAP_PREFILTER',
    'SHADER_LOC_MAP_BRDF',
    'ShaderUniformDataType',
    'SHADER_UNIFORM_FLOAT',
    'SHADER_UNIFORM_VEC2',
    'SHADER_UNIFORM_VEC3',
    'SHADER_UNIFORM_VEC4',
    'SHADER_UNIFORM_INT',
    'SHADER_UNIFORM_IVEC2',
    'SHADER_UNIFORM_IVEC3',
    'SHADER_UNIFORM_IVEC4',
    'SHADER_UNIFORM_SAMPLER2D',
    'ShaderAttributeDataType',
    'SHADER_ATTRIB_FLOAT',
    'SHADER_ATTRIB_VEC2',
    'SHADER_ATTRIB_VEC3',
    'SHADER_ATTRIB_VEC4',
    'PixelFormat',
    'PIXELFORMAT_UNCOMPRESSED_GRAYSCALE',
    'PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA',
    'PIXELFORMAT_UNCOMPRESSED_R5G6B5',
    'PIXELFORMAT_UNCOMPRESSED_R8G8B8',
    'PIXELFORMAT_UNCOMPRESSED_R5G5B5A1',
    'PIXELFORMAT_UNCOMPRESSED_R4G4B4A4',
    'PIXELFORMAT_UNCOMPRESSED_R8G8B8A8',
    'PIXELFORMAT_UNCOMPRESSED_R32',
    'PIXELFORMAT_UNCOMPRESSED_R32G32B32',
    'PIXELFORMAT_UNCOMPRESSED_R32G32B32A32',
    'PIXELFORMAT_COMPRESSED_DXT1_RGB',
    'PIXELFORMAT_COMPRESSED_DXT1_RGBA',
    'PIXELFORMAT_COMPRESSED_DXT3_RGBA',
    'PIXELFORMAT_COMPRESSED_DXT5_RGBA',
    'PIXELFORMAT_COMPRESSED_ETC1_RGB',
    'PIXELFORMAT_COMPRESSED_ETC2_RGB',
    'PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA',
    'PIXELFORMAT_COMPRESSED_PVRT_RGB',
    'PIXELFORMAT_COMPRESSED_PVRT_RGBA',
    'PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA',
    'PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA',
    'TextureFilter',
    'TEXTURE_FILTER_POINT',
    'TEXTURE_FILTER_BILINEAR',
    'TEXTURE_FILTER_TRILINEAR',
    'TEXTURE_FILTER_ANISOTROPIC_4X',
    'TEXTURE_FILTER_ANISOTROPIC_8X',
    'TEXTURE_FILTER_ANISOTROPIC_16X',
    'TextureWrap',
    'TEXTURE_WRAP_REPEAT',
    'TEXTURE_WRAP_CLAMP',
    'TEXTURE_WRAP_MIRROR_REPEAT',
    'TEXTURE_WRAP_MIRROR_CLAMP',
    'CubemapLayout',
    'CUBEMAP_LAYOUT_AUTO_DETECT',
    'CUBEMAP_LAYOUT_LINE_VERTICAL',
    'CUBEMAP_LAYOUT_LINE_HORIZONTAL',
    'CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR',
    'CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE',
    'CUBEMAP_LAYOUT_PANORAMA',
    'FontType',
    'FONT_DEFAULT',
    'FONT_BITMAP',
    'FONT_SDF',
    'BlendMode',
    'BLEND_ALPHA',
    'BLEND_ADDITIVE',
    'BLEND_MULTIPLIED',
    'BLEND_ADD_COLORS',
    'BLEND_SUBTRACT_COLORS',
    'BLEND_ALPHA_PREMULTIPLY',
    'BLEND_CUSTOM',
    'Gesture',
    'GESTURE_NONE',
    'GESTURE_TAP',
    'GESTURE_DOUBLETAP',
    'GESTURE_HOLD',
    'GESTURE_DRAG',
    'GESTURE_SWIPE_RIGHT',
    'GESTURE_SWIPE_LEFT',
    'GESTURE_SWIPE_UP',
    'GESTURE_SWIPE_DOWN',
    'GESTURE_PINCH_IN',
    'GESTURE_PINCH_OUT',
    'CameraMode',
    'CAMERA_CUSTOM',
    'CAMERA_FREE',
    'CAMERA_ORBITAL',
    'CAMERA_FIRST_PERSON',
    'CAMERA_THIRD_PERSON',
    'CameraProjection',
    'CAMERA_PERSPECTIVE',
    'CAMERA_ORTHOGRAPHIC',
    'NPatchLayout',
    'NPATCH_NINE_PATCH',
    'NPATCH_THREE_PATCH_VERTICAL',
    'NPATCH_THREE_PATCH_HORIZONTAL',
    'TraceLogCallback',
    'LoadFileDataCallback',
    'SaveFileDataCallback',
    'LoadFileTextCallback',
    'SaveFileTextCallback',
    'AudioCallback',
    'init_window',
    'window_should_close',
    'close_window',
    'is_window_ready',
    'is_window_fullscreen',
    'is_window_hidden',
    'is_window_minimized',
    'is_window_maximized',
    'is_window_focused',
    'is_window_resized',
    'is_window_state',
    'set_window_state',
    'clear_window_state',
    'toggle_fullscreen',
    'maximize_window',
    'minimize_window',
    'restore_window',
    'set_window_icon',
    'set_window_title',
    'set_window_position',
    'set_window_monitor',
    'set_window_min_size',
    'set_window_size',
    'set_window_opacity',
    'get_window_handle',
    'get_screen_width',
    'get_screen_height',
    'get_render_width',
    'get_render_height',
    'get_monitor_count',
    'get_current_monitor',
    'get_monitor_position',
    'get_monitor_width',
    'get_monitor_height',
    'get_monitor_physical_width',
    'get_monitor_physical_height',
    'get_monitor_refresh_rate',
    'get_window_position',
    'get_window_scale_dpi',
    'get_monitor_name',
    'set_clipboard_text',
    'get_clipboard_text',
    'enable_event_waiting',
    'disable_event_waiting',
    'swap_screen_buffer',
    'poll_input_events',
    'wait_time',
    'show_cursor',
    'hide_cursor',
    'is_cursor_hidden',
    'enable_cursor',
    'disable_cursor',
    'is_cursor_on_screen',
    'clear_background',
    'begin_drawing',
    'end_drawing',
    'begin_mode2d',
    'end_mode2d',
    'begin_mode3d',
    'end_mode3d',
    'begin_texture_mode',
    'end_texture_mode',
    'begin_shader_mode',
    'end_shader_mode',
    'begin_blend_mode',
    'end_blend_mode',
    'begin_scissor_mode',
    'end_scissor_mode',
    'begin_vr_stereo_mode',
    'end_vr_stereo_mode',
    'load_vr_stereo_config',
    'unload_vr_stereo_config',
    'load_shader',
    'load_shader_from_memory',
    'get_shader_location',
    'get_shader_location_attrib',
    'set_shader_value',
    'set_shader_value_v',
    'set_shader_value_matrix',
    'set_shader_value_texture',
    'unload_shader',
    'get_mouse_ray',
    'get_camera_matrix',
    'get_camera_matrix2d',
    'get_world_to_screen',
    'get_screen_to_world2d',
    'get_world_to_screen_ex',
    'get_world_to_screen2d',
    'set_target_fps',
    'get_fps',
    'get_frame_time',
    'get_time',
    'get_random_value',
    'set_random_seed',
    'take_screenshot',
    'set_config_flags',
    'trace_log',
    'set_trace_log_level',
    'mem_alloc',
    'mem_realloc',
    'mem_free',
    'open_url',
    'set_trace_log_callback',
    'set_load_file_data_callback',
    'set_save_file_data_callback',
    'set_load_file_text_callback',
    'set_save_file_text_callback',
    'load_file_data',
    'unload_file_data',
    'save_file_data',
    'export_data_as_code',
    'load_file_text',
    'unload_file_text',
    'save_file_text',
    'file_exists',
    'directory_exists',
    'is_file_extension',
    'get_file_length',
    'get_file_extension',
    'get_file_name',
    'get_file_name_without_ext',
    'get_directory_path',
    'get_prev_directory_path',
    'get_working_directory',
    'get_application_directory',
    'change_directory',
    'is_path_file',
    'load_directory_files',
    'load_directory_files_ex',
    'unload_directory_files',
    'is_file_dropped',
    'load_dropped_files',
    'unload_dropped_files',
    'get_file_mod_time',
    'compress_data',
    'decompress_data',
    'encode_data_base64',
    'decode_data_base64',
    'is_key_pressed',
    'is_key_down',
    'is_key_released',
    'is_key_up',
    'set_exit_key',
    'get_key_pressed',
    'get_char_pressed',
    'is_gamepad_available',
    'get_gamepad_name',
    'is_gamepad_button_pressed',
    'is_gamepad_button_down',
    'is_gamepad_button_released',
    'is_gamepad_button_up',
    'get_gamepad_button_pressed',
    'get_gamepad_axis_count',
    'get_gamepad_axis_movement',
    'set_gamepad_mappings',
    'is_mouse_button_pressed',
    'is_mouse_button_down',
    'is_mouse_button_released',
    'is_mouse_button_up',
    'get_mouse_x',
    'get_mouse_y',
    'get_mouse_position',
    'get_mouse_delta',
    'set_mouse_position',
    'set_mouse_offset',
    'set_mouse_scale',
    'get_mouse_wheel_move',
    'get_mouse_wheel_move_v',
    'set_mouse_cursor',
    'get_touch_x',
    'get_touch_y',
    'get_touch_position',
    'get_touch_point_id',
    'get_touch_point_count',
    'set_gestures_enabled',
    'is_gesture_detected',
    'get_gesture_detected',
    'get_gesture_hold_duration',
    'get_gesture_drag_vector',
    'get_gesture_drag_angle',
    'get_gesture_pinch_vector',
    'get_gesture_pinch_angle',
    'set_camera_mode',
    'update_camera',
    'set_camera_pan_control',
    'set_camera_alt_control',
    'set_camera_smooth_zoom_control',
    'set_camera_move_controls',
    'set_shapes_texture',
    'draw_pixel',
    'draw_pixel_v',
    'draw_line',
    'draw_line_v',
    'draw_line_ex',
    'draw_line_bezier',
    'draw_line_bezier_quad',
    'draw_line_bezier_cubic',
    'draw_line_strip',
    'draw_circle',
    'draw_circle_sector',
    'draw_circle_sector_lines',
    'draw_circle_gradient',
    'draw_circle_v',
    'draw_circle_lines',
    'draw_ellipse',
    'draw_ellipse_lines',
    'draw_ring',
    'draw_ring_lines',
    'draw_rectangle',
    'draw_rectangle_v',
    'draw_rectangle_rec',
    'draw_rectangle_pro',
    'draw_rectangle_gradient_v',
    'draw_rectangle_gradient_h',
    'draw_rectangle_gradient_ex',
    'draw_rectangle_lines',
    'draw_rectangle_lines_ex',
    'draw_rectangle_rounded',
    'draw_rectangle_rounded_lines',
    'draw_triangle',
    'draw_triangle_lines',
    'draw_triangle_fan',
    'draw_triangle_strip',
    'draw_poly',
    'draw_poly_lines',
    'draw_poly_lines_ex',
    'check_collision_recs',
    'check_collision_circles',
    'check_collision_circle_rec',
    'check_collision_point_rec',
    'check_collision_point_circle',
    'check_collision_point_triangle',
    'check_collision_lines',
    'check_collision_point_line',
    'get_collision_rec',
    'load_image',
    'load_image_raw',
    'load_image_anim',
    'load_image_from_memory',
    'load_image_from_texture',
    'load_image_from_screen',
    'unload_image',
    'export_image',
    'export_image_as_code',
    'gen_image_color',
    'gen_image_gradient_v',
    'gen_image_gradient_h',
    'gen_image_gradient_radial',
    'gen_image_checked',
    'gen_image_white_noise',
    'gen_image_cellular',
    'image_copy',
    'image_from_image',
    'image_text',
    'image_text_ex',
    'image_format',
    'image_to_pot',
    'image_crop',
    'image_alpha_crop',
    'image_alpha_clear',
    'image_alpha_mask',
    'image_alpha_premultiply',
    'image_resize',
    'image_resize_nn',
    'image_resize_canvas',
    'image_mipmaps',
    'image_dither',
    'image_flip_vertical',
    'image_flip_horizontal',
    'image_rotate_cw',
    'image_rotate_ccw',
    'image_color_tint',
    'image_color_invert',
    'image_color_grayscale',
    'image_color_contrast',
    'image_color_brightness',
    'image_color_replace',
    'load_image_colors',
    'load_image_palette',
    'unload_image_colors',
    'unload_image_palette',
    'get_image_alpha_border',
    'get_image_color',
    'image_clear_background',
    'image_draw_pixel',
    'image_draw_pixel_v',
    'image_draw_line',
    'image_draw_line_v',
    'image_draw_circle',
    'image_draw_circle_v',
    'image_draw_rectangle',
    'image_draw_rectangle_v',
    'image_draw_rectangle_rec',
    'image_draw_rectangle_lines',
    'image_draw',
    'image_draw_text',
    'image_draw_text_ex',
    'load_texture',
    'load_texture_from_image',
    'load_texture_cubemap',
    'load_render_texture',
    'unload_texture',
    'unload_render_texture',
    'update_texture',
    'update_texture_rec',
    'gen_texture_mipmaps',
    'set_texture_filter',
    'set_texture_wrap',
    'draw_texture',
    'draw_texture_v',
    'draw_texture_ex',
    'draw_texture_rec',
    'draw_texture_quad',
    'draw_texture_tiled',
    'draw_texture_pro',
    'draw_texture_npatch',
    'draw_texture_poly',
    'fade',
    'color_to_int',
    'color_normalize',
    'color_from_normalized',
    'color_to_hsv',
    'color_from_hsv',
    'color_alpha',
    'color_alpha_blend',
    'get_color',
    'get_pixel_color',
    'set_pixel_color',
    'get_pixel_data_size',
    'get_font_default',
    'load_font',
    'load_font_ex',
    'load_font_from_image',
    'load_font_from_memory',
    'load_font_data',
    'gen_image_font_atlas',
    'unload_font_data',
    'unload_font',
    'export_font_as_code',
    'draw_fps',
    'draw_text',
    'draw_text_ex',
    'draw_text_pro',
    'draw_text_codepoint',
    'draw_text_codepoints',
    'measure_text',
    'measure_text_ex',
    'get_glyph_index',
    'get_glyph_info',
    'get_glyph_atlas_rec',
    'load_codepoints',
    'unload_codepoints',
    'get_codepoint_count',
    'get_codepoint',
    'codepoint_to_utf8',
    'text_codepoints_to_utf8',
    'text_copy',
    'text_is_equal',
    'text_length',
    'text_format',
    'text_subtext',
    'text_replace',
    'text_insert',
    'text_join',
    'text_split',
    'text_append',
    'text_find_index',
    'text_to_upper',
    'text_to_lower',
    'text_to_pascal',
    'text_to_integer',
    'draw_line3d',
    'draw_point3d',
    'draw_circle3d',
    'draw_triangle3d',
    'draw_triangle_strip3d',
    'draw_cube',
    'draw_cube_v',
    'draw_cube_wires',
    'draw_cube_wires_v',
    'draw_cube_texture',
    'draw_cube_texture_rec',
    'draw_sphere',
    'draw_sphere_ex',
    'draw_sphere_wires',
    'draw_cylinder',
    'draw_cylinder_ex',
    'draw_cylinder_wires',
    'draw_cylinder_wires_ex',
    'draw_plane',
    'draw_ray',
    'draw_grid',
    'load_model',
    'load_model_from_mesh',
    'unload_model',
    'unload_model_keep_meshes',
    'get_model_bounding_box',
    'draw_model',
    'draw_model_ex',
    'draw_model_wires',
    'draw_model_wires_ex',
    'draw_bounding_box',
    'draw_billboard',
    'draw_billboard_rec',
    'draw_billboard_pro',
    'upload_mesh',
    'update_mesh_buffer',
    'unload_mesh',
    'draw_mesh',
    'draw_mesh_instanced',
    'export_mesh',
    'get_mesh_bounding_box',
    'gen_mesh_tangents',
    'gen_mesh_poly',
    'gen_mesh_plane',
    'gen_mesh_cube',
    'gen_mesh_sphere',
    'gen_mesh_hemi_sphere',
    'gen_mesh_cylinder',
    'gen_mesh_cone',
    'gen_mesh_torus',
    'gen_mesh_knot',
    'gen_mesh_heightmap',
    'gen_mesh_cubicmap',
    'load_materials',
    'load_material_default',
    'unload_material',
    'set_material_texture',
    'set_model_mesh_material',
    'load_model_animations',
    'update_model_animation',
    'unload_model_animation',
    'unload_model_animations',
    'is_model_animation_valid',
    'check_collision_spheres',
    'check_collision_boxes',
    'check_collision_box_sphere',
    'get_ray_collision_sphere',
    'get_ray_collision_box',
    'get_ray_collision_mesh',
    'get_ray_collision_triangle',
    'get_ray_collision_quad',
    'init_audio_device',
    'close_audio_device',
    'is_audio_device_ready',
    'set_master_volume',
    'load_wave',
    'load_wave_from_memory',
    'load_sound',
    'load_sound_from_wave',
    'update_sound',
    'unload_wave',
    'unload_sound',
    'export_wave',
    'export_wave_as_code',
    'play_sound',
    'stop_sound',
    'pause_sound',
    'resume_sound',
    'play_sound_multi',
    'stop_sound_multi',
    'get_sounds_playing',
    'is_sound_playing',
    'set_sound_volume',
    'set_sound_pitch',
    'set_sound_pan',
    'wave_copy',
    'wave_crop',
    'wave_format',
    'load_wave_samples',
    'unload_wave_samples',
    'load_music_stream',
    'load_music_stream_from_memory',
    'unload_music_stream',
    'play_music_stream',
    'is_music_stream_playing',
    'update_music_stream',
    'stop_music_stream',
    'pause_music_stream',
    'resume_music_stream',
    'seek_music_stream',
    'set_music_volume',
    'set_music_pitch',
    'set_music_pan',
    'get_music_time_length',
    'get_music_time_played',
    'load_audio_stream',
    'unload_audio_stream',
    'update_audio_stream',
    'is_audio_stream_processed',
    'play_audio_stream',
    'pause_audio_stream',
    'resume_audio_stream',
    'is_audio_stream_playing',
    'stop_audio_stream',
    'set_audio_stream_volume',
    'set_audio_stream_pitch',
    'set_audio_stream_pan',
    'set_audio_stream_buffer_size_default',
    'set_audio_stream_callback',
    'attach_audio_stream_processor',
    'detach_audio_stream_processor',
]

# region LIBRARY LOADING

# region CDLLEX

DONT_RESOLVE_DLL_REFERENCES = 0x00000001
LOAD_LIBRARY_AS_DATAFILE = 0x00000002
LOAD_WITH_ALTERED_SEARCH_PATH = 0x00000008
LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010  # NT 6.1
LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020  # NT 6.0
LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040  # NT 6.0

# These cannot be combined with LOAD_WITH_ALTERED_SEARCH_PATH.
# Install update KB2533623 for NT 6.0 & 6.1.
LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000

kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)


def check_bool(result, func, args):
    if not result:
        raise ctypes.WinError(ctypes.get_last_error())
    return args


kernel32.LoadLibraryExW.errcheck = check_bool
kernel32.LoadLibraryExW.restype = wintypes.HMODULE
kernel32.LoadLibraryExW.argtypes = (wintypes.LPCWSTR,
                                    wintypes.HANDLE,
                                    wintypes.DWORD)


class CDLLEx(ctypes.CDLL):
    def __init__(self, name, mode=0, handle=None,
                 use_errno=True, use_last_error=False):
        if handle is None:
            handle = kernel32.LoadLibraryExW(name, None, mode)
        super(CDLLEx, self).__init__(name, mode, handle,
                                     use_errno, use_last_error)


class WinDLLEx(ctypes.WinDLL):
    def __init__(self, name, mode=0, handle=None,
                 use_errno=False, use_last_error=True):
        if handle is None:
            handle = kernel32.LoadLibraryExW(name, None, mode)
        super(WinDLLEx, self).__init__(name, mode, handle,
                                       use_errno, use_last_error)


# endregion (cdllex)


_lib_fname = {
    'win32': 'raylib.dll',
    'linux': 'libraylib.so.3.7.0',
    'darwin': 'libraylib.3.7.0.dylib'
}

_lib_platform = sys.platform

if _lib_platform == 'win32':
    _bitness = platform.architecture()[0]
else:
    _bitness = '64bit' if sys.maxsize > 2 ** 32 else '32bit'

_lib_fname_abspath = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin', _bitness, _lib_fname[_lib_platform])
_lib_fname_abspath = os.path.normcase(os.path.normpath(_lib_fname_abspath))

print(
    """Library loading info:
    platform: {}
    bitness: {}
    absolute path: {}
    exists: {}
    is file: {}
    """.format(
        _lib_platform,
        _bitness,
        _lib_fname_abspath,
        'yes' if os.path.exists(_lib_fname_abspath) else 'no',
        'yes' if os.path.isfile(_lib_fname_abspath) else 'no'
    )
)

rlapi = None
if _lib_platform == 'win32':

    try:
        rlapi = CDLLEx(_lib_fname_abspath, LOAD_WITH_ALTERED_SEARCH_PATH)
    except OSError:
        print("Unable to load {}.".format(_lib_fname[_lib_platform]))
        rlapi = None
else:
    rlapi = CDLL(_lib_fname_abspath)

if rlapi is None:
    print("Failed to load shared library.")
    exit()
else:
    print("Shared library loaded succesfully.", rlapi)

# Vector component swizzling helppers
_VEC2_GET_SWZL = re.compile(r'[xy]{,4}')
_VEC3_GET_SWZL = re.compile(r'[xyz]{,4}')
_VEC4_GET_SWZL = re.compile(r'[xyzw]{,4}')
_RGBA_GET_SWZL = re.compile(r'[rgba]{4}')

_VEC2_SET_SWZL = re.compile(r'[xy]{,2}')
_VEC3_SET_SWZL = re.compile(r'[xyz]{,3}')
_VEC4_SET_SWZL = re.compile(r'[xyzw]{,4}')
_RGBA_SET_SWZL = re.compile(r'[rgba]{1,4}')

_number = (int, float)

# region FUNCTIONS


def _classname(obj):
    return obj.__class__.__name__


def _clsname(obj):
    return obj.__class__.__name__


def is_number(obj):
    return isinstance(obj, _number)


def is_component(value):
    return isinstance(value, int) and 0 <= value <= 255


def _clamp_rgba(*args):
    return tuple(value & 255 for value in args)


def _str_in(value):
    return value.encode('utf-8', 'ignore') if isinstance(value, str) else value


def _str_in2(values):
    return _arr(CharPtr, tuple(_str_in(value) for value in values))


def _str_out(value):
    return value.decode('utf-8', 'ignore') if isinstance(value, bytes) else value


def _arr(typ, data):
    return (typ * len(data))(*data)


def _arr2(typ, data):
    arr = typ * len(data[0])
    return (arr * len(data))(*data)

# region TYPE CAST FUNCS


def _float(value):
    return float(value)


def _int(value, ranged=None):
    if ranged:
        return max(ranged[0], min(int(value), ranged[1]))
    return int(value)


def _vec2(seq):
    if isinstance(seq, Vector2):
        return seq
    x, y = seq
    return Vector2(_float(x), _float(y))


def _vec3(seq):
    if isinstance(seq, Vector3):
        return seq
    x, y, z = seq
    return Vector3(float(x), float(y), float(z))


def _vec4(seq):
    if isinstance(seq, Vector4):
        return seq
    x, y, z, w = seq
    return Vector4(float(x), float(y), float(z), float(w))


def _rect(seq):
    if isinstance(seq, Rectangle):
        return seq
    x, y, w, h = seq
    return Rectangle(float(x), float(y), float(w), float(h))


def _color(seq):
    if isinstance(seq, Color):
        return seq
    r, g, b, q = seq
    rng = 0, 255
    return Color(_int(r, rng), _int(r, rng), _int(b, rng), _int(q, rng))

# endregion (type cast funcs)

# endregion (functions)

# region TYPES

Bool = c_bool
BoolPtr = POINTER(c_bool)
Byte = c_byte
BytePtr = POINTER(c_byte)
Char = c_char
CharPtr = POINTER(c_char)
Short = c_short
ShortPtr = POINTER(c_short)
Int = c_long
IntPtr = POINTER(c_long)
Long = c_long
LongPtr = POINTER(c_long)
UByte = c_ubyte
UBytePtr = POINTER(c_ubyte)
UShort = c_ushort
UShortPtr = POINTER(c_ushort)
UInt = c_ulong
UIntPtr = POINTER(c_ulong)
ULong = c_ulong
ULongPtr = POINTER(c_ulong)
Float = c_float
FloatPtr = POINTER(c_float)
Double = c_double
DoublePtr = POINTER(c_double)
VoidPtr = c_void_p
VoidPtrPtr = POINTER(c_void_p)
CharPtr = c_char_p
CharPtrPtr = POINTER(c_char_p)

class Vector2(Structure):
    '''Vector2, 2 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
    ]

    @classmethod
    def array_of(cls, vector2_sequence):
        '''Creates and returns an array of Vector2s'''
        arr = cls * len(vector2_sequence)
        return arr(*vector2_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Vector2'''
        return cls(None, None)

    def __init__(self, x, y):
        '''Vector2, 2 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        '''
        super(Vector2, self).__init__(x, y)

    def __str__(self):
        return "[Vector2 at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Vector2 instance'''
        return byref(self)

    def __len__(self):
        return 2

    def __getitem__(self, key):
        return (self.x, self.y).__getitem__(key)

    def __getattr__(self, attr):
        m = _VEC2_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: float, 2: Vector2, 3: Vector3, 4: Vector4}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _VEC2_SET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Vector2, self).__setattr__(attr, float(value))
        else:
            for i, ch in enumerate(attr):
                super(Vector2, self).__setattr__(ch, float(value[i]))

    def todict(self):
        '''Returns a dict mapping this Vector2's components'''
        return {'x': self.x, 'y': self.y}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Vector2's components'''
        self.x = float(d.get('x', self.x))
        self.y = float(d.get('y', self.y))


# Pointer type to Vector2s
Vector2Ptr = POINTER(Vector2)



class Vector3(Structure):
    '''Vector3, 3 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
        ('z', Float),
    ]

    @classmethod
    def array_of(cls, vector3_sequence):
        '''Creates and returns an array of Vector3s'''
        arr = cls * len(vector3_sequence)
        return arr(*vector3_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Vector3'''
        return cls(None, None, None)

    def __init__(self, x, y, z):
        '''Vector3, 3 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        :param float z: `float` in C raylib
        '''
        super(Vector3, self).__init__(x, y, z)

    def __str__(self):
        return "[Vector3 at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Vector3 instance'''
        return byref(self)

    def __len__(self):
        return 3

    def __getitem__(self, key):
        return (self.x, self.y, self.z).__getitem__(key)

    def __getattr__(self, attr):
        m = _VEC3_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: float, 2: Vector2, 3: Vector3, 4: Vector4}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _VEC3_SET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Vector3, self).__setattr__(attr, float(value))
        else:
            for i, ch in enumerate(attr):
                super(Vector3, self).__setattr__(ch, float(value[i]))

    def todict(self):
        '''Returns a dict mapping this Vector3's components'''
        return {'x': self.x, 'y': self.y, 'z': self.z}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Vector3's components'''
        self.x = float(d.get('x', self.x))
        self.y = float(d.get('y', self.y))
        self.z = float(d.get('z', self.z))


# Pointer type to Vector3s
Vector3Ptr = POINTER(Vector3)



class Vector4(Structure):
    '''Vector4, 4 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
        ('z', Float),
        ('w', Float),
    ]

    @classmethod
    def array_of(cls, vector4_sequence):
        '''Creates and returns an array of Vector4s'''
        arr = cls * len(vector4_sequence)
        return arr(*vector4_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Vector4'''
        return cls(None, None, None, None)

    def __init__(self, x, y, z, w):
        '''Vector4, 4 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        :param float z: `float` in C raylib
        :param float w: `float` in C raylib
        '''
        super(Vector4, self).__init__(x, y, z, w)

    def __str__(self):
        return "[Vector4 at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Vector4 instance'''
        return byref(self)

    def __len__(self):
        return 4

    def __getitem__(self, key):
        return (self.x, self.y. self.z, self.w).__getitem__(key)

    def __getattr__(self, attr):
        m = _VEC4_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: float, 2: Vector2, 3: Vector3, 4: Vector4}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _VEC4_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Vector4, self).__setattr__(attr, float(value))
        else:
            for i, ch in enumerate(attr):
                super(Vector4, self).__setattr__(ch, float(value[i]))

    def todict(self):
        '''Returns a dict mapping this Vector4's components'''
        return {'x': self.x, 'y': self.y, 'z': self.z, 'w': self.w}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Vector4's components'''
        self.x = float(d.get('x', self.x))
        self.y = float(d.get('y', self.y))
        self.z = float(d.get('z', self.z))
        self.w = float(d.get('w', self.w))


# Pointer type to Vector4s
Vector4Ptr = POINTER(Vector4)

# Quaternion, 4 components (Vector4 alias)
Quaternion = Vector4
QuaternionPtr = Vector4Ptr



class Matrix(Structure):
    '''Matrix, 4x4 components, column major, OpenGL style, right handed'''
    _fields_ = [
        ('m0', Float),
        ('m4', Float),
        ('m8', Float),
        ('m12', Float),
        ('m1', Float),
        ('m5', Float),
        ('m9', Float),
        ('m13', Float),
        ('m2', Float),
        ('m6', Float),
        ('m10', Float),
        ('m14', Float),
        ('m3', Float),
        ('m7', Float),
        ('m11', Float),
        ('m15', Float),
    ]

    @classmethod
    def array_of(cls, matrix_sequence):
        '''Creates and returns an array of Matrixs'''
        arr = cls * len(matrix_sequence)
        return arr(*matrix_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Matrix'''
        return cls(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def __init__(self, m0, m4, m8, m12, m1, m5, m9, m13, m2, m6, m10, m14, m3, m7, m11, m15):
        '''Matrix, 4x4 components, column major, OpenGL style, right handed

        :param float m0: `float` in C raylib
        :param float m4: `float` in C raylib
        :param float m8: `float` in C raylib
        :param float m12: `float` in C raylib
        :param float m1: `float` in C raylib
        :param float m5: `float` in C raylib
        :param float m9: `float` in C raylib
        :param float m13: `float` in C raylib
        :param float m2: `float` in C raylib
        :param float m6: `float` in C raylib
        :param float m10: `float` in C raylib
        :param float m14: `float` in C raylib
        :param float m3: `float` in C raylib
        :param float m7: `float` in C raylib
        :param float m11: `float` in C raylib
        :param float m15: `float` in C raylib
        '''
        super(Matrix, self).__init__(m0, m4, m8, m12, m1, m5, m9, m13, m2, m6, m10, m14, m3, m7, m11, m15)

    def __str__(self):
        return "[Matrix at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Matrix instance'''
        return byref(self)


# Pointer type to Matrixs
MatrixPtr = POINTER(Matrix)



class Color(Structure):
    '''Color, 4 components, R8G8B8A8 (32bit)'''
    _fields_ = [
        ('r', UByte),
        ('g', UByte),
        ('b', UByte),
        ('a', UByte),
    ]

    @classmethod
    def array_of(cls, color_sequence):
        '''Creates and returns an array of Colors'''
        arr = cls * len(color_sequence)
        return arr(*color_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Color'''
        return cls(None, None, None, None)

    def __init__(self, r, g, b, a):
        '''Color, 4 components, R8G8B8A8 (32bit)

        :param int r: `unsigned char` in C raylib
        :param int g: `unsigned char` in C raylib
        :param int b: `unsigned char` in C raylib
        :param int a: `unsigned char` in C raylib
        '''
        super(Color, self).__init__(r, g, b, a)

    def __str__(self):
        return "[Color at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Color instance'''
        return byref(self)

    def __len__(self):
        return 4

    def __getitem__(self, key):
        return (self.r, self.g, self.b, self.a).__getitem__(key)

    def __getattr__(self, attr):
        m = _RGBA_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: int, 4: Color}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _RGBA_SET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Color, self).__setattr__(attr, int(value))
        else:
            for i, ch in enumerate(attr):
                super(Color, self).__setattr__(ch, int(value[i]))

    def todict(self):
        '''Returns a dict mapping this Color's components'''
        return {'r': self.r, 'g': self.g, 'b': self.b, 'a': self.a}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Color's components'''
        self.r = int(d.get('r', self.r))
        self.g = int(d.get('g', self.g))
        self.b = int(d.get('b', self.b))
        self.a = int(d.get('a', self.a))


# Pointer type to Colors
ColorPtr = POINTER(Color)



class Rectangle(Structure):
    '''Rectangle, 4 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
        ('width', Float),
        ('height', Float),
    ]

    @classmethod
    def array_of(cls, rectangle_sequence):
        '''Creates and returns an array of Rectangles'''
        arr = cls * len(rectangle_sequence)
        return arr(*rectangle_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Rectangle'''
        return cls(None, None, None, None)

    def __init__(self, x, y, width, height):
        '''Rectangle, 4 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        :param float width: `float` in C raylib
        :param float height: `float` in C raylib
        '''
        super(Rectangle, self).__init__(x, y, width, height)

    def __str__(self):
        return "[Rectangle at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Rectangle instance'''
        return byref(self)


# Pointer type to Rectangles
RectanglePtr = POINTER(Rectangle)



class Image(Structure):
    '''Image, pixel data stored in CPU memory (RAM)'''
    _fields_ = [
        ('data', VoidPtr),
        ('width', Int),
        ('height', Int),
        ('mipmaps', Int),
        ('format', Int),
    ]

    @classmethod
    def array_of(cls, image_sequence):
        '''Creates and returns an array of Images'''
        arr = cls * len(image_sequence)
        return arr(*image_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Image'''
        return cls(None, None, None, None, None)

    def __init__(self, data, width, height, mipmaps, format):
        '''Image, pixel data stored in CPU memory (RAM)

        :param bytes data: `void *` in C raylib
        :param int width: `int` in C raylib
        :param int height: `int` in C raylib
        :param int mipmaps: `int` in C raylib
        :param int format: `int` in C raylib
        '''
        super(Image, self).__init__(data, width, height, mipmaps, format)

    def __str__(self):
        return "[Image at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Image instance'''
        return byref(self)


# Pointer type to Images
ImagePtr = POINTER(Image)



class Texture(Structure):
    '''Texture, tex data stored in GPU memory (VRAM)'''
    _fields_ = [
        ('id', UInt),
        ('width', Int),
        ('height', Int),
        ('mipmaps', Int),
        ('format', Int),
    ]

    @classmethod
    def array_of(cls, texture_sequence):
        '''Creates and returns an array of Textures'''
        arr = cls * len(texture_sequence)
        return arr(*texture_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Texture'''
        return cls(None, None, None, None, None)

    def __init__(self, id, width, height, mipmaps, format):
        '''Texture, tex data stored in GPU memory (VRAM)

        :param int id: `unsigned int` in C raylib
        :param int width: `int` in C raylib
        :param int height: `int` in C raylib
        :param int mipmaps: `int` in C raylib
        :param int format: `int` in C raylib
        '''
        super(Texture, self).__init__(id, width, height, mipmaps, format)

    def __str__(self):
        return "[Texture at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Texture instance'''
        return byref(self)


# Pointer type to Textures
TexturePtr = POINTER(Texture)

# Texture2D, same as Texture
Texture2D = Texture
Texture2DPtr = TexturePtr


# TextureCubemap, same as Texture
TextureCubemap = Texture
TextureCubemapPtr = TexturePtr



class RenderTexture(Structure):
    '''RenderTexture, fbo for texture rendering'''
    _fields_ = [
        ('id', UInt),
        ('texture', Texture),
        ('depth', Texture),
    ]

    @classmethod
    def array_of(cls, render_texture_sequence):
        '''Creates and returns an array of RenderTextures'''
        arr = cls * len(render_texture_sequence)
        return arr(*render_texture_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized RenderTexture'''
        return cls(None, None, None)

    def __init__(self, id, texture, depth):
        '''RenderTexture, fbo for texture rendering

        :param int id: `unsigned int` in C raylib
        :param Texture texture: `Texture` in C raylib
        :param Texture depth: `Texture` in C raylib
        '''
        super(RenderTexture, self).__init__(id, texture, depth)

    def __str__(self):
        return "[RenderTexture at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this RenderTexture instance'''
        return byref(self)


# Pointer type to RenderTextures
RenderTexturePtr = POINTER(RenderTexture)

# RenderTexture2D, same as RenderTexture
RenderTexture2D = RenderTexture
RenderTexture2DPtr = RenderTexturePtr



class NPatchInfo(Structure):
    '''NPatchInfo, n-patch layout info'''
    _fields_ = [
        ('source', Rectangle),
        ('left', Int),
        ('top', Int),
        ('right', Int),
        ('bottom', Int),
        ('layout', Int),
    ]

    @classmethod
    def array_of(cls, npatch_info_sequence):
        '''Creates and returns an array of NPatchInfos'''
        arr = cls * len(npatch_info_sequence)
        return arr(*npatch_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized NPatchInfo'''
        return cls(None, None, None, None, None, None)

    def __init__(self, source, left, top, right, bottom, layout):
        '''NPatchInfo, n-patch layout info

        :param Rectangle source: `Rectangle` in C raylib
        :param int left: `int` in C raylib
        :param int top: `int` in C raylib
        :param int right: `int` in C raylib
        :param int bottom: `int` in C raylib
        :param int layout: `int` in C raylib
        '''
        super(NPatchInfo, self).__init__(source, left, top, right, bottom, layout)

    def __str__(self):
        return "[NPatchInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this NPatchInfo instance'''
        return byref(self)


# Pointer type to NPatchInfos
NPatchInfoPtr = POINTER(NPatchInfo)



class GlyphInfo(Structure):
    '''GlyphInfo, font characters glyphs info'''
    _fields_ = [
        ('value', Int),
        ('offset_x', Int),
        ('offset_y', Int),
        ('advance_x', Int),
        ('image', Image),
    ]

    @classmethod
    def array_of(cls, glyph_info_sequence):
        '''Creates and returns an array of GlyphInfos'''
        arr = cls * len(glyph_info_sequence)
        return arr(*glyph_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized GlyphInfo'''
        return cls(None, None, None, None, None)

    def __init__(self, value, offset_x, offset_y, advance_x, image):
        '''GlyphInfo, font characters glyphs info

        :param int value: `int` in C raylib
        :param int offsetX: `int` in C raylib
        :param int offsetY: `int` in C raylib
        :param int advanceX: `int` in C raylib
        :param Image image: `Image` in C raylib
        '''
        super(GlyphInfo, self).__init__(value, offset_x, offset_y, advance_x, image)

    def __str__(self):
        return "[GlyphInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this GlyphInfo instance'''
        return byref(self)


# Pointer type to GlyphInfos
GlyphInfoPtr = POINTER(GlyphInfo)



class Font(Structure):
    '''Font, font texture and GlyphInfo array data'''
    _fields_ = [
        ('base_size', Int),
        ('glyph_count', Int),
        ('glyph_padding', Int),
        ('texture', Texture2D),
        ('recs', RectanglePtr),
        ('glyphs', GlyphInfoPtr),
    ]

    @classmethod
    def array_of(cls, font_sequence):
        '''Creates and returns an array of Fonts'''
        arr = cls * len(font_sequence)
        return arr(*font_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Font'''
        return cls(None, None, None, None, None, None)

    def __init__(self, base_size, glyph_count, glyph_padding, texture, recs, glyphs):
        '''Font, font texture and GlyphInfo array data

        :param int baseSize: `int` in C raylib
        :param int glyphCount: `int` in C raylib
        :param int glyphPadding: `int` in C raylib
        :param Texture2D texture: `Texture2D` in C raylib
        :param RectanglePtr recs: `Rectangle *` in C raylib
        :param GlyphInfoPtr glyphs: `GlyphInfo *` in C raylib
        '''
        super(Font, self).__init__(base_size, glyph_count, glyph_padding, texture, recs, glyphs)

    def __str__(self):
        return "[Font at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Font instance'''
        return byref(self)


# Pointer type to Fonts
FontPtr = POINTER(Font)



class Camera3D(Structure):
    '''Camera, defines position/orientation in 3d space'''
    _fields_ = [
        ('position', Vector3),
        ('target', Vector3),
        ('up', Vector3),
        ('fovy', Float),
        ('projection', Int),
    ]

    @classmethod
    def array_of(cls, camera3d_sequence):
        '''Creates and returns an array of Camera3Ds'''
        arr = cls * len(camera3d_sequence)
        return arr(*camera3d_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Camera3D'''
        return cls(None, None, None, None, None)

    def __init__(self, position, target, up, fovy, projection):
        '''Camera, defines position/orientation in 3d space

        :param Vector3 position: `Vector3` in C raylib
        :param Vector3 target: `Vector3` in C raylib
        :param Vector3 up: `Vector3` in C raylib
        :param float fovy: `float` in C raylib
        :param int projection: `int` in C raylib
        '''
        super(Camera3D, self).__init__(position, target, up, fovy, projection)

    def __str__(self):
        return "[Camera3D at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Camera3D instance'''
        return byref(self)


# Pointer type to Camera3Ds
Camera3DPtr = POINTER(Camera3D)

# Camera type fallback, defaults to Camera3D
Camera = Camera3D
CameraPtr = Camera3DPtr



class Camera2D(Structure):
    '''Camera2D, defines position/orientation in 2d space'''
    _fields_ = [
        ('offset', Vector2),
        ('target', Vector2),
        ('rotation', Float),
        ('zoom', Float),
    ]

    @classmethod
    def array_of(cls, camera2d_sequence):
        '''Creates and returns an array of Camera2Ds'''
        arr = cls * len(camera2d_sequence)
        return arr(*camera2d_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Camera2D'''
        return cls(None, None, None, None)

    def __init__(self, offset, target, rotation, zoom):
        '''Camera2D, defines position/orientation in 2d space

        :param Vector2 offset: `Vector2` in C raylib
        :param Vector2 target: `Vector2` in C raylib
        :param float rotation: `float` in C raylib
        :param float zoom: `float` in C raylib
        '''
        super(Camera2D, self).__init__(offset, target, rotation, zoom)

    def __str__(self):
        return "[Camera2D at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Camera2D instance'''
        return byref(self)


# Pointer type to Camera2Ds
Camera2DPtr = POINTER(Camera2D)



class Mesh(Structure):
    '''Mesh, vertex data and vao/vbo'''
    _fields_ = [
        ('vertex_count', Int),
        ('triangle_count', Int),
        ('vertices', FloatPtr),
        ('texcoords', FloatPtr),
        ('texcoords2', FloatPtr),
        ('normals', FloatPtr),
        ('tangents', FloatPtr),
        ('colors', UBytePtr),
        ('indices', UShortPtr),
        ('anim_vertices', FloatPtr),
        ('anim_normals', FloatPtr),
        ('bone_ids', UBytePtr),
        ('bone_weights', FloatPtr),
        ('vao_id', UInt),
        ('vbo_id', UIntPtr),
    ]

    @classmethod
    def array_of(cls, mesh_sequence):
        '''Creates and returns an array of Meshs'''
        arr = cls * len(mesh_sequence)
        return arr(*mesh_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Mesh'''
        return cls(None, None, None, None, None, None, None, None, None, None, None, None, None, None, None)

    def __init__(self, vertex_count, triangle_count, vertices, texcoords, texcoords2, normals, tangents, colors, indices, anim_vertices, anim_normals, bone_ids, bone_weights, vao_id, vbo_id):
        '''Mesh, vertex data and vao/vbo

        :param int vertexCount: `int` in C raylib
        :param int triangleCount: `int` in C raylib
        :param Sequence[float] vertices: `float *` in C raylib
        :param Sequence[float] texcoords: `float *` in C raylib
        :param Sequence[float] texcoords2: `float *` in C raylib
        :param Sequence[float] normals: `float *` in C raylib
        :param Sequence[float] tangents: `float *` in C raylib
        :param bytes colors: `unsigned char *` in C raylib
        :param Sequence[int] indices: `unsigned short *` in C raylib
        :param Sequence[float] animVertices: `float *` in C raylib
        :param Sequence[float] animNormals: `float *` in C raylib
        :param bytes boneIds: `unsigned char *` in C raylib
        :param Sequence[float] boneWeights: `float *` in C raylib
        :param int vaoId: `unsigned int` in C raylib
        :param Sequence[int] vboId: `unsigned int *` in C raylib
        '''
        super(Mesh, self).__init__(vertex_count, triangle_count, vertices, texcoords, texcoords2, normals, tangents, colors, indices, anim_vertices, anim_normals, bone_ids, bone_weights, vao_id, vbo_id)

    def __str__(self):
        return "[Mesh at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Mesh instance'''
        return byref(self)


# Pointer type to Meshs
MeshPtr = POINTER(Mesh)



class Shader(Structure):
    '''Shader'''
    _fields_ = [
        ('id', UInt),
        ('locs', IntPtr),
    ]

    @classmethod
    def array_of(cls, shader_sequence):
        '''Creates and returns an array of Shaders'''
        arr = cls * len(shader_sequence)
        return arr(*shader_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Shader'''
        return cls(None, None)

    def __init__(self, id, locs):
        '''Shader

        :param int id: `unsigned int` in C raylib
        :param Sequence[int] locs: `int *` in C raylib
        '''
        super(Shader, self).__init__(id, locs)

    def __str__(self):
        return "[Shader at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Shader instance'''
        return byref(self)


# Pointer type to Shaders
ShaderPtr = POINTER(Shader)



class MaterialMap(Structure):
    '''MaterialMap'''
    _fields_ = [
        ('texture', Texture2D),
        ('color', Color),
        ('value', Float),
    ]

    @classmethod
    def array_of(cls, material_map_sequence):
        '''Creates and returns an array of MaterialMaps'''
        arr = cls * len(material_map_sequence)
        return arr(*material_map_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized MaterialMap'''
        return cls(None, None, None)

    def __init__(self, texture, color, value):
        '''MaterialMap

        :param Texture2D texture: `Texture2D` in C raylib
        :param Color color: `Color` in C raylib
        :param float value: `float` in C raylib
        '''
        super(MaterialMap, self).__init__(texture, color, value)

    def __str__(self):
        return "[MaterialMap at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this MaterialMap instance'''
        return byref(self)


# Pointer type to MaterialMaps
MaterialMapPtr = POINTER(MaterialMap)



class Material(Structure):
    '''Material, includes shader and maps'''
    _fields_ = [
        ('shader', Shader),
        ('maps', MaterialMapPtr),
        ('params', Float * 4),
    ]

    @classmethod
    def array_of(cls, material_sequence):
        '''Creates and returns an array of Materials'''
        arr = cls * len(material_sequence)
        return arr(*material_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Material'''
        return cls(None, None, None)

    def __init__(self, shader, maps, params):
        '''Material, includes shader and maps

        :param Shader shader: `Shader` in C raylib
        :param MaterialMapPtr maps: `MaterialMap *` in C raylib
        :param Sequence[float] params: `float[4]` in C raylib
        '''
        super(Material, self).__init__(shader, maps, params)

    def __str__(self):
        return "[Material at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Material instance'''
        return byref(self)


# Pointer type to Materials
MaterialPtr = POINTER(Material)



class Transform(Structure):
    '''Transform, vectex transformation data'''
    _fields_ = [
        ('translation', Vector3),
        ('rotation', Quaternion),
        ('scale', Vector3),
    ]

    @classmethod
    def array_of(cls, transform_sequence):
        '''Creates and returns an array of Transforms'''
        arr = cls * len(transform_sequence)
        return arr(*transform_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Transform'''
        return cls(None, None, None)

    def __init__(self, translation, rotation, scale):
        '''Transform, vectex transformation data

        :param Vector3 translation: `Vector3` in C raylib
        :param Quaternion rotation: `Quaternion` in C raylib
        :param Vector3 scale: `Vector3` in C raylib
        '''
        super(Transform, self).__init__(translation, rotation, scale)

    def __str__(self):
        return "[Transform at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Transform instance'''
        return byref(self)


# Pointer type to Transforms
TransformPtr = POINTER(Transform)



class BoneInfo(Structure):
    '''Bone, skeletal animation bone'''
    _fields_ = [
        ('name', Char * 32),
        ('parent', Int),
    ]

    @classmethod
    def array_of(cls, bone_info_sequence):
        '''Creates and returns an array of BoneInfos'''
        arr = cls * len(bone_info_sequence)
        return arr(*bone_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized BoneInfo'''
        return cls(None, None)

    def __init__(self, name, parent):
        '''Bone, skeletal animation bone

        :param Sequence[bytes] name: `char[32]` in C raylib
        :param int parent: `int` in C raylib
        '''
        super(BoneInfo, self).__init__(name, parent)

    def __str__(self):
        return "[BoneInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this BoneInfo instance'''
        return byref(self)


# Pointer type to BoneInfos
BoneInfoPtr = POINTER(BoneInfo)



class Model(Structure):
    '''Model, meshes, materials and animation data'''
    _fields_ = [
        ('transform', Matrix),
        ('mesh_count', Int),
        ('material_count', Int),
        ('meshes', MeshPtr),
        ('materials', MaterialPtr),
        ('mesh_material', IntPtr),
        ('bone_count', Int),
        ('bones', BoneInfoPtr),
        ('bind_pose', TransformPtr),
    ]

    @classmethod
    def array_of(cls, model_sequence):
        '''Creates and returns an array of Models'''
        arr = cls * len(model_sequence)
        return arr(*model_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Model'''
        return cls(None, None, None, None, None, None, None, None, None)

    def __init__(self, transform, mesh_count, material_count, meshes, materials, mesh_material, bone_count, bones, bind_pose):
        '''Model, meshes, materials and animation data

        :param Matrix transform: `Matrix` in C raylib
        :param int meshCount: `int` in C raylib
        :param int materialCount: `int` in C raylib
        :param MeshPtr meshes: `Mesh *` in C raylib
        :param MaterialPtr materials: `Material *` in C raylib
        :param Sequence[int] meshMaterial: `int *` in C raylib
        :param int boneCount: `int` in C raylib
        :param BoneInfoPtr bones: `BoneInfo *` in C raylib
        :param TransformPtr bindPose: `Transform *` in C raylib
        '''
        super(Model, self).__init__(transform, mesh_count, material_count, meshes, materials, mesh_material, bone_count, bones, bind_pose)

    def __str__(self):
        return "[Model at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Model instance'''
        return byref(self)


# Pointer type to Models
ModelPtr = POINTER(Model)



class ModelAnimation(Structure):
    '''ModelAnimation'''
    _fields_ = [
        ('bone_count', Int),
        ('frame_count', Int),
        ('bones', BoneInfoPtr),
        ('frame_poses', POINTER(TransformPtr)),
    ]

    @classmethod
    def array_of(cls, model_animation_sequence):
        '''Creates and returns an array of ModelAnimations'''
        arr = cls * len(model_animation_sequence)
        return arr(*model_animation_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized ModelAnimation'''
        return cls(None, None, None, None)

    def __init__(self, bone_count, frame_count, bones, frame_poses):
        '''ModelAnimation

        :param int boneCount: `int` in C raylib
        :param int frameCount: `int` in C raylib
        :param BoneInfoPtr bones: `BoneInfo *` in C raylib
        :param Sequence[TransformPtr] framePoses: `Transform **` in C raylib
        '''
        super(ModelAnimation, self).__init__(bone_count, frame_count, bones, frame_poses)

    def __str__(self):
        return "[ModelAnimation at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this ModelAnimation instance'''
        return byref(self)


# Pointer type to ModelAnimations
ModelAnimationPtr = POINTER(ModelAnimation)



class Ray(Structure):
    '''Ray, ray for raycasting'''
    _fields_ = [
        ('position', Vector3),
        ('direction', Vector3),
    ]

    @classmethod
    def array_of(cls, ray_sequence):
        '''Creates and returns an array of Rays'''
        arr = cls * len(ray_sequence)
        return arr(*ray_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Ray'''
        return cls(None, None)

    def __init__(self, position, direction):
        '''Ray, ray for raycasting

        :param Vector3 position: `Vector3` in C raylib
        :param Vector3 direction: `Vector3` in C raylib
        '''
        super(Ray, self).__init__(position, direction)

    def __str__(self):
        return "[Ray at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Ray instance'''
        return byref(self)


# Pointer type to Rays
RayPtr = POINTER(Ray)



class RayCollision(Structure):
    '''RayCollision, ray hit information'''
    _fields_ = [
        ('hit', Bool),
        ('distance', Float),
        ('point', Vector3),
        ('normal', Vector3),
    ]

    @classmethod
    def array_of(cls, ray_collision_sequence):
        '''Creates and returns an array of RayCollisions'''
        arr = cls * len(ray_collision_sequence)
        return arr(*ray_collision_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized RayCollision'''
        return cls(None, None, None, None)

    def __init__(self, hit, distance, point, normal):
        '''RayCollision, ray hit information

        :param bool hit: `bool` in C raylib
        :param float distance: `float` in C raylib
        :param Vector3 point: `Vector3` in C raylib
        :param Vector3 normal: `Vector3` in C raylib
        '''
        super(RayCollision, self).__init__(hit, distance, point, normal)

    def __str__(self):
        return "[RayCollision at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this RayCollision instance'''
        return byref(self)


# Pointer type to RayCollisions
RayCollisionPtr = POINTER(RayCollision)



class BoundingBox(Structure):
    '''BoundingBox'''
    _fields_ = [
        ('min', Vector3),
        ('max', Vector3),
    ]

    @classmethod
    def array_of(cls, bounding_box_sequence):
        '''Creates and returns an array of BoundingBoxs'''
        arr = cls * len(bounding_box_sequence)
        return arr(*bounding_box_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized BoundingBox'''
        return cls(None, None)

    def __init__(self, min, max):
        '''BoundingBox

        :param Vector3 min: `Vector3` in C raylib
        :param Vector3 max: `Vector3` in C raylib
        '''
        super(BoundingBox, self).__init__(min, max)

    def __str__(self):
        return "[BoundingBox at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this BoundingBox instance'''
        return byref(self)


# Pointer type to BoundingBoxs
BoundingBoxPtr = POINTER(BoundingBox)



class Wave(Structure):
    '''Wave, audio wave data'''
    _fields_ = [
        ('frame_count', UInt),
        ('sample_rate', UInt),
        ('sample_size', UInt),
        ('channels', UInt),
        ('data', VoidPtr),
    ]

    @classmethod
    def array_of(cls, wave_sequence):
        '''Creates and returns an array of Waves'''
        arr = cls * len(wave_sequence)
        return arr(*wave_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Wave'''
        return cls(None, None, None, None, None)

    def __init__(self, frame_count, sample_rate, sample_size, channels, data):
        '''Wave, audio wave data

        :param int frameCount: `unsigned int` in C raylib
        :param int sampleRate: `unsigned int` in C raylib
        :param int sampleSize: `unsigned int` in C raylib
        :param int channels: `unsigned int` in C raylib
        :param bytes data: `void *` in C raylib
        '''
        super(Wave, self).__init__(frame_count, sample_rate, sample_size, channels, data)

    def __str__(self):
        return "[Wave at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Wave instance'''
        return byref(self)


# Pointer type to Waves
WavePtr = POINTER(Wave)



class AudioStream(Structure):
    '''AudioStream, custom audio stream'''
    _fields_ = [
        ('buffer', VoidPtr),
        ('processor', VoidPtr),
        ('sample_rate', UInt),
        ('sample_size', UInt),
        ('channels', UInt),
    ]

    @classmethod
    def array_of(cls, audio_stream_sequence):
        '''Creates and returns an array of AudioStreams'''
        arr = cls * len(audio_stream_sequence)
        return arr(*audio_stream_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized AudioStream'''
        return cls(None, None, None, None, None)

    def __init__(self, buffer, processor, sample_rate, sample_size, channels):
        '''AudioStream, custom audio stream

        :param bytes buffer: `rAudioBuffer *` in C raylib
        :param bytes processor: `rAudioProcessor *` in C raylib
        :param int sampleRate: `unsigned int` in C raylib
        :param int sampleSize: `unsigned int` in C raylib
        :param int channels: `unsigned int` in C raylib
        '''
        super(AudioStream, self).__init__(buffer, processor, sample_rate, sample_size, channels)

    def __str__(self):
        return "[AudioStream at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this AudioStream instance'''
        return byref(self)


# Pointer type to AudioStreams
AudioStreamPtr = POINTER(AudioStream)



class Sound(Structure):
    '''Sound'''
    _fields_ = [
        ('stream', AudioStream),
        ('frame_count', UInt),
    ]

    @classmethod
    def array_of(cls, sound_sequence):
        '''Creates and returns an array of Sounds'''
        arr = cls * len(sound_sequence)
        return arr(*sound_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Sound'''
        return cls(None, None)

    def __init__(self, stream, frame_count):
        '''Sound

        :param AudioStream stream: `AudioStream` in C raylib
        :param int frameCount: `unsigned int` in C raylib
        '''
        super(Sound, self).__init__(stream, frame_count)

    def __str__(self):
        return "[Sound at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Sound instance'''
        return byref(self)


# Pointer type to Sounds
SoundPtr = POINTER(Sound)



class Music(Structure):
    '''Music, audio stream, anything longer than ~10 seconds should be streamed'''
    _fields_ = [
        ('stream', AudioStream),
        ('frame_count', UInt),
        ('looping', Bool),
        ('ctx_type', Int),
        ('ctx_data', VoidPtr),
    ]

    @classmethod
    def array_of(cls, music_sequence):
        '''Creates and returns an array of Musics'''
        arr = cls * len(music_sequence)
        return arr(*music_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Music'''
        return cls(None, None, None, None, None)

    def __init__(self, stream, frame_count, looping, ctx_type, ctx_data):
        '''Music, audio stream, anything longer than ~10 seconds should be streamed

        :param AudioStream stream: `AudioStream` in C raylib
        :param int frameCount: `unsigned int` in C raylib
        :param bool looping: `bool` in C raylib
        :param int ctxType: `int` in C raylib
        :param bytes ctxData: `void *` in C raylib
        '''
        super(Music, self).__init__(stream, frame_count, looping, ctx_type, ctx_data)

    def __str__(self):
        return "[Music at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Music instance'''
        return byref(self)


# Pointer type to Musics
MusicPtr = POINTER(Music)



class VrDeviceInfo(Structure):
    '''VrDeviceInfo, Head-Mounted-Display device parameters'''
    _fields_ = [
        ('h_resolution', Int),
        ('v_resolution', Int),
        ('h_screen_size', Float),
        ('v_screen_size', Float),
        ('v_screen_center', Float),
        ('eye_to_screen_distance', Float),
        ('lens_separation_distance', Float),
        ('interpupillary_distance', Float),
        ('lens_distortion_values', Float * 4),
        ('chroma_ab_correction', Float * 4),
    ]

    @classmethod
    def array_of(cls, vr_device_info_sequence):
        '''Creates and returns an array of VrDeviceInfos'''
        arr = cls * len(vr_device_info_sequence)
        return arr(*vr_device_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized VrDeviceInfo'''
        return cls(None, None, None, None, None, None, None, None, None, None)

    def __init__(self, h_resolution, v_resolution, h_screen_size, v_screen_size, v_screen_center, eye_to_screen_distance, lens_separation_distance, interpupillary_distance, lens_distortion_values, chroma_ab_correction):
        '''VrDeviceInfo, Head-Mounted-Display device parameters

        :param int hResolution: `int` in C raylib
        :param int vResolution: `int` in C raylib
        :param float hScreenSize: `float` in C raylib
        :param float vScreenSize: `float` in C raylib
        :param float vScreenCenter: `float` in C raylib
        :param float eyeToScreenDistance: `float` in C raylib
        :param float lensSeparationDistance: `float` in C raylib
        :param float interpupillaryDistance: `float` in C raylib
        :param Sequence[float] lensDistortionValues: `float[4]` in C raylib
        :param Sequence[float] chromaAbCorrection: `float[4]` in C raylib
        '''
        super(VrDeviceInfo, self).__init__(h_resolution, v_resolution, h_screen_size, v_screen_size, v_screen_center, eye_to_screen_distance, lens_separation_distance, interpupillary_distance, lens_distortion_values, chroma_ab_correction)

    def __str__(self):
        return "[VrDeviceInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this VrDeviceInfo instance'''
        return byref(self)


# Pointer type to VrDeviceInfos
VrDeviceInfoPtr = POINTER(VrDeviceInfo)



class VrStereoConfig(Structure):
    '''VrStereoConfig, VR stereo rendering configuration for simulator'''
    _fields_ = [
        ('projection', Matrix * 2),
        ('view_offset', Matrix * 2),
        ('left_lens_center', Float * 2),
        ('right_lens_center', Float * 2),
        ('left_screen_center', Float * 2),
        ('right_screen_center', Float * 2),
        ('scale', Float * 2),
        ('scale_in', Float * 2),
    ]

    @classmethod
    def array_of(cls, vr_stereo_config_sequence):
        '''Creates and returns an array of VrStereoConfigs'''
        arr = cls * len(vr_stereo_config_sequence)
        return arr(*vr_stereo_config_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized VrStereoConfig'''
        return cls(None, None, None, None, None, None, None, None)

    def __init__(self, projection, view_offset, left_lens_center, right_lens_center, left_screen_center, right_screen_center, scale, scale_in):
        '''VrStereoConfig, VR stereo rendering configuration for simulator

        :param Sequence[Matrix] projection: `Matrix[2]` in C raylib
        :param Sequence[Matrix] viewOffset: `Matrix[2]` in C raylib
        :param Sequence[float] leftLensCenter: `float[2]` in C raylib
        :param Sequence[float] rightLensCenter: `float[2]` in C raylib
        :param Sequence[float] leftScreenCenter: `float[2]` in C raylib
        :param Sequence[float] rightScreenCenter: `float[2]` in C raylib
        :param Sequence[float] scale: `float[2]` in C raylib
        :param Sequence[float] scaleIn: `float[2]` in C raylib
        '''
        super(VrStereoConfig, self).__init__(projection, view_offset, left_lens_center, right_lens_center, left_screen_center, right_screen_center, scale, scale_in)

    def __str__(self):
        return "[VrStereoConfig at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this VrStereoConfig instance'''
        return byref(self)


# Pointer type to VrStereoConfigs
VrStereoConfigPtr = POINTER(VrStereoConfig)



class FilePathList(Structure):
    '''File path list'''
    _fields_ = [
        ('capacity', UInt),
        ('count', UInt),
        ('paths', POINTER(CharPtr)),
    ]

    @classmethod
    def array_of(cls, file_path_list_sequence):
        '''Creates and returns an array of FilePathLists'''
        arr = cls * len(file_path_list_sequence)
        return arr(*file_path_list_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized FilePathList'''
        return cls(None, None, None)

    def __init__(self, capacity, count, paths):
        '''File path list

        :param int capacity: `unsigned int` in C raylib
        :param int count: `unsigned int` in C raylib
        :param Sequence[bytes] paths: `char **` in C raylib
        '''
        super(FilePathList, self).__init__(capacity, count, paths)

    def __str__(self):
        return "[FilePathList at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this FilePathList instance'''
        return byref(self)


# Pointer type to FilePathLists
FilePathListPtr = POINTER(FilePathList)



# endregion (types)
# region CONSTANTS AND ENUMS


class ConfigFlags(IntEnum):
    FLAG_VSYNC_HINT = 64
    FLAG_FULLSCREEN_MODE = 2
    FLAG_WINDOW_RESIZABLE = 4
    FLAG_WINDOW_UNDECORATED = 8
    FLAG_WINDOW_HIDDEN = 128
    FLAG_WINDOW_MINIMIZED = 512
    FLAG_WINDOW_MAXIMIZED = 1024
    FLAG_WINDOW_UNFOCUSED = 2048
    FLAG_WINDOW_TOPMOST = 4096
    FLAG_WINDOW_ALWAYS_RUN = 256
    FLAG_WINDOW_TRANSPARENT = 16
    FLAG_WINDOW_HIGHDPI = 8192
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384
    FLAG_MSAA_4X_HINT = 32
    FLAG_INTERLACED_HINT = 65536


# Set to try enabling V-Sync on GPU
FLAG_VSYNC_HINT = ConfigFlags.FLAG_VSYNC_HINT
# Set to run program in fullscreen
FLAG_FULLSCREEN_MODE = ConfigFlags.FLAG_FULLSCREEN_MODE
# Set to allow resizable window
FLAG_WINDOW_RESIZABLE = ConfigFlags.FLAG_WINDOW_RESIZABLE
# Set to disable window decoration (frame and buttons)
FLAG_WINDOW_UNDECORATED = ConfigFlags.FLAG_WINDOW_UNDECORATED
# Set to hide window
FLAG_WINDOW_HIDDEN = ConfigFlags.FLAG_WINDOW_HIDDEN
# Set to minimize window (iconify)
FLAG_WINDOW_MINIMIZED = ConfigFlags.FLAG_WINDOW_MINIMIZED
# Set to maximize window (expanded to monitor)
FLAG_WINDOW_MAXIMIZED = ConfigFlags.FLAG_WINDOW_MAXIMIZED
# Set to window non focused
FLAG_WINDOW_UNFOCUSED = ConfigFlags.FLAG_WINDOW_UNFOCUSED
# Set to window always on top
FLAG_WINDOW_TOPMOST = ConfigFlags.FLAG_WINDOW_TOPMOST
# Set to allow windows running while minimized
FLAG_WINDOW_ALWAYS_RUN = ConfigFlags.FLAG_WINDOW_ALWAYS_RUN
# Set to allow transparent framebuffer
FLAG_WINDOW_TRANSPARENT = ConfigFlags.FLAG_WINDOW_TRANSPARENT
# Set to support HighDPI
FLAG_WINDOW_HIGHDPI = ConfigFlags.FLAG_WINDOW_HIGHDPI
# Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
FLAG_WINDOW_MOUSE_PASSTHROUGH = ConfigFlags.FLAG_WINDOW_MOUSE_PASSTHROUGH
# Set to try enabling MSAA 4X
FLAG_MSAA_4X_HINT = ConfigFlags.FLAG_MSAA_4X_HINT
# Set to try enabling interlaced video format (for V3D)
FLAG_INTERLACED_HINT = ConfigFlags.FLAG_INTERLACED_HINT


class TraceLogLevel(IntEnum):
    LOG_ALL = 0
    LOG_TRACE = 1
    LOG_DEBUG = 2
    LOG_INFO = 3
    LOG_WARNING = 4
    LOG_ERROR = 5
    LOG_FATAL = 6
    LOG_NONE = 7


# Display all logs
LOG_ALL = TraceLogLevel.LOG_ALL
# Trace logging, intended for internal use only
LOG_TRACE = TraceLogLevel.LOG_TRACE
# Debug logging, used for internal debugging, it should be disabled on release builds
LOG_DEBUG = TraceLogLevel.LOG_DEBUG
# Info logging, used for program execution info
LOG_INFO = TraceLogLevel.LOG_INFO
# Warning logging, used on recoverable failures
LOG_WARNING = TraceLogLevel.LOG_WARNING
# Error logging, used on unrecoverable failures
LOG_ERROR = TraceLogLevel.LOG_ERROR
# Fatal logging, used to abort program: exit(EXIT_FAILURE)
LOG_FATAL = TraceLogLevel.LOG_FATAL
# Disable logging
LOG_NONE = TraceLogLevel.LOG_NONE


class KeyboardKey(IntEnum):
    KEY_NULL = 0
    KEY_APOSTROPHE = 39
    KEY_COMMA = 44
    KEY_MINUS = 45
    KEY_PERIOD = 46
    KEY_SLASH = 47
    KEY_ZERO = 48
    KEY_ONE = 49
    KEY_TWO = 50
    KEY_THREE = 51
    KEY_FOUR = 52
    KEY_FIVE = 53
    KEY_SIX = 54
    KEY_SEVEN = 55
    KEY_EIGHT = 56
    KEY_NINE = 57
    KEY_SEMICOLON = 59
    KEY_EQUAL = 61
    KEY_A = 65
    KEY_B = 66
    KEY_C = 67
    KEY_D = 68
    KEY_E = 69
    KEY_F = 70
    KEY_G = 71
    KEY_H = 72
    KEY_I = 73
    KEY_J = 74
    KEY_K = 75
    KEY_L = 76
    KEY_M = 77
    KEY_N = 78
    KEY_O = 79
    KEY_P = 80
    KEY_Q = 81
    KEY_R = 82
    KEY_S = 83
    KEY_T = 84
    KEY_U = 85
    KEY_V = 86
    KEY_W = 87
    KEY_X = 88
    KEY_Y = 89
    KEY_Z = 90
    KEY_LEFT_BRACKET = 91
    KEY_BACKSLASH = 92
    KEY_RIGHT_BRACKET = 93
    KEY_GRAVE = 96
    KEY_SPACE = 32
    KEY_ESCAPE = 256
    KEY_ENTER = 257
    KEY_TAB = 258
    KEY_BACKSPACE = 259
    KEY_INSERT = 260
    KEY_DELETE = 261
    KEY_RIGHT = 262
    KEY_LEFT = 263
    KEY_DOWN = 264
    KEY_UP = 265
    KEY_PAGE_UP = 266
    KEY_PAGE_DOWN = 267
    KEY_HOME = 268
    KEY_END = 269
    KEY_CAPS_LOCK = 280
    KEY_SCROLL_LOCK = 281
    KEY_NUM_LOCK = 282
    KEY_PRINT_SCREEN = 283
    KEY_PAUSE = 284
    KEY_F1 = 290
    KEY_F2 = 291
    KEY_F3 = 292
    KEY_F4 = 293
    KEY_F5 = 294
    KEY_F6 = 295
    KEY_F7 = 296
    KEY_F8 = 297
    KEY_F9 = 298
    KEY_F10 = 299
    KEY_F11 = 300
    KEY_F12 = 301
    KEY_LEFT_SHIFT = 340
    KEY_LEFT_CONTROL = 341
    KEY_LEFT_ALT = 342
    KEY_LEFT_SUPER = 343
    KEY_RIGHT_SHIFT = 344
    KEY_RIGHT_CONTROL = 345
    KEY_RIGHT_ALT = 346
    KEY_RIGHT_SUPER = 347
    KEY_KB_MENU = 348
    KEY_KP_0 = 320
    KEY_KP_1 = 321
    KEY_KP_2 = 322
    KEY_KP_3 = 323
    KEY_KP_4 = 324
    KEY_KP_5 = 325
    KEY_KP_6 = 326
    KEY_KP_7 = 327
    KEY_KP_8 = 328
    KEY_KP_9 = 329
    KEY_KP_DECIMAL = 330
    KEY_KP_DIVIDE = 331
    KEY_KP_MULTIPLY = 332
    KEY_KP_SUBTRACT = 333
    KEY_KP_ADD = 334
    KEY_KP_ENTER = 335
    KEY_KP_EQUAL = 336
    KEY_BACK = 4
    KEY_MENU = 82
    KEY_VOLUME_UP = 24
    KEY_VOLUME_DOWN = 25


# Key: NULL, used for no key pressed
KEY_NULL = KeyboardKey.KEY_NULL
# Key: '
KEY_APOSTROPHE = KeyboardKey.KEY_APOSTROPHE
# Key: ,
KEY_COMMA = KeyboardKey.KEY_COMMA
# Key: -
KEY_MINUS = KeyboardKey.KEY_MINUS
# Key: .
KEY_PERIOD = KeyboardKey.KEY_PERIOD
# Key: /
KEY_SLASH = KeyboardKey.KEY_SLASH
# Key: 0
KEY_ZERO = KeyboardKey.KEY_ZERO
# Key: 1
KEY_ONE = KeyboardKey.KEY_ONE
# Key: 2
KEY_TWO = KeyboardKey.KEY_TWO
# Key: 3
KEY_THREE = KeyboardKey.KEY_THREE
# Key: 4
KEY_FOUR = KeyboardKey.KEY_FOUR
# Key: 5
KEY_FIVE = KeyboardKey.KEY_FIVE
# Key: 6
KEY_SIX = KeyboardKey.KEY_SIX
# Key: 7
KEY_SEVEN = KeyboardKey.KEY_SEVEN
# Key: 8
KEY_EIGHT = KeyboardKey.KEY_EIGHT
# Key: 9
KEY_NINE = KeyboardKey.KEY_NINE
# Key: ;
KEY_SEMICOLON = KeyboardKey.KEY_SEMICOLON
# Key: =
KEY_EQUAL = KeyboardKey.KEY_EQUAL
# Key: A | a
KEY_A = KeyboardKey.KEY_A
# Key: B | b
KEY_B = KeyboardKey.KEY_B
# Key: C | c
KEY_C = KeyboardKey.KEY_C
# Key: D | d
KEY_D = KeyboardKey.KEY_D
# Key: E | e
KEY_E = KeyboardKey.KEY_E
# Key: F | f
KEY_F = KeyboardKey.KEY_F
# Key: G | g
KEY_G = KeyboardKey.KEY_G
# Key: H | h
KEY_H = KeyboardKey.KEY_H
# Key: I | i
KEY_I = KeyboardKey.KEY_I
# Key: J | j
KEY_J = KeyboardKey.KEY_J
# Key: K | k
KEY_K = KeyboardKey.KEY_K
# Key: L | l
KEY_L = KeyboardKey.KEY_L
# Key: M | m
KEY_M = KeyboardKey.KEY_M
# Key: N | n
KEY_N = KeyboardKey.KEY_N
# Key: O | o
KEY_O = KeyboardKey.KEY_O
# Key: P | p
KEY_P = KeyboardKey.KEY_P
# Key: Q | q
KEY_Q = KeyboardKey.KEY_Q
# Key: R | r
KEY_R = KeyboardKey.KEY_R
# Key: S | s
KEY_S = KeyboardKey.KEY_S
# Key: T | t
KEY_T = KeyboardKey.KEY_T
# Key: U | u
KEY_U = KeyboardKey.KEY_U
# Key: V | v
KEY_V = KeyboardKey.KEY_V
# Key: W | w
KEY_W = KeyboardKey.KEY_W
# Key: X | x
KEY_X = KeyboardKey.KEY_X
# Key: Y | y
KEY_Y = KeyboardKey.KEY_Y
# Key: Z | z
KEY_Z = KeyboardKey.KEY_Z
# Key: [
KEY_LEFT_BRACKET = KeyboardKey.KEY_LEFT_BRACKET
# Key: '\'
KEY_BACKSLASH = KeyboardKey.KEY_BACKSLASH
# Key: ]
KEY_RIGHT_BRACKET = KeyboardKey.KEY_RIGHT_BRACKET
# Key: `
KEY_GRAVE = KeyboardKey.KEY_GRAVE
# Key: Space
KEY_SPACE = KeyboardKey.KEY_SPACE
# Key: Esc
KEY_ESCAPE = KeyboardKey.KEY_ESCAPE
# Key: Enter
KEY_ENTER = KeyboardKey.KEY_ENTER
# Key: Tab
KEY_TAB = KeyboardKey.KEY_TAB
# Key: Backspace
KEY_BACKSPACE = KeyboardKey.KEY_BACKSPACE
# Key: Ins
KEY_INSERT = KeyboardKey.KEY_INSERT
# Key: Del
KEY_DELETE = KeyboardKey.KEY_DELETE
# Key: Cursor right
KEY_RIGHT = KeyboardKey.KEY_RIGHT
# Key: Cursor left
KEY_LEFT = KeyboardKey.KEY_LEFT
# Key: Cursor down
KEY_DOWN = KeyboardKey.KEY_DOWN
# Key: Cursor up
KEY_UP = KeyboardKey.KEY_UP
# Key: Page up
KEY_PAGE_UP = KeyboardKey.KEY_PAGE_UP
# Key: Page down
KEY_PAGE_DOWN = KeyboardKey.KEY_PAGE_DOWN
# Key: Home
KEY_HOME = KeyboardKey.KEY_HOME
# Key: End
KEY_END = KeyboardKey.KEY_END
# Key: Caps lock
KEY_CAPS_LOCK = KeyboardKey.KEY_CAPS_LOCK
# Key: Scroll down
KEY_SCROLL_LOCK = KeyboardKey.KEY_SCROLL_LOCK
# Key: Num lock
KEY_NUM_LOCK = KeyboardKey.KEY_NUM_LOCK
# Key: Print screen
KEY_PRINT_SCREEN = KeyboardKey.KEY_PRINT_SCREEN
# Key: Pause
KEY_PAUSE = KeyboardKey.KEY_PAUSE
# Key: F1
KEY_F1 = KeyboardKey.KEY_F1
# Key: F2
KEY_F2 = KeyboardKey.KEY_F2
# Key: F3
KEY_F3 = KeyboardKey.KEY_F3
# Key: F4
KEY_F4 = KeyboardKey.KEY_F4
# Key: F5
KEY_F5 = KeyboardKey.KEY_F5
# Key: F6
KEY_F6 = KeyboardKey.KEY_F6
# Key: F7
KEY_F7 = KeyboardKey.KEY_F7
# Key: F8
KEY_F8 = KeyboardKey.KEY_F8
# Key: F9
KEY_F9 = KeyboardKey.KEY_F9
# Key: F10
KEY_F10 = KeyboardKey.KEY_F10
# Key: F11
KEY_F11 = KeyboardKey.KEY_F11
# Key: F12
KEY_F12 = KeyboardKey.KEY_F12
# Key: Shift left
KEY_LEFT_SHIFT = KeyboardKey.KEY_LEFT_SHIFT
# Key: Control left
KEY_LEFT_CONTROL = KeyboardKey.KEY_LEFT_CONTROL
# Key: Alt left
KEY_LEFT_ALT = KeyboardKey.KEY_LEFT_ALT
# Key: Super left
KEY_LEFT_SUPER = KeyboardKey.KEY_LEFT_SUPER
# Key: Shift right
KEY_RIGHT_SHIFT = KeyboardKey.KEY_RIGHT_SHIFT
# Key: Control right
KEY_RIGHT_CONTROL = KeyboardKey.KEY_RIGHT_CONTROL
# Key: Alt right
KEY_RIGHT_ALT = KeyboardKey.KEY_RIGHT_ALT
# Key: Super right
KEY_RIGHT_SUPER = KeyboardKey.KEY_RIGHT_SUPER
# Key: KB menu
KEY_KB_MENU = KeyboardKey.KEY_KB_MENU
# Key: Keypad 0
KEY_KP_0 = KeyboardKey.KEY_KP_0
# Key: Keypad 1
KEY_KP_1 = KeyboardKey.KEY_KP_1
# Key: Keypad 2
KEY_KP_2 = KeyboardKey.KEY_KP_2
# Key: Keypad 3
KEY_KP_3 = KeyboardKey.KEY_KP_3
# Key: Keypad 4
KEY_KP_4 = KeyboardKey.KEY_KP_4
# Key: Keypad 5
KEY_KP_5 = KeyboardKey.KEY_KP_5
# Key: Keypad 6
KEY_KP_6 = KeyboardKey.KEY_KP_6
# Key: Keypad 7
KEY_KP_7 = KeyboardKey.KEY_KP_7
# Key: Keypad 8
KEY_KP_8 = KeyboardKey.KEY_KP_8
# Key: Keypad 9
KEY_KP_9 = KeyboardKey.KEY_KP_9
# Key: Keypad .
KEY_KP_DECIMAL = KeyboardKey.KEY_KP_DECIMAL
# Key: Keypad /
KEY_KP_DIVIDE = KeyboardKey.KEY_KP_DIVIDE
# Key: Keypad *
KEY_KP_MULTIPLY = KeyboardKey.KEY_KP_MULTIPLY
# Key: Keypad -
KEY_KP_SUBTRACT = KeyboardKey.KEY_KP_SUBTRACT
# Key: Keypad +
KEY_KP_ADD = KeyboardKey.KEY_KP_ADD
# Key: Keypad Enter
KEY_KP_ENTER = KeyboardKey.KEY_KP_ENTER
# Key: Keypad =
KEY_KP_EQUAL = KeyboardKey.KEY_KP_EQUAL
# Key: Android back button
KEY_BACK = KeyboardKey.KEY_BACK
# Key: Android menu button
KEY_MENU = KeyboardKey.KEY_MENU
# Key: Android volume up button
KEY_VOLUME_UP = KeyboardKey.KEY_VOLUME_UP
# Key: Android volume down button
KEY_VOLUME_DOWN = KeyboardKey.KEY_VOLUME_DOWN


class MouseButton(IntEnum):
    MOUSE_BUTTON_LEFT = 0
    MOUSE_BUTTON_RIGHT = 1
    MOUSE_BUTTON_MIDDLE = 2
    MOUSE_BUTTON_SIDE = 3
    MOUSE_BUTTON_EXTRA = 4
    MOUSE_BUTTON_FORWARD = 5
    MOUSE_BUTTON_BACK = 6


# Mouse button left
MOUSE_BUTTON_LEFT = MouseButton.MOUSE_BUTTON_LEFT
# Mouse button right
MOUSE_BUTTON_RIGHT = MouseButton.MOUSE_BUTTON_RIGHT
# Mouse button middle (pressed wheel)
MOUSE_BUTTON_MIDDLE = MouseButton.MOUSE_BUTTON_MIDDLE
# Mouse button side (advanced mouse device)
MOUSE_BUTTON_SIDE = MouseButton.MOUSE_BUTTON_SIDE
# Mouse button extra (advanced mouse device)
MOUSE_BUTTON_EXTRA = MouseButton.MOUSE_BUTTON_EXTRA
# Mouse button fordward (advanced mouse device)
MOUSE_BUTTON_FORWARD = MouseButton.MOUSE_BUTTON_FORWARD
# Mouse button back (advanced mouse device)
MOUSE_BUTTON_BACK = MouseButton.MOUSE_BUTTON_BACK


class MouseCursor(IntEnum):
    MOUSE_CURSOR_DEFAULT = 0
    MOUSE_CURSOR_ARROW = 1
    MOUSE_CURSOR_IBEAM = 2
    MOUSE_CURSOR_CROSSHAIR = 3
    MOUSE_CURSOR_POINTING_HAND = 4
    MOUSE_CURSOR_RESIZE_EW = 5
    MOUSE_CURSOR_RESIZE_NS = 6
    MOUSE_CURSOR_RESIZE_NWSE = 7
    MOUSE_CURSOR_RESIZE_NESW = 8
    MOUSE_CURSOR_RESIZE_ALL = 9
    MOUSE_CURSOR_NOT_ALLOWED = 10


# Default pointer shape
MOUSE_CURSOR_DEFAULT = MouseCursor.MOUSE_CURSOR_DEFAULT
# Arrow shape
MOUSE_CURSOR_ARROW = MouseCursor.MOUSE_CURSOR_ARROW
# Text writing cursor shape
MOUSE_CURSOR_IBEAM = MouseCursor.MOUSE_CURSOR_IBEAM
# Cross shape
MOUSE_CURSOR_CROSSHAIR = MouseCursor.MOUSE_CURSOR_CROSSHAIR
# Pointing hand cursor
MOUSE_CURSOR_POINTING_HAND = MouseCursor.MOUSE_CURSOR_POINTING_HAND
# Horizontal resize/move arrow shape
MOUSE_CURSOR_RESIZE_EW = MouseCursor.MOUSE_CURSOR_RESIZE_EW
# Vertical resize/move arrow shape
MOUSE_CURSOR_RESIZE_NS = MouseCursor.MOUSE_CURSOR_RESIZE_NS
# Top-left to bottom-right diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NWSE = MouseCursor.MOUSE_CURSOR_RESIZE_NWSE
# The top-right to bottom-left diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NESW = MouseCursor.MOUSE_CURSOR_RESIZE_NESW
# The omni-directional resize/move cursor shape
MOUSE_CURSOR_RESIZE_ALL = MouseCursor.MOUSE_CURSOR_RESIZE_ALL
# The operation-not-allowed shape
MOUSE_CURSOR_NOT_ALLOWED = MouseCursor.MOUSE_CURSOR_NOT_ALLOWED


class GamepadButton(IntEnum):
    GAMEPAD_BUTTON_UNKNOWN = 0
    GAMEPAD_BUTTON_LEFT_FACE_UP = 1
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2
    GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3
    GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4
    GAMEPAD_BUTTON_RIGHT_FACE_UP = 5
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8
    GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9
    GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12
    GAMEPAD_BUTTON_MIDDLE_LEFT = 13
    GAMEPAD_BUTTON_MIDDLE = 14
    GAMEPAD_BUTTON_MIDDLE_RIGHT = 15
    GAMEPAD_BUTTON_LEFT_THUMB = 16
    GAMEPAD_BUTTON_RIGHT_THUMB = 17


# Unknown button, just for error checking
GAMEPAD_BUTTON_UNKNOWN = GamepadButton.GAMEPAD_BUTTON_UNKNOWN
# Gamepad left DPAD up button
GAMEPAD_BUTTON_LEFT_FACE_UP = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_UP
# Gamepad left DPAD right button
GAMEPAD_BUTTON_LEFT_FACE_RIGHT = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_RIGHT
# Gamepad left DPAD down button
GAMEPAD_BUTTON_LEFT_FACE_DOWN = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_DOWN
# Gamepad left DPAD left button
GAMEPAD_BUTTON_LEFT_FACE_LEFT = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_LEFT
# Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
GAMEPAD_BUTTON_RIGHT_FACE_UP = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_UP
# Gamepad right button right (i.e. PS3: Square, Xbox: X)
GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_RIGHT
# Gamepad right button down (i.e. PS3: Cross, Xbox: A)
GAMEPAD_BUTTON_RIGHT_FACE_DOWN = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_DOWN
# Gamepad right button left (i.e. PS3: Circle, Xbox: B)
GAMEPAD_BUTTON_RIGHT_FACE_LEFT = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_LEFT
# Gamepad top/back trigger left (first), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_1 = GamepadButton.GAMEPAD_BUTTON_LEFT_TRIGGER_1
# Gamepad top/back trigger left (second), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_2 = GamepadButton.GAMEPAD_BUTTON_LEFT_TRIGGER_2
# Gamepad top/back trigger right (one), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = GamepadButton.GAMEPAD_BUTTON_RIGHT_TRIGGER_1
# Gamepad top/back trigger right (second), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = GamepadButton.GAMEPAD_BUTTON_RIGHT_TRIGGER_2
# Gamepad center buttons, left one (i.e. PS3: Select)
GAMEPAD_BUTTON_MIDDLE_LEFT = GamepadButton.GAMEPAD_BUTTON_MIDDLE_LEFT
# Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
GAMEPAD_BUTTON_MIDDLE = GamepadButton.GAMEPAD_BUTTON_MIDDLE
# Gamepad center buttons, right one (i.e. PS3: Start)
GAMEPAD_BUTTON_MIDDLE_RIGHT = GamepadButton.GAMEPAD_BUTTON_MIDDLE_RIGHT
# Gamepad joystick pressed button left
GAMEPAD_BUTTON_LEFT_THUMB = GamepadButton.GAMEPAD_BUTTON_LEFT_THUMB
# Gamepad joystick pressed button right
GAMEPAD_BUTTON_RIGHT_THUMB = GamepadButton.GAMEPAD_BUTTON_RIGHT_THUMB


class GamepadAxis(IntEnum):
    GAMEPAD_AXIS_LEFT_X = 0
    GAMEPAD_AXIS_LEFT_Y = 1
    GAMEPAD_AXIS_RIGHT_X = 2
    GAMEPAD_AXIS_RIGHT_Y = 3
    GAMEPAD_AXIS_LEFT_TRIGGER = 4
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5


# Gamepad left stick X axis
GAMEPAD_AXIS_LEFT_X = GamepadAxis.GAMEPAD_AXIS_LEFT_X
# Gamepad left stick Y axis
GAMEPAD_AXIS_LEFT_Y = GamepadAxis.GAMEPAD_AXIS_LEFT_Y
# Gamepad right stick X axis
GAMEPAD_AXIS_RIGHT_X = GamepadAxis.GAMEPAD_AXIS_RIGHT_X
# Gamepad right stick Y axis
GAMEPAD_AXIS_RIGHT_Y = GamepadAxis.GAMEPAD_AXIS_RIGHT_Y
# Gamepad back trigger left, pressure level: [1..-1]
GAMEPAD_AXIS_LEFT_TRIGGER = GamepadAxis.GAMEPAD_AXIS_LEFT_TRIGGER
# Gamepad back trigger right, pressure level: [1..-1]
GAMEPAD_AXIS_RIGHT_TRIGGER = GamepadAxis.GAMEPAD_AXIS_RIGHT_TRIGGER


class MaterialMapIndex(IntEnum):
    MATERIAL_MAP_ALBEDO = 0
    MATERIAL_MAP_METALNESS = 1
    MATERIAL_MAP_NORMAL = 2
    MATERIAL_MAP_ROUGHNESS = 3
    MATERIAL_MAP_OCCLUSION = 4
    MATERIAL_MAP_EMISSION = 5
    MATERIAL_MAP_HEIGHT = 6
    MATERIAL_MAP_CUBEMAP = 7
    MATERIAL_MAP_IRRADIANCE = 8
    MATERIAL_MAP_PREFILTER = 9
    MATERIAL_MAP_BRDF = 10


# Albedo material (same as: MATERIAL_MAP_DIFFUSE)
MATERIAL_MAP_ALBEDO = MaterialMapIndex.MATERIAL_MAP_ALBEDO
# Metalness material (same as: MATERIAL_MAP_SPECULAR)
MATERIAL_MAP_METALNESS = MaterialMapIndex.MATERIAL_MAP_METALNESS
# Normal material
MATERIAL_MAP_NORMAL = MaterialMapIndex.MATERIAL_MAP_NORMAL
# Roughness material
MATERIAL_MAP_ROUGHNESS = MaterialMapIndex.MATERIAL_MAP_ROUGHNESS
# Ambient occlusion material
MATERIAL_MAP_OCCLUSION = MaterialMapIndex.MATERIAL_MAP_OCCLUSION
# Emission material
MATERIAL_MAP_EMISSION = MaterialMapIndex.MATERIAL_MAP_EMISSION
# Heightmap material
MATERIAL_MAP_HEIGHT = MaterialMapIndex.MATERIAL_MAP_HEIGHT
# Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_CUBEMAP = MaterialMapIndex.MATERIAL_MAP_CUBEMAP
# Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_IRRADIANCE = MaterialMapIndex.MATERIAL_MAP_IRRADIANCE
# Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_PREFILTER = MaterialMapIndex.MATERIAL_MAP_PREFILTER
# Brdf material
MATERIAL_MAP_BRDF = MaterialMapIndex.MATERIAL_MAP_BRDF


class ShaderLocationIndex(IntEnum):
    SHADER_LOC_VERTEX_POSITION = 0
    SHADER_LOC_VERTEX_TEXCOORD01 = 1
    SHADER_LOC_VERTEX_TEXCOORD02 = 2
    SHADER_LOC_VERTEX_NORMAL = 3
    SHADER_LOC_VERTEX_TANGENT = 4
    SHADER_LOC_VERTEX_COLOR = 5
    SHADER_LOC_MATRIX_MVP = 6
    SHADER_LOC_MATRIX_VIEW = 7
    SHADER_LOC_MATRIX_PROJECTION = 8
    SHADER_LOC_MATRIX_MODEL = 9
    SHADER_LOC_MATRIX_NORMAL = 10
    SHADER_LOC_VECTOR_VIEW = 11
    SHADER_LOC_COLOR_DIFFUSE = 12
    SHADER_LOC_COLOR_SPECULAR = 13
    SHADER_LOC_COLOR_AMBIENT = 14
    SHADER_LOC_MAP_ALBEDO = 15
    SHADER_LOC_MAP_METALNESS = 16
    SHADER_LOC_MAP_NORMAL = 17
    SHADER_LOC_MAP_ROUGHNESS = 18
    SHADER_LOC_MAP_OCCLUSION = 19
    SHADER_LOC_MAP_EMISSION = 20
    SHADER_LOC_MAP_HEIGHT = 21
    SHADER_LOC_MAP_CUBEMAP = 22
    SHADER_LOC_MAP_IRRADIANCE = 23
    SHADER_LOC_MAP_PREFILTER = 24
    SHADER_LOC_MAP_BRDF = 25


# Shader location: vertex attribute: position
SHADER_LOC_VERTEX_POSITION = ShaderLocationIndex.SHADER_LOC_VERTEX_POSITION
# Shader location: vertex attribute: texcoord01
SHADER_LOC_VERTEX_TEXCOORD01 = ShaderLocationIndex.SHADER_LOC_VERTEX_TEXCOORD01
# Shader location: vertex attribute: texcoord02
SHADER_LOC_VERTEX_TEXCOORD02 = ShaderLocationIndex.SHADER_LOC_VERTEX_TEXCOORD02
# Shader location: vertex attribute: normal
SHADER_LOC_VERTEX_NORMAL = ShaderLocationIndex.SHADER_LOC_VERTEX_NORMAL
# Shader location: vertex attribute: tangent
SHADER_LOC_VERTEX_TANGENT = ShaderLocationIndex.SHADER_LOC_VERTEX_TANGENT
# Shader location: vertex attribute: color
SHADER_LOC_VERTEX_COLOR = ShaderLocationIndex.SHADER_LOC_VERTEX_COLOR
# Shader location: matrix uniform: model-view-projection
SHADER_LOC_MATRIX_MVP = ShaderLocationIndex.SHADER_LOC_MATRIX_MVP
# Shader location: matrix uniform: view (camera transform)
SHADER_LOC_MATRIX_VIEW = ShaderLocationIndex.SHADER_LOC_MATRIX_VIEW
# Shader location: matrix uniform: projection
SHADER_LOC_MATRIX_PROJECTION = ShaderLocationIndex.SHADER_LOC_MATRIX_PROJECTION
# Shader location: matrix uniform: model (transform)
SHADER_LOC_MATRIX_MODEL = ShaderLocationIndex.SHADER_LOC_MATRIX_MODEL
# Shader location: matrix uniform: normal
SHADER_LOC_MATRIX_NORMAL = ShaderLocationIndex.SHADER_LOC_MATRIX_NORMAL
# Shader location: vector uniform: view
SHADER_LOC_VECTOR_VIEW = ShaderLocationIndex.SHADER_LOC_VECTOR_VIEW
# Shader location: vector uniform: diffuse color
SHADER_LOC_COLOR_DIFFUSE = ShaderLocationIndex.SHADER_LOC_COLOR_DIFFUSE
# Shader location: vector uniform: specular color
SHADER_LOC_COLOR_SPECULAR = ShaderLocationIndex.SHADER_LOC_COLOR_SPECULAR
# Shader location: vector uniform: ambient color
SHADER_LOC_COLOR_AMBIENT = ShaderLocationIndex.SHADER_LOC_COLOR_AMBIENT
# Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
SHADER_LOC_MAP_ALBEDO = ShaderLocationIndex.SHADER_LOC_MAP_ALBEDO
# Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
SHADER_LOC_MAP_METALNESS = ShaderLocationIndex.SHADER_LOC_MAP_METALNESS
# Shader location: sampler2d texture: normal
SHADER_LOC_MAP_NORMAL = ShaderLocationIndex.SHADER_LOC_MAP_NORMAL
# Shader location: sampler2d texture: roughness
SHADER_LOC_MAP_ROUGHNESS = ShaderLocationIndex.SHADER_LOC_MAP_ROUGHNESS
# Shader location: sampler2d texture: occlusion
SHADER_LOC_MAP_OCCLUSION = ShaderLocationIndex.SHADER_LOC_MAP_OCCLUSION
# Shader location: sampler2d texture: emission
SHADER_LOC_MAP_EMISSION = ShaderLocationIndex.SHADER_LOC_MAP_EMISSION
# Shader location: sampler2d texture: height
SHADER_LOC_MAP_HEIGHT = ShaderLocationIndex.SHADER_LOC_MAP_HEIGHT
# Shader location: samplerCube texture: cubemap
SHADER_LOC_MAP_CUBEMAP = ShaderLocationIndex.SHADER_LOC_MAP_CUBEMAP
# Shader location: samplerCube texture: irradiance
SHADER_LOC_MAP_IRRADIANCE = ShaderLocationIndex.SHADER_LOC_MAP_IRRADIANCE
# Shader location: samplerCube texture: prefilter
SHADER_LOC_MAP_PREFILTER = ShaderLocationIndex.SHADER_LOC_MAP_PREFILTER
# Shader location: sampler2d texture: brdf
SHADER_LOC_MAP_BRDF = ShaderLocationIndex.SHADER_LOC_MAP_BRDF


class ShaderUniformDataType(IntEnum):
    SHADER_UNIFORM_FLOAT = 0
    SHADER_UNIFORM_VEC2 = 1
    SHADER_UNIFORM_VEC3 = 2
    SHADER_UNIFORM_VEC4 = 3
    SHADER_UNIFORM_INT = 4
    SHADER_UNIFORM_IVEC2 = 5
    SHADER_UNIFORM_IVEC3 = 6
    SHADER_UNIFORM_IVEC4 = 7
    SHADER_UNIFORM_SAMPLER2D = 8


# Shader uniform type: float
SHADER_UNIFORM_FLOAT = ShaderUniformDataType.SHADER_UNIFORM_FLOAT
# Shader uniform type: vec2 (2 float)
SHADER_UNIFORM_VEC2 = ShaderUniformDataType.SHADER_UNIFORM_VEC2
# Shader uniform type: vec3 (3 float)
SHADER_UNIFORM_VEC3 = ShaderUniformDataType.SHADER_UNIFORM_VEC3
# Shader uniform type: vec4 (4 float)
SHADER_UNIFORM_VEC4 = ShaderUniformDataType.SHADER_UNIFORM_VEC4
# Shader uniform type: int
SHADER_UNIFORM_INT = ShaderUniformDataType.SHADER_UNIFORM_INT
# Shader uniform type: ivec2 (2 int)
SHADER_UNIFORM_IVEC2 = ShaderUniformDataType.SHADER_UNIFORM_IVEC2
# Shader uniform type: ivec3 (3 int)
SHADER_UNIFORM_IVEC3 = ShaderUniformDataType.SHADER_UNIFORM_IVEC3
# Shader uniform type: ivec4 (4 int)
SHADER_UNIFORM_IVEC4 = ShaderUniformDataType.SHADER_UNIFORM_IVEC4
# Shader uniform type: sampler2d
SHADER_UNIFORM_SAMPLER2D = ShaderUniformDataType.SHADER_UNIFORM_SAMPLER2D


class ShaderAttributeDataType(IntEnum):
    SHADER_ATTRIB_FLOAT = 0
    SHADER_ATTRIB_VEC2 = 1
    SHADER_ATTRIB_VEC3 = 2
    SHADER_ATTRIB_VEC4 = 3


# Shader attribute type: float
SHADER_ATTRIB_FLOAT = ShaderAttributeDataType.SHADER_ATTRIB_FLOAT
# Shader attribute type: vec2 (2 float)
SHADER_ATTRIB_VEC2 = ShaderAttributeDataType.SHADER_ATTRIB_VEC2
# Shader attribute type: vec3 (3 float)
SHADER_ATTRIB_VEC3 = ShaderAttributeDataType.SHADER_ATTRIB_VEC3
# Shader attribute type: vec4 (4 float)
SHADER_ATTRIB_VEC4 = ShaderAttributeDataType.SHADER_ATTRIB_VEC4


class PixelFormat(IntEnum):
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2
    PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3
    PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7
    PIXELFORMAT_UNCOMPRESSED_R32 = 8
    PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10
    PIXELFORMAT_COMPRESSED_DXT1_RGB = 11
    PIXELFORMAT_COMPRESSED_DXT1_RGBA = 12
    PIXELFORMAT_COMPRESSED_DXT3_RGBA = 13
    PIXELFORMAT_COMPRESSED_DXT5_RGBA = 14
    PIXELFORMAT_COMPRESSED_ETC1_RGB = 15
    PIXELFORMAT_COMPRESSED_ETC2_RGB = 16
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 17
    PIXELFORMAT_COMPRESSED_PVRT_RGB = 18
    PIXELFORMAT_COMPRESSED_PVRT_RGBA = 19
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 20
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 21


# 8 bit per pixel (no alpha)
PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = PixelFormat.PIXELFORMAT_UNCOMPRESSED_GRAYSCALE
# 8*2 bpp (2 channels)
PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = PixelFormat.PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA
# 16 bpp
PIXELFORMAT_UNCOMPRESSED_R5G6B5 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R5G6B5
# 24 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R8G8B8
# 16 bpp (1 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R5G5B5A1
# 16 bpp (4 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R4G4B4A4
# 32 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R8G8B8A8
# 32 bpp (1 channel - float)
PIXELFORMAT_UNCOMPRESSED_R32 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R32
# 32*3 bpp (3 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R32G32B32
# 32*4 bpp (4 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R32G32B32A32
# 4 bpp (no alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_DXT1_RGB
# 4 bpp (1 bit alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_DXT1_RGBA
# 8 bpp
PIXELFORMAT_COMPRESSED_DXT3_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_DXT3_RGBA
# 8 bpp
PIXELFORMAT_COMPRESSED_DXT5_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_DXT5_RGBA
# 4 bpp
PIXELFORMAT_COMPRESSED_ETC1_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_ETC1_RGB
# 4 bpp
PIXELFORMAT_COMPRESSED_ETC2_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_ETC2_RGB
# 8 bpp
PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_PVRT_RGB
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_PVRT_RGBA
# 8 bpp
PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA
# 2 bpp
PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA


class TextureFilter(IntEnum):
    TEXTURE_FILTER_POINT = 0
    TEXTURE_FILTER_BILINEAR = 1
    TEXTURE_FILTER_TRILINEAR = 2
    TEXTURE_FILTER_ANISOTROPIC_4X = 3
    TEXTURE_FILTER_ANISOTROPIC_8X = 4
    TEXTURE_FILTER_ANISOTROPIC_16X = 5


# No filter, just pixel approximation
TEXTURE_FILTER_POINT = TextureFilter.TEXTURE_FILTER_POINT
# Linear filtering
TEXTURE_FILTER_BILINEAR = TextureFilter.TEXTURE_FILTER_BILINEAR
# Trilinear filtering (linear with mipmaps)
TEXTURE_FILTER_TRILINEAR = TextureFilter.TEXTURE_FILTER_TRILINEAR
# Anisotropic filtering 4x
TEXTURE_FILTER_ANISOTROPIC_4X = TextureFilter.TEXTURE_FILTER_ANISOTROPIC_4X
# Anisotropic filtering 8x
TEXTURE_FILTER_ANISOTROPIC_8X = TextureFilter.TEXTURE_FILTER_ANISOTROPIC_8X
# Anisotropic filtering 16x
TEXTURE_FILTER_ANISOTROPIC_16X = TextureFilter.TEXTURE_FILTER_ANISOTROPIC_16X


class TextureWrap(IntEnum):
    TEXTURE_WRAP_REPEAT = 0
    TEXTURE_WRAP_CLAMP = 1
    TEXTURE_WRAP_MIRROR_REPEAT = 2
    TEXTURE_WRAP_MIRROR_CLAMP = 3


# Repeats texture in tiled mode
TEXTURE_WRAP_REPEAT = TextureWrap.TEXTURE_WRAP_REPEAT
# Clamps texture to edge pixel in tiled mode
TEXTURE_WRAP_CLAMP = TextureWrap.TEXTURE_WRAP_CLAMP
# Mirrors and repeats the texture in tiled mode
TEXTURE_WRAP_MIRROR_REPEAT = TextureWrap.TEXTURE_WRAP_MIRROR_REPEAT
# Mirrors and clamps to border the texture in tiled mode
TEXTURE_WRAP_MIRROR_CLAMP = TextureWrap.TEXTURE_WRAP_MIRROR_CLAMP


class CubemapLayout(IntEnum):
    CUBEMAP_LAYOUT_AUTO_DETECT = 0
    CUBEMAP_LAYOUT_LINE_VERTICAL = 1
    CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4
    CUBEMAP_LAYOUT_PANORAMA = 5


# Automatically detect layout type
CUBEMAP_LAYOUT_AUTO_DETECT = CubemapLayout.CUBEMAP_LAYOUT_AUTO_DETECT
# Layout is defined by a vertical line with faces
CUBEMAP_LAYOUT_LINE_VERTICAL = CubemapLayout.CUBEMAP_LAYOUT_LINE_VERTICAL
# Layout is defined by an horizontal line with faces
CUBEMAP_LAYOUT_LINE_HORIZONTAL = CubemapLayout.CUBEMAP_LAYOUT_LINE_HORIZONTAL
# Layout is defined by a 3x4 cross with cubemap faces
CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = CubemapLayout.CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR
# Layout is defined by a 4x3 cross with cubemap faces
CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = CubemapLayout.CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE
# Layout is defined by a panorama image (equirectangular map)
CUBEMAP_LAYOUT_PANORAMA = CubemapLayout.CUBEMAP_LAYOUT_PANORAMA


class FontType(IntEnum):
    FONT_DEFAULT = 0
    FONT_BITMAP = 1
    FONT_SDF = 2


# Default font generation, anti-aliased
FONT_DEFAULT = FontType.FONT_DEFAULT
# Bitmap font generation, no anti-aliasing
FONT_BITMAP = FontType.FONT_BITMAP
# SDF font generation, requires external shader
FONT_SDF = FontType.FONT_SDF


class BlendMode(IntEnum):
    BLEND_ALPHA = 0
    BLEND_ADDITIVE = 1
    BLEND_MULTIPLIED = 2
    BLEND_ADD_COLORS = 3
    BLEND_SUBTRACT_COLORS = 4
    BLEND_ALPHA_PREMULTIPLY = 5
    BLEND_CUSTOM = 6


# Blend textures considering alpha (default)
BLEND_ALPHA = BlendMode.BLEND_ALPHA
# Blend textures adding colors
BLEND_ADDITIVE = BlendMode.BLEND_ADDITIVE
# Blend textures multiplying colors
BLEND_MULTIPLIED = BlendMode.BLEND_MULTIPLIED
# Blend textures adding colors (alternative)
BLEND_ADD_COLORS = BlendMode.BLEND_ADD_COLORS
# Blend textures subtracting colors (alternative)
BLEND_SUBTRACT_COLORS = BlendMode.BLEND_SUBTRACT_COLORS
# Blend premultiplied textures considering alpha
BLEND_ALPHA_PREMULTIPLY = BlendMode.BLEND_ALPHA_PREMULTIPLY
# Blend textures using custom src/dst factors (use rlSetBlendMode())
BLEND_CUSTOM = BlendMode.BLEND_CUSTOM


class Gesture(IntEnum):
    GESTURE_NONE = 0
    GESTURE_TAP = 1
    GESTURE_DOUBLETAP = 2
    GESTURE_HOLD = 4
    GESTURE_DRAG = 8
    GESTURE_SWIPE_RIGHT = 16
    GESTURE_SWIPE_LEFT = 32
    GESTURE_SWIPE_UP = 64
    GESTURE_SWIPE_DOWN = 128
    GESTURE_PINCH_IN = 256
    GESTURE_PINCH_OUT = 512


# No gesture
GESTURE_NONE = Gesture.GESTURE_NONE
# Tap gesture
GESTURE_TAP = Gesture.GESTURE_TAP
# Double tap gesture
GESTURE_DOUBLETAP = Gesture.GESTURE_DOUBLETAP
# Hold gesture
GESTURE_HOLD = Gesture.GESTURE_HOLD
# Drag gesture
GESTURE_DRAG = Gesture.GESTURE_DRAG
# Swipe right gesture
GESTURE_SWIPE_RIGHT = Gesture.GESTURE_SWIPE_RIGHT
# Swipe left gesture
GESTURE_SWIPE_LEFT = Gesture.GESTURE_SWIPE_LEFT
# Swipe up gesture
GESTURE_SWIPE_UP = Gesture.GESTURE_SWIPE_UP
# Swipe down gesture
GESTURE_SWIPE_DOWN = Gesture.GESTURE_SWIPE_DOWN
# Pinch in gesture
GESTURE_PINCH_IN = Gesture.GESTURE_PINCH_IN
# Pinch out gesture
GESTURE_PINCH_OUT = Gesture.GESTURE_PINCH_OUT


class CameraMode(IntEnum):
    CAMERA_CUSTOM = 0
    CAMERA_FREE = 1
    CAMERA_ORBITAL = 2
    CAMERA_FIRST_PERSON = 3
    CAMERA_THIRD_PERSON = 4


# Custom camera
CAMERA_CUSTOM = CameraMode.CAMERA_CUSTOM
# Free camera
CAMERA_FREE = CameraMode.CAMERA_FREE
# Orbital camera
CAMERA_ORBITAL = CameraMode.CAMERA_ORBITAL
# First person camera
CAMERA_FIRST_PERSON = CameraMode.CAMERA_FIRST_PERSON
# Third person camera
CAMERA_THIRD_PERSON = CameraMode.CAMERA_THIRD_PERSON


class CameraProjection(IntEnum):
    CAMERA_PERSPECTIVE = 0
    CAMERA_ORTHOGRAPHIC = 1


# Perspective projection
CAMERA_PERSPECTIVE = CameraProjection.CAMERA_PERSPECTIVE
# Orthographic projection
CAMERA_ORTHOGRAPHIC = CameraProjection.CAMERA_ORTHOGRAPHIC


class NPatchLayout(IntEnum):
    NPATCH_NINE_PATCH = 0
    NPATCH_THREE_PATCH_VERTICAL = 1
    NPATCH_THREE_PATCH_HORIZONTAL = 2


# Npatch layout: 3x3 tiles
NPATCH_NINE_PATCH = NPatchLayout.NPATCH_NINE_PATCH
# Npatch layout: 1x3 tiles
NPATCH_THREE_PATCH_VERTICAL = NPatchLayout.NPATCH_THREE_PATCH_VERTICAL
# Npatch layout: 3x1 tiles
NPATCH_THREE_PATCH_HORIZONTAL = NPatchLayout.NPATCH_THREE_PATCH_HORIZONTAL


RAYLIB_VERSION = "4.2"
PI = 3.141592653589793
DEG2RAD = (PI / 180.0)
RAD2DEG = (180.0 / PI)
# Light Gray
LIGHTGRAY = Color(200, 200, 200, 255)
# Gray
GRAY = Color(130, 130, 130, 255)
# Dark Gray
DARKGRAY = Color(80, 80, 80, 255)
# Yellow
YELLOW = Color(253, 249, 0, 255)
# Gold
GOLD = Color(255, 203, 0, 255)
# Orange
ORANGE = Color(255, 161, 0, 255)
# Pink
PINK = Color(255, 109, 194, 255)
# Red
RED = Color(230, 41, 55, 255)
# Maroon
MAROON = Color(190, 33, 55, 255)
# Green
GREEN = Color(0, 228, 48, 255)
# Lime
LIME = Color(0, 158, 47, 255)
# Dark Green
DARKGREEN = Color(0, 117, 44, 255)
# Sky Blue
SKYBLUE = Color(102, 191, 255, 255)
# Blue
BLUE = Color(0, 121, 241, 255)
# Dark Blue
DARKBLUE = Color(0, 82, 172, 255)
# Purple
PURPLE = Color(200, 122, 255, 255)
# Violet
VIOLET = Color(135, 60, 190, 255)
# Dark Purple
DARKPURPLE = Color(112, 31, 126, 255)
# Beige
BEIGE = Color(211, 176, 131, 255)
# Brown
BROWN = Color(127, 106, 79, 255)
# Dark Brown
DARKBROWN = Color(76, 63, 47, 255)
# White
WHITE = Color(255, 255, 255, 255)
# Black
BLACK = Color(0, 0, 0, 255)
# Blank (Transparent)
BLANK = Color(0, 0, 0, 0)
# Magenta
MAGENTA = Color(255, 0, 255, 255)
# My own White (raylib logo)
RAYWHITE = Color(245, 245, 245, 255)
# endregion (constants and enums)
# region CALLBACKS


# Logging: Redirect trace log messages
TraceLogCallback = CFUNCTYPE(Int, CharPtr, VoidPtr)
# FileIO: Load binary data
LoadFileDataCallback = CFUNCTYPE(CharPtr, UIntPtr)
# FileIO: Save binary data
SaveFileDataCallback = CFUNCTYPE(CharPtr, VoidPtr, UInt)
# FileIO: Load text data
LoadFileTextCallback = CFUNCTYPE(CharPtr)
# FileIO: Save text data
SaveFileTextCallback = CFUNCTYPE(CharPtr, CharPtr)
# 
AudioCallback = CFUNCTYPE(VoidPtr, UInt)
# endregion (callbacks)

# region PROTOTYPES


def _wrap(api, argtypes, restype):
    api.argtypes = argtypes
    api.restype = restype


_wrap(rlapi.InitWindow, [Int, Int, CharPtr], None)
_wrap(rlapi.WindowShouldClose, [], Bool)
_wrap(rlapi.CloseWindow, [], None)
_wrap(rlapi.IsWindowReady, [], Bool)
_wrap(rlapi.IsWindowFullscreen, [], Bool)
_wrap(rlapi.IsWindowHidden, [], Bool)
_wrap(rlapi.IsWindowMinimized, [], Bool)
_wrap(rlapi.IsWindowMaximized, [], Bool)
_wrap(rlapi.IsWindowFocused, [], Bool)
_wrap(rlapi.IsWindowResized, [], Bool)
_wrap(rlapi.IsWindowState, [UInt], Bool)
_wrap(rlapi.SetWindowState, [UInt], None)
_wrap(rlapi.ClearWindowState, [UInt], None)
_wrap(rlapi.ToggleFullscreen, [], None)
_wrap(rlapi.MaximizeWindow, [], None)
_wrap(rlapi.MinimizeWindow, [], None)
_wrap(rlapi.RestoreWindow, [], None)
_wrap(rlapi.SetWindowIcon, [Image], None)
_wrap(rlapi.SetWindowTitle, [CharPtr], None)
_wrap(rlapi.SetWindowPosition, [Int, Int], None)
_wrap(rlapi.SetWindowMonitor, [Int], None)
_wrap(rlapi.SetWindowMinSize, [Int, Int], None)
_wrap(rlapi.SetWindowSize, [Int, Int], None)
_wrap(rlapi.SetWindowOpacity, [Float], None)
_wrap(rlapi.GetWindowHandle, [], VoidPtr)
_wrap(rlapi.GetScreenWidth, [], Int)
_wrap(rlapi.GetScreenHeight, [], Int)
_wrap(rlapi.GetRenderWidth, [], Int)
_wrap(rlapi.GetRenderHeight, [], Int)
_wrap(rlapi.GetMonitorCount, [], Int)
_wrap(rlapi.GetCurrentMonitor, [], Int)
_wrap(rlapi.GetMonitorPosition, [Int], Vector2)
_wrap(rlapi.GetMonitorWidth, [Int], Int)
_wrap(rlapi.GetMonitorHeight, [Int], Int)
_wrap(rlapi.GetMonitorPhysicalWidth, [Int], Int)
_wrap(rlapi.GetMonitorPhysicalHeight, [Int], Int)
_wrap(rlapi.GetMonitorRefreshRate, [Int], Int)
_wrap(rlapi.GetWindowPosition, [], Vector2)
_wrap(rlapi.GetWindowScaleDPI, [], Vector2)
_wrap(rlapi.GetMonitorName, [Int], CharPtr)
_wrap(rlapi.SetClipboardText, [CharPtr], None)
_wrap(rlapi.GetClipboardText, [], CharPtr)
_wrap(rlapi.EnableEventWaiting, [], None)
_wrap(rlapi.DisableEventWaiting, [], None)
_wrap(rlapi.SwapScreenBuffer, [], None)
_wrap(rlapi.PollInputEvents, [], None)
_wrap(rlapi.WaitTime, [Double], None)
_wrap(rlapi.ShowCursor, [], None)
_wrap(rlapi.HideCursor, [], None)
_wrap(rlapi.IsCursorHidden, [], Bool)
_wrap(rlapi.EnableCursor, [], None)
_wrap(rlapi.DisableCursor, [], None)
_wrap(rlapi.IsCursorOnScreen, [], Bool)
_wrap(rlapi.ClearBackground, [Color], None)
_wrap(rlapi.BeginDrawing, [], None)
_wrap(rlapi.EndDrawing, [], None)
_wrap(rlapi.BeginMode2D, [Camera2D], None)
_wrap(rlapi.EndMode2D, [], None)
_wrap(rlapi.BeginMode3D, [Camera3D], None)
_wrap(rlapi.EndMode3D, [], None)
_wrap(rlapi.BeginTextureMode, [RenderTexture2D], None)
_wrap(rlapi.EndTextureMode, [], None)
_wrap(rlapi.BeginShaderMode, [Shader], None)
_wrap(rlapi.EndShaderMode, [], None)
_wrap(rlapi.BeginBlendMode, [Int], None)
_wrap(rlapi.EndBlendMode, [], None)
_wrap(rlapi.BeginScissorMode, [Int, Int, Int, Int], None)
_wrap(rlapi.EndScissorMode, [], None)
_wrap(rlapi.BeginVrStereoMode, [VrStereoConfig], None)
_wrap(rlapi.EndVrStereoMode, [], None)
_wrap(rlapi.LoadVrStereoConfig, [VrDeviceInfo], VrStereoConfig)
_wrap(rlapi.UnloadVrStereoConfig, [VrStereoConfig], None)
_wrap(rlapi.LoadShader, [CharPtr, CharPtr], Shader)
_wrap(rlapi.LoadShaderFromMemory, [CharPtr, CharPtr], Shader)
_wrap(rlapi.GetShaderLocation, [Shader, CharPtr], Int)
_wrap(rlapi.GetShaderLocationAttrib, [Shader, CharPtr], Int)
_wrap(rlapi.SetShaderValue, [Shader, Int, VoidPtr, Int], None)
_wrap(rlapi.SetShaderValueV, [Shader, Int, VoidPtr, Int, Int], None)
_wrap(rlapi.SetShaderValueMatrix, [Shader, Int, Matrix], None)
_wrap(rlapi.SetShaderValueTexture, [Shader, Int, Texture2D], None)
_wrap(rlapi.UnloadShader, [Shader], None)
_wrap(rlapi.GetMouseRay, [Vector2, Camera], Ray)
_wrap(rlapi.GetCameraMatrix, [Camera], Matrix)
_wrap(rlapi.GetCameraMatrix2D, [Camera2D], Matrix)
_wrap(rlapi.GetWorldToScreen, [Vector3, Camera], Vector2)
_wrap(rlapi.GetScreenToWorld2D, [Vector2, Camera2D], Vector2)
_wrap(rlapi.GetWorldToScreenEx, [Vector3, Camera, Int, Int], Vector2)
_wrap(rlapi.GetWorldToScreen2D, [Vector2, Camera2D], Vector2)
_wrap(rlapi.SetTargetFPS, [Int], None)
_wrap(rlapi.GetFPS, [], Int)
_wrap(rlapi.GetFrameTime, [], Float)
_wrap(rlapi.GetTime, [], Double)
_wrap(rlapi.GetRandomValue, [Int, Int], Int)
_wrap(rlapi.SetRandomSeed, [UInt], None)
_wrap(rlapi.TakeScreenshot, [CharPtr], None)
_wrap(rlapi.SetConfigFlags, [UInt], None)
_wrap(rlapi.TraceLog, [Int, CharPtr, VoidPtr], None)
_wrap(rlapi.SetTraceLogLevel, [Int], None)
_wrap(rlapi.MemAlloc, [Int], VoidPtr)
_wrap(rlapi.MemRealloc, [VoidPtr, Int], VoidPtr)
_wrap(rlapi.MemFree, [VoidPtr], None)
_wrap(rlapi.OpenURL, [CharPtr], None)
_wrap(rlapi.SetTraceLogCallback, [TraceLogCallback], None)
_wrap(rlapi.SetLoadFileDataCallback, [LoadFileDataCallback], None)
_wrap(rlapi.SetSaveFileDataCallback, [SaveFileDataCallback], None)
_wrap(rlapi.SetLoadFileTextCallback, [LoadFileTextCallback], None)
_wrap(rlapi.SetSaveFileTextCallback, [SaveFileTextCallback], None)
_wrap(rlapi.LoadFileData, [CharPtr, UIntPtr], UBytePtr)
_wrap(rlapi.UnloadFileData, [UBytePtr], None)
_wrap(rlapi.SaveFileData, [CharPtr, VoidPtr, UInt], Bool)
_wrap(rlapi.ExportDataAsCode, [CharPtr, UInt, CharPtr], Bool)
_wrap(rlapi.LoadFileText, [CharPtr], CharPtr)
_wrap(rlapi.UnloadFileText, [CharPtr], None)
_wrap(rlapi.SaveFileText, [CharPtr, CharPtr], Bool)
_wrap(rlapi.FileExists, [CharPtr], Bool)
_wrap(rlapi.DirectoryExists, [CharPtr], Bool)
_wrap(rlapi.IsFileExtension, [CharPtr, CharPtr], Bool)
_wrap(rlapi.GetFileLength, [CharPtr], Int)
_wrap(rlapi.GetFileExtension, [CharPtr], CharPtr)
_wrap(rlapi.GetFileName, [CharPtr], CharPtr)
_wrap(rlapi.GetFileNameWithoutExt, [CharPtr], CharPtr)
_wrap(rlapi.GetDirectoryPath, [CharPtr], CharPtr)
_wrap(rlapi.GetPrevDirectoryPath, [CharPtr], CharPtr)
_wrap(rlapi.GetWorkingDirectory, [], CharPtr)
_wrap(rlapi.GetApplicationDirectory, [], CharPtr)
_wrap(rlapi.ChangeDirectory, [CharPtr], Bool)
_wrap(rlapi.IsPathFile, [CharPtr], Bool)
_wrap(rlapi.LoadDirectoryFiles, [CharPtr], FilePathList)
_wrap(rlapi.LoadDirectoryFilesEx, [CharPtr, CharPtr, Bool], FilePathList)
_wrap(rlapi.UnloadDirectoryFiles, [FilePathList], None)
_wrap(rlapi.IsFileDropped, [], Bool)
_wrap(rlapi.LoadDroppedFiles, [], FilePathList)
_wrap(rlapi.UnloadDroppedFiles, [FilePathList], None)
_wrap(rlapi.GetFileModTime, [CharPtr], Long)
_wrap(rlapi.CompressData, [UBytePtr, Int, IntPtr], UBytePtr)
_wrap(rlapi.DecompressData, [UBytePtr, Int, IntPtr], UBytePtr)
_wrap(rlapi.EncodeDataBase64, [UBytePtr, Int, IntPtr], CharPtr)
_wrap(rlapi.DecodeDataBase64, [UBytePtr, IntPtr], UBytePtr)
_wrap(rlapi.IsKeyPressed, [Int], Bool)
_wrap(rlapi.IsKeyDown, [Int], Bool)
_wrap(rlapi.IsKeyReleased, [Int], Bool)
_wrap(rlapi.IsKeyUp, [Int], Bool)
_wrap(rlapi.SetExitKey, [Int], None)
_wrap(rlapi.GetKeyPressed, [], Int)
_wrap(rlapi.GetCharPressed, [], Int)
_wrap(rlapi.IsGamepadAvailable, [Int], Bool)
_wrap(rlapi.GetGamepadName, [Int], CharPtr)
_wrap(rlapi.IsGamepadButtonPressed, [Int, Int], Bool)
_wrap(rlapi.IsGamepadButtonDown, [Int, Int], Bool)
_wrap(rlapi.IsGamepadButtonReleased, [Int, Int], Bool)
_wrap(rlapi.IsGamepadButtonUp, [Int, Int], Bool)
_wrap(rlapi.GetGamepadButtonPressed, [], Int)
_wrap(rlapi.GetGamepadAxisCount, [Int], Int)
_wrap(rlapi.GetGamepadAxisMovement, [Int, Int], Float)
_wrap(rlapi.SetGamepadMappings, [CharPtr], Int)
_wrap(rlapi.IsMouseButtonPressed, [Int], Bool)
_wrap(rlapi.IsMouseButtonDown, [Int], Bool)
_wrap(rlapi.IsMouseButtonReleased, [Int], Bool)
_wrap(rlapi.IsMouseButtonUp, [Int], Bool)
_wrap(rlapi.GetMouseX, [], Int)
_wrap(rlapi.GetMouseY, [], Int)
_wrap(rlapi.GetMousePosition, [], Vector2)
_wrap(rlapi.GetMouseDelta, [], Vector2)
_wrap(rlapi.SetMousePosition, [Int, Int], None)
_wrap(rlapi.SetMouseOffset, [Int, Int], None)
_wrap(rlapi.SetMouseScale, [Float, Float], None)
_wrap(rlapi.GetMouseWheelMove, [], Float)
_wrap(rlapi.GetMouseWheelMoveV, [], Vector2)
_wrap(rlapi.SetMouseCursor, [Int], None)
_wrap(rlapi.GetTouchX, [], Int)
_wrap(rlapi.GetTouchY, [], Int)
_wrap(rlapi.GetTouchPosition, [Int], Vector2)
_wrap(rlapi.GetTouchPointId, [Int], Int)
_wrap(rlapi.GetTouchPointCount, [], Int)
_wrap(rlapi.SetGesturesEnabled, [UInt], None)
_wrap(rlapi.IsGestureDetected, [Int], Bool)
_wrap(rlapi.GetGestureDetected, [], Int)
_wrap(rlapi.GetGestureHoldDuration, [], Float)
_wrap(rlapi.GetGestureDragVector, [], Vector2)
_wrap(rlapi.GetGestureDragAngle, [], Float)
_wrap(rlapi.GetGesturePinchVector, [], Vector2)
_wrap(rlapi.GetGesturePinchAngle, [], Float)
_wrap(rlapi.SetCameraMode, [Camera, Int], None)
_wrap(rlapi.UpdateCamera, [CameraPtr], None)
_wrap(rlapi.SetCameraPanControl, [Int], None)
_wrap(rlapi.SetCameraAltControl, [Int], None)
_wrap(rlapi.SetCameraSmoothZoomControl, [Int], None)
_wrap(rlapi.SetCameraMoveControls, [Int, Int, Int, Int, Int, Int], None)
_wrap(rlapi.SetShapesTexture, [Texture2D, Rectangle], None)
_wrap(rlapi.DrawPixel, [Int, Int, Color], None)
_wrap(rlapi.DrawPixelV, [Vector2, Color], None)
_wrap(rlapi.DrawLine, [Int, Int, Int, Int, Color], None)
_wrap(rlapi.DrawLineV, [Vector2, Vector2, Color], None)
_wrap(rlapi.DrawLineEx, [Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineBezier, [Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineBezierQuad, [Vector2, Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineBezierCubic, [Vector2, Vector2, Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineStrip, [Vector2Ptr, Int, Color], None)
_wrap(rlapi.DrawCircle, [Int, Int, Float, Color], None)
_wrap(rlapi.DrawCircleSector, [Vector2, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCircleSectorLines, [Vector2, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCircleGradient, [Int, Int, Float, Color, Color], None)
_wrap(rlapi.DrawCircleV, [Vector2, Float, Color], None)
_wrap(rlapi.DrawCircleLines, [Int, Int, Float, Color], None)
_wrap(rlapi.DrawEllipse, [Int, Int, Float, Float, Color], None)
_wrap(rlapi.DrawEllipseLines, [Int, Int, Float, Float, Color], None)
_wrap(rlapi.DrawRing, [Vector2, Float, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawRingLines, [Vector2, Float, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawRectangle, [Int, Int, Int, Int, Color], None)
_wrap(rlapi.DrawRectangleV, [Vector2, Vector2, Color], None)
_wrap(rlapi.DrawRectangleRec, [Rectangle, Color], None)
_wrap(rlapi.DrawRectanglePro, [Rectangle, Vector2, Float, Color], None)
_wrap(rlapi.DrawRectangleGradientV, [Int, Int, Int, Int, Color, Color], None)
_wrap(rlapi.DrawRectangleGradientH, [Int, Int, Int, Int, Color, Color], None)
_wrap(rlapi.DrawRectangleGradientEx, [Rectangle, Color, Color, Color, Color], None)
_wrap(rlapi.DrawRectangleLines, [Int, Int, Int, Int, Color], None)
_wrap(rlapi.DrawRectangleLinesEx, [Rectangle, Float, Color], None)
_wrap(rlapi.DrawRectangleRounded, [Rectangle, Float, Int, Color], None)
_wrap(rlapi.DrawRectangleRoundedLines, [Rectangle, Float, Int, Float, Color], None)
_wrap(rlapi.DrawTriangle, [Vector2, Vector2, Vector2, Color], None)
_wrap(rlapi.DrawTriangleLines, [Vector2, Vector2, Vector2, Color], None)
_wrap(rlapi.DrawTriangleFan, [Vector2Ptr, Int, Color], None)
_wrap(rlapi.DrawTriangleStrip, [Vector2Ptr, Int, Color], None)
_wrap(rlapi.DrawPoly, [Vector2, Int, Float, Float, Color], None)
_wrap(rlapi.DrawPolyLines, [Vector2, Int, Float, Float, Color], None)
_wrap(rlapi.DrawPolyLinesEx, [Vector2, Int, Float, Float, Float, Color], None)
_wrap(rlapi.CheckCollisionRecs, [Rectangle, Rectangle], Bool)
_wrap(rlapi.CheckCollisionCircles, [Vector2, Float, Vector2, Float], Bool)
_wrap(rlapi.CheckCollisionCircleRec, [Vector2, Float, Rectangle], Bool)
_wrap(rlapi.CheckCollisionPointRec, [Vector2, Rectangle], Bool)
_wrap(rlapi.CheckCollisionPointCircle, [Vector2, Vector2, Float], Bool)
_wrap(rlapi.CheckCollisionPointTriangle, [Vector2, Vector2, Vector2, Vector2], Bool)
_wrap(rlapi.CheckCollisionLines, [Vector2, Vector2, Vector2, Vector2, Vector2Ptr], Bool)
_wrap(rlapi.CheckCollisionPointLine, [Vector2, Vector2, Vector2, Int], Bool)
_wrap(rlapi.GetCollisionRec, [Rectangle, Rectangle], Rectangle)
_wrap(rlapi.LoadImage, [CharPtr], Image)
_wrap(rlapi.LoadImageRaw, [CharPtr, Int, Int, Int, Int], Image)
_wrap(rlapi.LoadImageAnim, [CharPtr, IntPtr], Image)
_wrap(rlapi.LoadImageFromMemory, [CharPtr, UBytePtr, Int], Image)
_wrap(rlapi.LoadImageFromTexture, [Texture2D], Image)
_wrap(rlapi.LoadImageFromScreen, [], Image)
_wrap(rlapi.UnloadImage, [Image], None)
_wrap(rlapi.ExportImage, [Image, CharPtr], Bool)
_wrap(rlapi.ExportImageAsCode, [Image, CharPtr], Bool)
_wrap(rlapi.GenImageColor, [Int, Int, Color], Image)
_wrap(rlapi.GenImageGradientV, [Int, Int, Color, Color], Image)
_wrap(rlapi.GenImageGradientH, [Int, Int, Color, Color], Image)
_wrap(rlapi.GenImageGradientRadial, [Int, Int, Float, Color, Color], Image)
_wrap(rlapi.GenImageChecked, [Int, Int, Int, Int, Color, Color], Image)
_wrap(rlapi.GenImageWhiteNoise, [Int, Int, Float], Image)
_wrap(rlapi.GenImageCellular, [Int, Int, Int], Image)
_wrap(rlapi.ImageCopy, [Image], Image)
_wrap(rlapi.ImageFromImage, [Image, Rectangle], Image)
_wrap(rlapi.ImageText, [CharPtr, Int, Color], Image)
_wrap(rlapi.ImageTextEx, [Font, CharPtr, Float, Float, Color], Image)
_wrap(rlapi.ImageFormat, [ImagePtr, Int], None)
_wrap(rlapi.ImageToPOT, [ImagePtr, Color], None)
_wrap(rlapi.ImageCrop, [ImagePtr, Rectangle], None)
_wrap(rlapi.ImageAlphaCrop, [ImagePtr, Float], None)
_wrap(rlapi.ImageAlphaClear, [ImagePtr, Color, Float], None)
_wrap(rlapi.ImageAlphaMask, [ImagePtr, Image], None)
_wrap(rlapi.ImageAlphaPremultiply, [ImagePtr], None)
_wrap(rlapi.ImageResize, [ImagePtr, Int, Int], None)
_wrap(rlapi.ImageResizeNN, [ImagePtr, Int, Int], None)
_wrap(rlapi.ImageResizeCanvas, [ImagePtr, Int, Int, Int, Int, Color], None)
_wrap(rlapi.ImageMipmaps, [ImagePtr], None)
_wrap(rlapi.ImageDither, [ImagePtr, Int, Int, Int, Int], None)
_wrap(rlapi.ImageFlipVertical, [ImagePtr], None)
_wrap(rlapi.ImageFlipHorizontal, [ImagePtr], None)
_wrap(rlapi.ImageRotateCW, [ImagePtr], None)
_wrap(rlapi.ImageRotateCCW, [ImagePtr], None)
_wrap(rlapi.ImageColorTint, [ImagePtr, Color], None)
_wrap(rlapi.ImageColorInvert, [ImagePtr], None)
_wrap(rlapi.ImageColorGrayscale, [ImagePtr], None)
_wrap(rlapi.ImageColorContrast, [ImagePtr, Float], None)
_wrap(rlapi.ImageColorBrightness, [ImagePtr, Int], None)
_wrap(rlapi.ImageColorReplace, [ImagePtr, Color, Color], None)
_wrap(rlapi.LoadImageColors, [Image], ColorPtr)
_wrap(rlapi.LoadImagePalette, [Image, Int, IntPtr], ColorPtr)
_wrap(rlapi.UnloadImageColors, [ColorPtr], None)
_wrap(rlapi.UnloadImagePalette, [ColorPtr], None)
_wrap(rlapi.GetImageAlphaBorder, [Image, Float], Rectangle)
_wrap(rlapi.GetImageColor, [Image, Int, Int], Color)
_wrap(rlapi.ImageClearBackground, [ImagePtr, Color], None)
_wrap(rlapi.ImageDrawPixel, [ImagePtr, Int, Int, Color], None)
_wrap(rlapi.ImageDrawPixelV, [ImagePtr, Vector2, Color], None)
_wrap(rlapi.ImageDrawLine, [ImagePtr, Int, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawLineV, [ImagePtr, Vector2, Vector2, Color], None)
_wrap(rlapi.ImageDrawCircle, [ImagePtr, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawCircleV, [ImagePtr, Vector2, Int, Color], None)
_wrap(rlapi.ImageDrawRectangle, [ImagePtr, Int, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawRectangleV, [ImagePtr, Vector2, Vector2, Color], None)
_wrap(rlapi.ImageDrawRectangleRec, [ImagePtr, Rectangle, Color], None)
_wrap(rlapi.ImageDrawRectangleLines, [ImagePtr, Rectangle, Int, Color], None)
_wrap(rlapi.ImageDraw, [ImagePtr, Image, Rectangle, Rectangle, Color], None)
_wrap(rlapi.ImageDrawText, [ImagePtr, CharPtr, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawTextEx, [ImagePtr, Font, CharPtr, Vector2, Float, Float, Color], None)
_wrap(rlapi.LoadTexture, [CharPtr], Texture2D)
_wrap(rlapi.LoadTextureFromImage, [Image], Texture2D)
_wrap(rlapi.LoadTextureCubemap, [Image, Int], TextureCubemap)
_wrap(rlapi.LoadRenderTexture, [Int, Int], RenderTexture2D)
_wrap(rlapi.UnloadTexture, [Texture2D], None)
_wrap(rlapi.UnloadRenderTexture, [RenderTexture2D], None)
_wrap(rlapi.UpdateTexture, [Texture2D, VoidPtr], None)
_wrap(rlapi.UpdateTextureRec, [Texture2D, Rectangle, VoidPtr], None)
_wrap(rlapi.GenTextureMipmaps, [Texture2DPtr], None)
_wrap(rlapi.SetTextureFilter, [Texture2D, Int], None)
_wrap(rlapi.SetTextureWrap, [Texture2D, Int], None)
_wrap(rlapi.DrawTexture, [Texture2D, Int, Int, Color], None)
_wrap(rlapi.DrawTextureV, [Texture2D, Vector2, Color], None)
_wrap(rlapi.DrawTextureEx, [Texture2D, Vector2, Float, Float, Color], None)
_wrap(rlapi.DrawTextureRec, [Texture2D, Rectangle, Vector2, Color], None)
_wrap(rlapi.DrawTextureQuad, [Texture2D, Vector2, Vector2, Rectangle, Color], None)
_wrap(rlapi.DrawTextureTiled, [Texture2D, Rectangle, Rectangle, Vector2, Float, Float, Color], None)
_wrap(rlapi.DrawTexturePro, [Texture2D, Rectangle, Rectangle, Vector2, Float, Color], None)
_wrap(rlapi.DrawTextureNPatch, [Texture2D, NPatchInfo, Rectangle, Vector2, Float, Color], None)
_wrap(rlapi.DrawTexturePoly, [Texture2D, Vector2, Vector2Ptr, Vector2Ptr, Int, Color], None)
_wrap(rlapi.Fade, [Color, Float], Color)
_wrap(rlapi.ColorToInt, [Color], Int)
_wrap(rlapi.ColorNormalize, [Color], Vector4)
_wrap(rlapi.ColorFromNormalized, [Vector4], Color)
_wrap(rlapi.ColorToHSV, [Color], Vector3)
_wrap(rlapi.ColorFromHSV, [Float, Float, Float], Color)
_wrap(rlapi.ColorAlpha, [Color, Float], Color)
_wrap(rlapi.ColorAlphaBlend, [Color, Color, Color], Color)
_wrap(rlapi.GetColor, [UInt], Color)
_wrap(rlapi.GetPixelColor, [VoidPtr, Int], Color)
_wrap(rlapi.SetPixelColor, [VoidPtr, Color, Int], None)
_wrap(rlapi.GetPixelDataSize, [Int, Int, Int], Int)
_wrap(rlapi.GetFontDefault, [], Font)
_wrap(rlapi.LoadFont, [CharPtr], Font)
_wrap(rlapi.LoadFontEx, [CharPtr, Int, IntPtr, Int], Font)
_wrap(rlapi.LoadFontFromImage, [Image, Color, Int], Font)
_wrap(rlapi.LoadFontFromMemory, [CharPtr, UBytePtr, Int, Int, IntPtr, Int], Font)
_wrap(rlapi.LoadFontData, [UBytePtr, Int, Int, IntPtr, Int, Int], GlyphInfoPtr)
_wrap(rlapi.GenImageFontAtlas, [GlyphInfoPtr, POINTER(RectanglePtr), Int, Int, Int, Int], Image)
_wrap(rlapi.UnloadFontData, [GlyphInfoPtr, Int], None)
_wrap(rlapi.UnloadFont, [Font], None)
_wrap(rlapi.ExportFontAsCode, [Font, CharPtr], Bool)
_wrap(rlapi.DrawFPS, [Int, Int], None)
_wrap(rlapi.DrawText, [CharPtr, Int, Int, Int, Color], None)
_wrap(rlapi.DrawTextEx, [Font, CharPtr, Vector2, Float, Float, Color], None)
_wrap(rlapi.DrawTextPro, [Font, CharPtr, Vector2, Vector2, Float, Float, Float, Color], None)
_wrap(rlapi.DrawTextCodepoint, [Font, Int, Vector2, Float, Color], None)
_wrap(rlapi.DrawTextCodepoints, [Font, IntPtr, Int, Vector2, Float, Float, Color], None)
_wrap(rlapi.MeasureText, [CharPtr, Int], Int)
_wrap(rlapi.MeasureTextEx, [Font, CharPtr, Float, Float], Vector2)
_wrap(rlapi.GetGlyphIndex, [Font, Int], Int)
_wrap(rlapi.GetGlyphInfo, [Font, Int], GlyphInfo)
_wrap(rlapi.GetGlyphAtlasRec, [Font, Int], Rectangle)
_wrap(rlapi.LoadCodepoints, [CharPtr, IntPtr], IntPtr)
_wrap(rlapi.UnloadCodepoints, [IntPtr], None)
_wrap(rlapi.GetCodepointCount, [CharPtr], Int)
_wrap(rlapi.GetCodepoint, [CharPtr, IntPtr], Int)
_wrap(rlapi.CodepointToUTF8, [Int, IntPtr], CharPtr)
_wrap(rlapi.TextCodepointsToUTF8, [IntPtr, Int], CharPtr)
_wrap(rlapi.TextCopy, [CharPtr, CharPtr], Int)
_wrap(rlapi.TextIsEqual, [CharPtr, CharPtr], Bool)
_wrap(rlapi.TextLength, [CharPtr], UInt)
_wrap(rlapi.TextFormat, [CharPtr, VoidPtr], CharPtr)
_wrap(rlapi.TextSubtext, [CharPtr, Int, Int], CharPtr)
_wrap(rlapi.TextReplace, [CharPtr, CharPtr, CharPtr], CharPtr)
_wrap(rlapi.TextInsert, [CharPtr, CharPtr, Int], CharPtr)
_wrap(rlapi.TextJoin, [POINTER(CharPtr), Int, CharPtr], CharPtr)
_wrap(rlapi.TextSplit, [CharPtr, Char, IntPtr], POINTER(CharPtr))
_wrap(rlapi.TextAppend, [CharPtr, CharPtr, IntPtr], None)
_wrap(rlapi.TextFindIndex, [CharPtr, CharPtr], Int)
_wrap(rlapi.TextToUpper, [CharPtr], CharPtr)
_wrap(rlapi.TextToLower, [CharPtr], CharPtr)
_wrap(rlapi.TextToPascal, [CharPtr], CharPtr)
_wrap(rlapi.TextToInteger, [CharPtr], Int)
_wrap(rlapi.DrawLine3D, [Vector3, Vector3, Color], None)
_wrap(rlapi.DrawPoint3D, [Vector3, Color], None)
_wrap(rlapi.DrawCircle3D, [Vector3, Float, Vector3, Float, Color], None)
_wrap(rlapi.DrawTriangle3D, [Vector3, Vector3, Vector3, Color], None)
_wrap(rlapi.DrawTriangleStrip3D, [Vector3Ptr, Int, Color], None)
_wrap(rlapi.DrawCube, [Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawCubeV, [Vector3, Vector3, Color], None)
_wrap(rlapi.DrawCubeWires, [Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawCubeWiresV, [Vector3, Vector3, Color], None)
_wrap(rlapi.DrawCubeTexture, [Texture2D, Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawCubeTextureRec, [Texture2D, Rectangle, Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawSphere, [Vector3, Float, Color], None)
_wrap(rlapi.DrawSphereEx, [Vector3, Float, Int, Int, Color], None)
_wrap(rlapi.DrawSphereWires, [Vector3, Float, Int, Int, Color], None)
_wrap(rlapi.DrawCylinder, [Vector3, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCylinderEx, [Vector3, Vector3, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCylinderWires, [Vector3, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCylinderWiresEx, [Vector3, Vector3, Float, Float, Int, Color], None)
_wrap(rlapi.DrawPlane, [Vector3, Vector2, Color], None)
_wrap(rlapi.DrawRay, [Ray, Color], None)
_wrap(rlapi.DrawGrid, [Int, Float], None)
_wrap(rlapi.LoadModel, [CharPtr], Model)
_wrap(rlapi.LoadModelFromMesh, [Mesh], Model)
_wrap(rlapi.UnloadModel, [Model], None)
_wrap(rlapi.UnloadModelKeepMeshes, [Model], None)
_wrap(rlapi.GetModelBoundingBox, [Model], BoundingBox)
_wrap(rlapi.DrawModel, [Model, Vector3, Float, Color], None)
_wrap(rlapi.DrawModelEx, [Model, Vector3, Vector3, Float, Vector3, Color], None)
_wrap(rlapi.DrawModelWires, [Model, Vector3, Float, Color], None)
_wrap(rlapi.DrawModelWiresEx, [Model, Vector3, Vector3, Float, Vector3, Color], None)
_wrap(rlapi.DrawBoundingBox, [BoundingBox, Color], None)
_wrap(rlapi.DrawBillboard, [Camera, Texture2D, Vector3, Float, Color], None)
_wrap(rlapi.DrawBillboardRec, [Camera, Texture2D, Rectangle, Vector3, Vector2, Color], None)
_wrap(rlapi.DrawBillboardPro, [Camera, Texture2D, Rectangle, Vector3, Vector3, Vector2, Vector2, Float, Color], None)
_wrap(rlapi.UploadMesh, [MeshPtr, Bool], None)
_wrap(rlapi.UpdateMeshBuffer, [Mesh, Int, VoidPtr, Int, Int], None)
_wrap(rlapi.UnloadMesh, [Mesh], None)
_wrap(rlapi.DrawMesh, [Mesh, Material, Matrix], None)
_wrap(rlapi.DrawMeshInstanced, [Mesh, Material, MatrixPtr, Int], None)
_wrap(rlapi.ExportMesh, [Mesh, CharPtr], Bool)
_wrap(rlapi.GetMeshBoundingBox, [Mesh], BoundingBox)
_wrap(rlapi.GenMeshTangents, [MeshPtr], None)
_wrap(rlapi.GenMeshPoly, [Int, Float], Mesh)
_wrap(rlapi.GenMeshPlane, [Float, Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshCube, [Float, Float, Float], Mesh)
_wrap(rlapi.GenMeshSphere, [Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshHemiSphere, [Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshCylinder, [Float, Float, Int], Mesh)
_wrap(rlapi.GenMeshCone, [Float, Float, Int], Mesh)
_wrap(rlapi.GenMeshTorus, [Float, Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshKnot, [Float, Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshHeightmap, [Image, Vector3], Mesh)
_wrap(rlapi.GenMeshCubicmap, [Image, Vector3], Mesh)
_wrap(rlapi.LoadMaterials, [CharPtr, IntPtr], MaterialPtr)
_wrap(rlapi.LoadMaterialDefault, [], Material)
_wrap(rlapi.UnloadMaterial, [Material], None)
_wrap(rlapi.SetMaterialTexture, [MaterialPtr, Int, Texture2D], None)
_wrap(rlapi.SetModelMeshMaterial, [ModelPtr, Int, Int], None)
_wrap(rlapi.LoadModelAnimations, [CharPtr, UIntPtr], ModelAnimationPtr)
_wrap(rlapi.UpdateModelAnimation, [Model, ModelAnimation, Int], None)
_wrap(rlapi.UnloadModelAnimation, [ModelAnimation], None)
_wrap(rlapi.UnloadModelAnimations, [ModelAnimationPtr, UInt], None)
_wrap(rlapi.IsModelAnimationValid, [Model, ModelAnimation], Bool)
_wrap(rlapi.CheckCollisionSpheres, [Vector3, Float, Vector3, Float], Bool)
_wrap(rlapi.CheckCollisionBoxes, [BoundingBox, BoundingBox], Bool)
_wrap(rlapi.CheckCollisionBoxSphere, [BoundingBox, Vector3, Float], Bool)
_wrap(rlapi.GetRayCollisionSphere, [Ray, Vector3, Float], RayCollision)
_wrap(rlapi.GetRayCollisionBox, [Ray, BoundingBox], RayCollision)
_wrap(rlapi.GetRayCollisionMesh, [Ray, Mesh, Matrix], RayCollision)
_wrap(rlapi.GetRayCollisionTriangle, [Ray, Vector3, Vector3, Vector3], RayCollision)
_wrap(rlapi.GetRayCollisionQuad, [Ray, Vector3, Vector3, Vector3, Vector3], RayCollision)
_wrap(rlapi.InitAudioDevice, [], None)
_wrap(rlapi.CloseAudioDevice, [], None)
_wrap(rlapi.IsAudioDeviceReady, [], Bool)
_wrap(rlapi.SetMasterVolume, [Float], None)
_wrap(rlapi.LoadWave, [CharPtr], Wave)
_wrap(rlapi.LoadWaveFromMemory, [CharPtr, UBytePtr, Int], Wave)
_wrap(rlapi.LoadSound, [CharPtr], Sound)
_wrap(rlapi.LoadSoundFromWave, [Wave], Sound)
_wrap(rlapi.UpdateSound, [Sound, VoidPtr, Int], None)
_wrap(rlapi.UnloadWave, [Wave], None)
_wrap(rlapi.UnloadSound, [Sound], None)
_wrap(rlapi.ExportWave, [Wave, CharPtr], Bool)
_wrap(rlapi.ExportWaveAsCode, [Wave, CharPtr], Bool)
_wrap(rlapi.PlaySound, [Sound], None)
_wrap(rlapi.StopSound, [Sound], None)
_wrap(rlapi.PauseSound, [Sound], None)
_wrap(rlapi.ResumeSound, [Sound], None)
_wrap(rlapi.PlaySoundMulti, [Sound], None)
_wrap(rlapi.StopSoundMulti, [], None)
_wrap(rlapi.GetSoundsPlaying, [], Int)
_wrap(rlapi.IsSoundPlaying, [Sound], Bool)
_wrap(rlapi.SetSoundVolume, [Sound, Float], None)
_wrap(rlapi.SetSoundPitch, [Sound, Float], None)
_wrap(rlapi.SetSoundPan, [Sound, Float], None)
_wrap(rlapi.WaveCopy, [Wave], Wave)
_wrap(rlapi.WaveCrop, [WavePtr, Int, Int], None)
_wrap(rlapi.WaveFormat, [WavePtr, Int, Int, Int], None)
_wrap(rlapi.LoadWaveSamples, [Wave], FloatPtr)
_wrap(rlapi.UnloadWaveSamples, [FloatPtr], None)
_wrap(rlapi.LoadMusicStream, [CharPtr], Music)
_wrap(rlapi.LoadMusicStreamFromMemory, [CharPtr, UBytePtr, Int], Music)
_wrap(rlapi.UnloadMusicStream, [Music], None)
_wrap(rlapi.PlayMusicStream, [Music], None)
_wrap(rlapi.IsMusicStreamPlaying, [Music], Bool)
_wrap(rlapi.UpdateMusicStream, [Music], None)
_wrap(rlapi.StopMusicStream, [Music], None)
_wrap(rlapi.PauseMusicStream, [Music], None)
_wrap(rlapi.ResumeMusicStream, [Music], None)
_wrap(rlapi.SeekMusicStream, [Music, Float], None)
_wrap(rlapi.SetMusicVolume, [Music, Float], None)
_wrap(rlapi.SetMusicPitch, [Music, Float], None)
_wrap(rlapi.SetMusicPan, [Music, Float], None)
_wrap(rlapi.GetMusicTimeLength, [Music], Float)
_wrap(rlapi.GetMusicTimePlayed, [Music], Float)
_wrap(rlapi.LoadAudioStream, [UInt, UInt, UInt], AudioStream)
_wrap(rlapi.UnloadAudioStream, [AudioStream], None)
_wrap(rlapi.UpdateAudioStream, [AudioStream, VoidPtr, Int], None)
_wrap(rlapi.IsAudioStreamProcessed, [AudioStream], Bool)
_wrap(rlapi.PlayAudioStream, [AudioStream], None)
_wrap(rlapi.PauseAudioStream, [AudioStream], None)
_wrap(rlapi.ResumeAudioStream, [AudioStream], None)
_wrap(rlapi.IsAudioStreamPlaying, [AudioStream], Bool)
_wrap(rlapi.StopAudioStream, [AudioStream], None)
_wrap(rlapi.SetAudioStreamVolume, [AudioStream, Float], None)
_wrap(rlapi.SetAudioStreamPitch, [AudioStream, Float], None)
_wrap(rlapi.SetAudioStreamPan, [AudioStream, Float], None)
_wrap(rlapi.SetAudioStreamBufferSizeDefault, [Int], None)
_wrap(rlapi.SetAudioStreamCallback, [AudioStream, AudioCallback], None)
_wrap(rlapi.AttachAudioStreamProcessor, [AudioStream, AudioCallback], None)
_wrap(rlapi.DetachAudioStreamProcessor, [AudioStream, AudioCallback], None)

# endregion (prototypes)
# region API


def init_window(width, height, title):
    '''Initialize window and OpenGL context

    Raylib's C API: InitWindow

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param bytes title: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.InitWindow(int(width), int(height), _str_in(title))


def window_should_close():
    '''Check if KEY_ESCAPE pressed or Close icon pressed

    Raylib's C API: WindowShouldClose

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.WindowShouldClose()
    return result


def close_window():
    '''Close window and unload OpenGL context

    Raylib's C API: CloseWindow

    :return: None (`void` in C raylib)
    '''
    rlapi.CloseWindow()


def is_window_ready():
    '''Check if window has been initialized successfully

    Raylib's C API: IsWindowReady

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowReady()
    return result


def is_window_fullscreen():
    '''Check if window is currently fullscreen

    Raylib's C API: IsWindowFullscreen

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowFullscreen()
    return result


def is_window_hidden():
    '''Check if window is currently hidden (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowHidden

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowHidden()
    return result


def is_window_minimized():
    '''Check if window is currently minimized (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowMinimized

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowMinimized()
    return result


def is_window_maximized():
    '''Check if window is currently maximized (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowMaximized

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowMaximized()
    return result


def is_window_focused():
    '''Check if window is currently focused (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowFocused

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowFocused()
    return result


def is_window_resized():
    '''Check if window has been resized last frame

    Raylib's C API: IsWindowResized

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowResized()
    return result


def is_window_state(flag):
    '''Check if one specific window flag is enabled

    Raylib's C API: IsWindowState

    :param int flag: `unsigned int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsWindowState(int(flag))
    return result


def set_window_state(flags):
    '''Set window configuration state using flags (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowState

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowState(int(flags))


def clear_window_state(flags):
    '''Clear window configuration state flags

    Raylib's C API: ClearWindowState

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ClearWindowState(int(flags))


def toggle_fullscreen():
    '''Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)

    Raylib's C API: ToggleFullscreen

    :return: None (`void` in C raylib)
    '''
    rlapi.ToggleFullscreen()


def maximize_window():
    '''Set window state: maximized, if resizable (only PLATFORM_DESKTOP)

    Raylib's C API: MaximizeWindow

    :return: None (`void` in C raylib)
    '''
    rlapi.MaximizeWindow()


def minimize_window():
    '''Set window state: minimized, if resizable (only PLATFORM_DESKTOP)

    Raylib's C API: MinimizeWindow

    :return: None (`void` in C raylib)
    '''
    rlapi.MinimizeWindow()


def restore_window():
    '''Set window state: not minimized/maximized (only PLATFORM_DESKTOP)

    Raylib's C API: RestoreWindow

    :return: None (`void` in C raylib)
    '''
    rlapi.RestoreWindow()


def set_window_icon(image):
    '''Set icon for window (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowIcon

    :param Image image: `Image` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowIcon(image)


def set_window_title(title):
    '''Set title for window (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowTitle

    :param bytes title: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowTitle(_str_in(title))


def set_window_position(x, y):
    '''Set window position on screen (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowPosition

    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowPosition(int(x), int(y))


def set_window_monitor(monitor):
    '''Set monitor for the current window (fullscreen mode)

    Raylib's C API: SetWindowMonitor

    :param int monitor: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowMonitor(int(monitor))


def set_window_min_size(width, height):
    '''Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)

    Raylib's C API: SetWindowMinSize

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowMinSize(int(width), int(height))


def set_window_size(width, height):
    '''Set window dimensions

    Raylib's C API: SetWindowSize

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowSize(int(width), int(height))


def set_window_opacity(opacity):
    '''Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowOpacity

    :param float opacity: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetWindowOpacity(float(opacity))


def get_window_handle():
    '''Get native window handle

    Raylib's C API: GetWindowHandle

    :return: bytes (`void *` in C raylib)
    '''
    result = rlapi.GetWindowHandle()
    return result


def get_screen_width():
    '''Get current screen width

    Raylib's C API: GetScreenWidth

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetScreenWidth()
    return result


def get_screen_height():
    '''Get current screen height

    Raylib's C API: GetScreenHeight

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetScreenHeight()
    return result


def get_render_width():
    '''Get current render width (it considers HiDPI)

    Raylib's C API: GetRenderWidth

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetRenderWidth()
    return result


def get_render_height():
    '''Get current render height (it considers HiDPI)

    Raylib's C API: GetRenderHeight

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetRenderHeight()
    return result


def get_monitor_count():
    '''Get number of connected monitors

    Raylib's C API: GetMonitorCount

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMonitorCount()
    return result


def get_current_monitor():
    '''Get current connected monitor

    Raylib's C API: GetCurrentMonitor

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetCurrentMonitor()
    return result


def get_monitor_position(monitor):
    '''Get specified monitor position

    Raylib's C API: GetMonitorPosition

    :param int monitor: `int` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetMonitorPosition(int(monitor))
    return result


def get_monitor_width(monitor):
    '''Get specified monitor width (current video mode used by monitor)

    Raylib's C API: GetMonitorWidth

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMonitorWidth(int(monitor))
    return result


def get_monitor_height(monitor):
    '''Get specified monitor height (current video mode used by monitor)

    Raylib's C API: GetMonitorHeight

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMonitorHeight(int(monitor))
    return result


def get_monitor_physical_width(monitor):
    '''Get specified monitor physical width in millimetres

    Raylib's C API: GetMonitorPhysicalWidth

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMonitorPhysicalWidth(int(monitor))
    return result


def get_monitor_physical_height(monitor):
    '''Get specified monitor physical height in millimetres

    Raylib's C API: GetMonitorPhysicalHeight

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMonitorPhysicalHeight(int(monitor))
    return result


def get_monitor_refresh_rate(monitor):
    '''Get specified monitor refresh rate

    Raylib's C API: GetMonitorRefreshRate

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMonitorRefreshRate(int(monitor))
    return result


def get_window_position():
    '''Get window position XY on monitor

    Raylib's C API: GetWindowPosition

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetWindowPosition()
    return result


def get_window_scale_dpi():
    '''Get window scale DPI factor

    Raylib's C API: GetWindowScaleDPI

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetWindowScaleDPI()
    return result


def get_monitor_name(monitor):
    '''Get the human-readable, UTF-8 encoded name of the primary monitor

    Raylib's C API: GetMonitorName

    :param int monitor: `int` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetMonitorName(int(monitor))
    return result


def set_clipboard_text(text):
    '''Set clipboard text content

    Raylib's C API: SetClipboardText

    :param bytes text: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetClipboardText(_str_in(text))


def get_clipboard_text():
    '''Get clipboard text content

    Raylib's C API: GetClipboardText

    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetClipboardText()
    return result


def enable_event_waiting():
    '''Enable waiting for events on EndDrawing(), no automatic event polling

    Raylib's C API: EnableEventWaiting

    :return: None (`void` in C raylib)
    '''
    rlapi.EnableEventWaiting()


def disable_event_waiting():
    '''Disable waiting for events on EndDrawing(), automatic events polling

    Raylib's C API: DisableEventWaiting

    :return: None (`void` in C raylib)
    '''
    rlapi.DisableEventWaiting()


def swap_screen_buffer():
    '''Swap back buffer with front buffer (screen drawing)

    Raylib's C API: SwapScreenBuffer

    :return: None (`void` in C raylib)
    '''
    rlapi.SwapScreenBuffer()


def poll_input_events():
    '''Register all input events

    Raylib's C API: PollInputEvents

    :return: None (`void` in C raylib)
    '''
    rlapi.PollInputEvents()


def wait_time(seconds):
    '''Wait for some time (halt program execution)

    Raylib's C API: WaitTime

    :param float seconds: `double` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.WaitTime(float(seconds))


def show_cursor():
    '''Shows cursor

    Raylib's C API: ShowCursor

    :return: None (`void` in C raylib)
    '''
    rlapi.ShowCursor()


def hide_cursor():
    '''Hides cursor

    Raylib's C API: HideCursor

    :return: None (`void` in C raylib)
    '''
    rlapi.HideCursor()


def is_cursor_hidden():
    '''Check if cursor is not visible

    Raylib's C API: IsCursorHidden

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsCursorHidden()
    return result


def enable_cursor():
    '''Enables cursor (unlock cursor)

    Raylib's C API: EnableCursor

    :return: None (`void` in C raylib)
    '''
    rlapi.EnableCursor()


def disable_cursor():
    '''Disables cursor (lock cursor)

    Raylib's C API: DisableCursor

    :return: None (`void` in C raylib)
    '''
    rlapi.DisableCursor()


def is_cursor_on_screen():
    '''Check if cursor is on the screen

    Raylib's C API: IsCursorOnScreen

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsCursorOnScreen()
    return result


def clear_background(color):
    '''Set background color (framebuffer clear color)

    Raylib's C API: ClearBackground

    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ClearBackground(color)


def begin_drawing():
    '''Setup canvas (framebuffer) to start drawing

    Raylib's C API: BeginDrawing

    :return: None (`void` in C raylib)
    '''
    rlapi.BeginDrawing()


def end_drawing():
    '''End canvas drawing and swap buffers (double buffering)

    Raylib's C API: EndDrawing

    :return: None (`void` in C raylib)
    '''
    rlapi.EndDrawing()


def begin_mode2d(camera):
    '''Begin 2D mode with custom camera (2D)

    Raylib's C API: BeginMode2D

    :param Camera2D camera: `Camera2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginMode2D(camera)


def end_mode2d():
    '''Ends 2D mode with custom camera

    Raylib's C API: EndMode2D

    :return: None (`void` in C raylib)
    '''
    rlapi.EndMode2D()


def begin_mode3d(camera):
    '''Begin 3D mode with custom camera (3D)

    Raylib's C API: BeginMode3D

    :param Camera3D camera: `Camera3D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginMode3D(camera)


def end_mode3d():
    '''Ends 3D mode and returns to default 2D orthographic mode

    Raylib's C API: EndMode3D

    :return: None (`void` in C raylib)
    '''
    rlapi.EndMode3D()


def begin_texture_mode(target):
    '''Begin drawing to render texture

    Raylib's C API: BeginTextureMode

    :param RenderTexture2D target: `RenderTexture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginTextureMode(target)


def end_texture_mode():
    '''Ends drawing to render texture

    Raylib's C API: EndTextureMode

    :return: None (`void` in C raylib)
    '''
    rlapi.EndTextureMode()


def begin_shader_mode(shader):
    '''Begin custom shader drawing

    Raylib's C API: BeginShaderMode

    :param Shader shader: `Shader` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginShaderMode(shader)


def end_shader_mode():
    '''End custom shader drawing (use default shader)

    Raylib's C API: EndShaderMode

    :return: None (`void` in C raylib)
    '''
    rlapi.EndShaderMode()


def begin_blend_mode(mode):
    '''Begin blending mode (alpha, additive, multiplied, subtract, custom)

    Raylib's C API: BeginBlendMode

    :param int mode: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginBlendMode(int(mode))


def end_blend_mode():
    '''End blending mode (reset to default: alpha blending)

    Raylib's C API: EndBlendMode

    :return: None (`void` in C raylib)
    '''
    rlapi.EndBlendMode()


def begin_scissor_mode(x, y, width, height):
    '''Begin scissor mode (define screen area for following drawing)

    Raylib's C API: BeginScissorMode

    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginScissorMode(int(x), int(y), int(width), int(height))


def end_scissor_mode():
    '''End scissor mode

    Raylib's C API: EndScissorMode

    :return: None (`void` in C raylib)
    '''
    rlapi.EndScissorMode()


def begin_vr_stereo_mode(config):
    '''Begin stereo rendering (requires VR simulator)

    Raylib's C API: BeginVrStereoMode

    :param VrStereoConfig config: `VrStereoConfig` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.BeginVrStereoMode(config)


def end_vr_stereo_mode():
    '''End stereo rendering (requires VR simulator)

    Raylib's C API: EndVrStereoMode

    :return: None (`void` in C raylib)
    '''
    rlapi.EndVrStereoMode()


def load_vr_stereo_config(device):
    '''Load VR stereo config for VR simulator device parameters

    Raylib's C API: LoadVrStereoConfig

    :param VrDeviceInfo device: `VrDeviceInfo` in C raylib
    :return: VrStereoConfig (`VrStereoConfig` in C raylib)
    '''
    result = rlapi.LoadVrStereoConfig(device)
    return result


def unload_vr_stereo_config(config):
    '''Unload VR stereo config

    Raylib's C API: UnloadVrStereoConfig

    :param VrStereoConfig config: `VrStereoConfig` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadVrStereoConfig(config)


def load_shader(vs_file_name, fs_file_name):
    '''Load shader from files and bind default locations

    Raylib's C API: LoadShader

    :param bytes vs_file_name: `const char *` in C raylib
    :param bytes fs_file_name: `const char *` in C raylib
    :return: Shader (`Shader` in C raylib)
    '''
    result = rlapi.LoadShader(_str_in(vs_file_name), _str_in(fs_file_name))
    return result


def load_shader_from_memory(vs_code, fs_code):
    '''Load shader from code strings and bind default locations

    Raylib's C API: LoadShaderFromMemory

    :param bytes vs_code: `const char *` in C raylib
    :param bytes fs_code: `const char *` in C raylib
    :return: Shader (`Shader` in C raylib)
    '''
    result = rlapi.LoadShaderFromMemory(_str_in(vs_code), _str_in(fs_code))
    return result


def get_shader_location(shader, uniform_name):
    '''Get shader uniform location

    Raylib's C API: GetShaderLocation

    :param Shader shader: `Shader` in C raylib
    :param bytes uniform_name: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetShaderLocation(shader, _str_in(uniform_name))
    return result


def get_shader_location_attrib(shader, attrib_name):
    '''Get shader attribute location

    Raylib's C API: GetShaderLocationAttrib

    :param Shader shader: `Shader` in C raylib
    :param bytes attrib_name: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetShaderLocationAttrib(shader, _str_in(attrib_name))
    return result


def set_shader_value(shader, loc_index, value, uniform_type):
    '''Set shader uniform value

    Raylib's C API: SetShaderValue

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param bytes value: `const void *` in C raylib
    :param int uniform_type: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    value_ref = VoidPtr(value)
    rlapi.SetShaderValue(shader, int(loc_index), value_ref, int(uniform_type))
    return value_ref.contents.value


def set_shader_value_v(shader, loc_index, value, uniform_type, count):
    '''Set shader uniform value vector

    Raylib's C API: SetShaderValueV

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param bytes value: `const void *` in C raylib
    :param int uniform_type: `int` in C raylib
    :param int count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    value_ref = VoidPtr(value)
    rlapi.SetShaderValueV(shader, int(loc_index), value_ref, int(uniform_type), int(count))
    return value_ref.contents.value


def set_shader_value_matrix(shader, loc_index, mat):
    '''Set shader uniform value (matrix 4x4)

    Raylib's C API: SetShaderValueMatrix

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param Matrix mat: `Matrix` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetShaderValueMatrix(shader, int(loc_index), mat)


def set_shader_value_texture(shader, loc_index, texture):
    '''Set shader uniform value for texture (sampler2d)

    Raylib's C API: SetShaderValueTexture

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetShaderValueTexture(shader, int(loc_index), texture)


def unload_shader(shader):
    '''Unload shader from GPU memory (VRAM)

    Raylib's C API: UnloadShader

    :param Shader shader: `Shader` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadShader(shader)


def get_mouse_ray(mouse_position, camera):
    '''Get a ray trace from mouse position

    Raylib's C API: GetMouseRay

    :param Vector2 mouse_position: `Vector2` in C raylib
    :param Camera camera: `Camera` in C raylib
    :return: Ray (`Ray` in C raylib)
    '''
    result = rlapi.GetMouseRay(mouse_position, camera)
    return result


def get_camera_matrix(camera):
    '''Get camera transform matrix (view matrix)

    Raylib's C API: GetCameraMatrix

    :param Camera camera: `Camera` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = rlapi.GetCameraMatrix(camera)
    return result


def get_camera_matrix2d(camera):
    '''Get camera 2d transform matrix

    Raylib's C API: GetCameraMatrix2D

    :param Camera2D camera: `Camera2D` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = rlapi.GetCameraMatrix2D(camera)
    return result


def get_world_to_screen(position, camera):
    '''Get the screen space position for a 3d world space position

    Raylib's C API: GetWorldToScreen

    :param Vector3 position: `Vector3` in C raylib
    :param Camera camera: `Camera` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetWorldToScreen(position, camera)
    return result


def get_screen_to_world2d(position, camera):
    '''Get the world space position for a 2d camera screen space position

    Raylib's C API: GetScreenToWorld2D

    :param Vector2 position: `Vector2` in C raylib
    :param Camera2D camera: `Camera2D` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetScreenToWorld2D(position, camera)
    return result


def get_world_to_screen_ex(position, camera, width, height):
    '''Get size position for a 3d world space position

    Raylib's C API: GetWorldToScreenEx

    :param Vector3 position: `Vector3` in C raylib
    :param Camera camera: `Camera` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetWorldToScreenEx(position, camera, int(width), int(height))
    return result


def get_world_to_screen2d(position, camera):
    '''Get the screen space position for a 2d camera world space position

    Raylib's C API: GetWorldToScreen2D

    :param Vector2 position: `Vector2` in C raylib
    :param Camera2D camera: `Camera2D` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetWorldToScreen2D(position, camera)
    return result


def set_target_fps(fps):
    '''Set target FPS (maximum)

    Raylib's C API: SetTargetFPS

    :param int fps: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetTargetFPS(int(fps))


def get_fps():
    '''Get current FPS

    Raylib's C API: GetFPS

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetFPS()
    return result


def get_frame_time():
    '''Get time in seconds for last frame drawn (delta time)

    Raylib's C API: GetFrameTime

    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetFrameTime()
    return result


def get_time():
    '''Get elapsed time in seconds since InitWindow()

    Raylib's C API: GetTime

    :return: float (`double` in C raylib)
    '''
    result = rlapi.GetTime()
    return result


def get_random_value(min, max):
    '''Get a random value between min and max (both included)

    Raylib's C API: GetRandomValue

    :param int min: `int` in C raylib
    :param int max: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetRandomValue(int(min), int(max))
    return result


def set_random_seed(seed):
    '''Set the seed for the random number generator

    Raylib's C API: SetRandomSeed

    :param int seed: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetRandomSeed(int(seed))


def take_screenshot(file_name):
    '''Takes a screenshot of current screen (filename extension defines format)

    Raylib's C API: TakeScreenshot

    :param bytes file_name: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.TakeScreenshot(_str_in(file_name))


def set_config_flags(flags):
    '''Setup init configuration flags (view FLAGS)

    Raylib's C API: SetConfigFlags

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetConfigFlags(int(flags))


def trace_log(log_level, text, *args):
    '''Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)

    Raylib's C API: TraceLog

    :param int log_level: `int` in C raylib
    :param bytes text: `const char *` in C raylib
    :param bytes args: `...` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.TraceLog(int(log_level), _str_in(text), *args)


def set_trace_log_level(log_level):
    '''Set the current threshold (minimum) log level

    Raylib's C API: SetTraceLogLevel

    :param int log_level: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetTraceLogLevel(int(log_level))


def mem_alloc(size):
    '''Internal memory allocator

    Raylib's C API: MemAlloc

    :param int size: `int` in C raylib
    :return: bytes (`void *` in C raylib)
    '''
    result = rlapi.MemAlloc(int(size))
    return result


def mem_realloc(ptr, size):
    '''Internal memory reallocator

    Raylib's C API: MemRealloc

    :param bytes ptr: `void *` in C raylib
    :param int size: `int` in C raylib
    :return: bytes (`void *` in C raylib)
    '''
    ptr_ref = VoidPtr(ptr)
    result = rlapi.MemRealloc(ptr_ref, int(size))
    return result, ptr_ref.contents.value


def mem_free(ptr):
    '''Internal memory free

    Raylib's C API: MemFree

    :param bytes ptr: `void *` in C raylib
    :return: None (`void` in C raylib)
    '''
    ptr_ref = VoidPtr(ptr)
    rlapi.MemFree(ptr_ref)
    return ptr_ref.contents.value


def open_url(url):
    '''Open URL with default system browser (if available)

    Raylib's C API: OpenURL

    :param bytes url: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.OpenURL(_str_in(url))


def set_trace_log_callback(callback):
    '''Set custom trace log

    Raylib's C API: SetTraceLogCallback

    :param TraceLogCallback callback: `TraceLogCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetTraceLogCallback(callback)


def set_load_file_data_callback(callback):
    '''Set custom file binary data loader

    Raylib's C API: SetLoadFileDataCallback

    :param LoadFileDataCallback callback: `LoadFileDataCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetLoadFileDataCallback(callback)


def set_save_file_data_callback(callback):
    '''Set custom file binary data saver

    Raylib's C API: SetSaveFileDataCallback

    :param SaveFileDataCallback callback: `SaveFileDataCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetSaveFileDataCallback(callback)


def set_load_file_text_callback(callback):
    '''Set custom file text data loader

    Raylib's C API: SetLoadFileTextCallback

    :param LoadFileTextCallback callback: `LoadFileTextCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetLoadFileTextCallback(callback)


def set_save_file_text_callback(callback):
    '''Set custom file text data saver

    Raylib's C API: SetSaveFileTextCallback

    :param SaveFileTextCallback callback: `SaveFileTextCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetSaveFileTextCallback(callback)


def load_file_data(file_name, bytes_read):
    '''Load file data as byte array (read)

    Raylib's C API: LoadFileData

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] bytes_read: `unsigned int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    bytes_read_ref = UIntPtr(bytes_read)
    result = rlapi.LoadFileData(_str_in(file_name), bytes_read_ref)
    return result, bytes_read_ref.contents.value


def unload_file_data(data):
    '''Unload file data allocated by LoadFileData()

    Raylib's C API: UnloadFileData

    :param bytes data: `unsigned char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadFileData(_str_in(data))


def save_file_data(file_name, data, bytes_to_write):
    '''Save data to file from byte array (write), returns true on success

    Raylib's C API: SaveFileData

    :param bytes file_name: `const char *` in C raylib
    :param bytes data: `void *` in C raylib
    :param int bytes_to_write: `unsigned int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    data_ref = VoidPtr(data)
    result = rlapi.SaveFileData(_str_in(file_name), data_ref, int(bytes_to_write))
    return result, data_ref.contents.value


def export_data_as_code(data, size, file_name):
    '''Export data to code (.h), returns true on success

    Raylib's C API: ExportDataAsCode

    :param bytes data: `const char *` in C raylib
    :param int size: `unsigned int` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportDataAsCode(_str_in(data), int(size), _str_in(file_name))
    return result


def load_file_text(file_name):
    '''Load text data from file (read), returns a '\0' terminated string

    Raylib's C API: LoadFileText

    :param bytes file_name: `const char *` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    result = rlapi.LoadFileText(_str_in(file_name))
    return result


def unload_file_text(text):
    '''Unload file text data allocated by LoadFileText()

    Raylib's C API: UnloadFileText

    :param bytes text: `char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadFileText(_str_in(text))


def save_file_text(file_name, text):
    '''Save text data to file (write), string must be '\0' terminated, returns true on success

    Raylib's C API: SaveFileText

    :param bytes file_name: `const char *` in C raylib
    :param bytes text: `char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.SaveFileText(_str_in(file_name), _str_in(text))
    return result


def file_exists(file_name):
    '''Check if file exists

    Raylib's C API: FileExists

    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.FileExists(_str_in(file_name))
    return result


def directory_exists(dir_path):
    '''Check if a directory path exists

    Raylib's C API: DirectoryExists

    :param bytes dir_path: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.DirectoryExists(_str_in(dir_path))
    return result


def is_file_extension(file_name, ext):
    '''Check file extension (including point: .png, .wav)

    Raylib's C API: IsFileExtension

    :param bytes file_name: `const char *` in C raylib
    :param bytes ext: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsFileExtension(_str_in(file_name), _str_in(ext))
    return result


def get_file_length(file_name):
    '''Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)

    Raylib's C API: GetFileLength

    :param bytes file_name: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetFileLength(_str_in(file_name))
    return result


def get_file_extension(file_name):
    '''Get pointer to extension for a filename string (includes dot: '.png')

    Raylib's C API: GetFileExtension

    :param bytes file_name: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetFileExtension(_str_in(file_name))
    return result


def get_file_name(file_path):
    '''Get pointer to filename for a path string

    Raylib's C API: GetFileName

    :param bytes file_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetFileName(_str_in(file_path))
    return result


def get_file_name_without_ext(file_path):
    '''Get filename string without extension (uses static string)

    Raylib's C API: GetFileNameWithoutExt

    :param bytes file_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetFileNameWithoutExt(_str_in(file_path))
    return result


def get_directory_path(file_path):
    '''Get full path for a given fileName with path (uses static string)

    Raylib's C API: GetDirectoryPath

    :param bytes file_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetDirectoryPath(_str_in(file_path))
    return result


def get_prev_directory_path(dir_path):
    '''Get previous directory path for a given path (uses static string)

    Raylib's C API: GetPrevDirectoryPath

    :param bytes dir_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetPrevDirectoryPath(_str_in(dir_path))
    return result


def get_working_directory():
    '''Get current working directory (uses static string)

    Raylib's C API: GetWorkingDirectory

    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetWorkingDirectory()
    return result


def get_application_directory():
    '''Get the directory if the running application (uses static string)

    Raylib's C API: GetApplicationDirectory

    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetApplicationDirectory()
    return result


def change_directory(dir):
    '''Change working directory, return true on success

    Raylib's C API: ChangeDirectory

    :param bytes dir: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ChangeDirectory(_str_in(dir))
    return result


def is_path_file(path):
    '''Check if a given path is a file or a directory

    Raylib's C API: IsPathFile

    :param bytes path: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsPathFile(_str_in(path))
    return result


def load_directory_files(dir_path):
    '''Load directory filepaths

    Raylib's C API: LoadDirectoryFiles

    :param bytes dir_path: `const char *` in C raylib
    :return: FilePathList (`FilePathList` in C raylib)
    '''
    result = rlapi.LoadDirectoryFiles(_str_in(dir_path))
    return result


def load_directory_files_ex(base_path, filter, scan_subdirs):
    '''Load directory filepaths with extension filtering and recursive directory scan

    Raylib's C API: LoadDirectoryFilesEx

    :param bytes base_path: `const char *` in C raylib
    :param bytes filter: `const char *` in C raylib
    :param bool scan_subdirs: `bool` in C raylib
    :return: FilePathList (`FilePathList` in C raylib)
    '''
    result = rlapi.LoadDirectoryFilesEx(_str_in(base_path), _str_in(filter), bool(scan_subdirs))
    return result


def unload_directory_files(files):
    '''Unload filepaths

    Raylib's C API: UnloadDirectoryFiles

    :param FilePathList files: `FilePathList` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadDirectoryFiles(files)


def is_file_dropped():
    '''Check if a file has been dropped into window

    Raylib's C API: IsFileDropped

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsFileDropped()
    return result


def load_dropped_files():
    '''Load dropped filepaths

    Raylib's C API: LoadDroppedFiles

    :return: FilePathList (`FilePathList` in C raylib)
    '''
    result = rlapi.LoadDroppedFiles()
    return result


def unload_dropped_files(files):
    '''Unload dropped filepaths

    Raylib's C API: UnloadDroppedFiles

    :param FilePathList files: `FilePathList` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadDroppedFiles(files)


def get_file_mod_time(file_name):
    '''Get file modification time (last write time)

    Raylib's C API: GetFileModTime

    :param bytes file_name: `const char *` in C raylib
    :return: int (`long` in C raylib)
    '''
    result = rlapi.GetFileModTime(_str_in(file_name))
    return result


def compress_data(data, data_size, comp_data_size):
    '''Compress data (DEFLATE algorithm), memory must be MemFree()

    Raylib's C API: CompressData

    :param bytes data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param Sequence[int] comp_data_size: `int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    comp_data_size_ref = IntPtr(comp_data_size)
    result = rlapi.CompressData(_str_in(data), int(data_size), comp_data_size_ref)
    return result, comp_data_size_ref.contents.value


def decompress_data(comp_data, comp_data_size, data_size):
    '''Decompress data (DEFLATE algorithm), memory must be MemFree()

    Raylib's C API: DecompressData

    :param bytes comp_data: `const unsigned char *` in C raylib
    :param int comp_data_size: `int` in C raylib
    :param Sequence[int] data_size: `int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    data_size_ref = IntPtr(data_size)
    result = rlapi.DecompressData(_str_in(comp_data), int(comp_data_size), data_size_ref)
    return result, data_size_ref.contents.value


def encode_data_base64(data, data_size, output_size):
    '''Encode data to Base64 string, memory must be MemFree()

    Raylib's C API: EncodeDataBase64

    :param bytes data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param Sequence[int] output_size: `int *` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    output_size_ref = IntPtr(output_size)
    result = rlapi.EncodeDataBase64(_str_in(data), int(data_size), output_size_ref)
    return result, output_size_ref.contents.value


def decode_data_base64(data, output_size):
    '''Decode Base64 string data, memory must be MemFree()

    Raylib's C API: DecodeDataBase64

    :param bytes data: `const unsigned char *` in C raylib
    :param Sequence[int] output_size: `int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    output_size_ref = IntPtr(output_size)
    result = rlapi.DecodeDataBase64(_str_in(data), output_size_ref)
    return result, output_size_ref.contents.value


def is_key_pressed(key):
    '''Check if a key has been pressed once

    Raylib's C API: IsKeyPressed

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsKeyPressed(int(key))
    return result


def is_key_down(key):
    '''Check if a key is being pressed

    Raylib's C API: IsKeyDown

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsKeyDown(int(key))
    return result


def is_key_released(key):
    '''Check if a key has been released once

    Raylib's C API: IsKeyReleased

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsKeyReleased(int(key))
    return result


def is_key_up(key):
    '''Check if a key is NOT being pressed

    Raylib's C API: IsKeyUp

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsKeyUp(int(key))
    return result


def set_exit_key(key):
    '''Set a custom key to exit program (default is ESC)

    Raylib's C API: SetExitKey

    :param int key: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetExitKey(int(key))


def get_key_pressed():
    '''Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty

    Raylib's C API: GetKeyPressed

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetKeyPressed()
    return result


def get_char_pressed():
    '''Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty

    Raylib's C API: GetCharPressed

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetCharPressed()
    return result


def is_gamepad_available(gamepad):
    '''Check if a gamepad is available

    Raylib's C API: IsGamepadAvailable

    :param int gamepad: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsGamepadAvailable(int(gamepad))
    return result


def get_gamepad_name(gamepad):
    '''Get gamepad internal name id

    Raylib's C API: GetGamepadName

    :param int gamepad: `int` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.GetGamepadName(int(gamepad))
    return result


def is_gamepad_button_pressed(gamepad, button):
    '''Check if a gamepad button has been pressed once

    Raylib's C API: IsGamepadButtonPressed

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsGamepadButtonPressed(int(gamepad), int(button))
    return result


def is_gamepad_button_down(gamepad, button):
    '''Check if a gamepad button is being pressed

    Raylib's C API: IsGamepadButtonDown

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsGamepadButtonDown(int(gamepad), int(button))
    return result


def is_gamepad_button_released(gamepad, button):
    '''Check if a gamepad button has been released once

    Raylib's C API: IsGamepadButtonReleased

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsGamepadButtonReleased(int(gamepad), int(button))
    return result


def is_gamepad_button_up(gamepad, button):
    '''Check if a gamepad button is NOT being pressed

    Raylib's C API: IsGamepadButtonUp

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsGamepadButtonUp(int(gamepad), int(button))
    return result


def get_gamepad_button_pressed():
    '''Get the last gamepad button pressed

    Raylib's C API: GetGamepadButtonPressed

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetGamepadButtonPressed()
    return result


def get_gamepad_axis_count(gamepad):
    '''Get gamepad axis count for a gamepad

    Raylib's C API: GetGamepadAxisCount

    :param int gamepad: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetGamepadAxisCount(int(gamepad))
    return result


def get_gamepad_axis_movement(gamepad, axis):
    '''Get axis movement value for a gamepad axis

    Raylib's C API: GetGamepadAxisMovement

    :param int gamepad: `int` in C raylib
    :param int axis: `int` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetGamepadAxisMovement(int(gamepad), int(axis))
    return result


def set_gamepad_mappings(mappings):
    '''Set internal gamepad mappings (SDL_GameControllerDB)

    Raylib's C API: SetGamepadMappings

    :param bytes mappings: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.SetGamepadMappings(_str_in(mappings))
    return result


def is_mouse_button_pressed(button):
    '''Check if a mouse button has been pressed once

    Raylib's C API: IsMouseButtonPressed

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsMouseButtonPressed(int(button))
    return result


def is_mouse_button_down(button):
    '''Check if a mouse button is being pressed

    Raylib's C API: IsMouseButtonDown

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsMouseButtonDown(int(button))
    return result


def is_mouse_button_released(button):
    '''Check if a mouse button has been released once

    Raylib's C API: IsMouseButtonReleased

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsMouseButtonReleased(int(button))
    return result


def is_mouse_button_up(button):
    '''Check if a mouse button is NOT being pressed

    Raylib's C API: IsMouseButtonUp

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsMouseButtonUp(int(button))
    return result


def get_mouse_x():
    '''Get mouse position X

    Raylib's C API: GetMouseX

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMouseX()
    return result


def get_mouse_y():
    '''Get mouse position Y

    Raylib's C API: GetMouseY

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetMouseY()
    return result


def get_mouse_position():
    '''Get mouse position XY

    Raylib's C API: GetMousePosition

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetMousePosition()
    return result


def get_mouse_delta():
    '''Get mouse delta between frames

    Raylib's C API: GetMouseDelta

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetMouseDelta()
    return result


def set_mouse_position(x, y):
    '''Set mouse position XY

    Raylib's C API: SetMousePosition

    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMousePosition(int(x), int(y))


def set_mouse_offset(offset_x, offset_y):
    '''Set mouse offset

    Raylib's C API: SetMouseOffset

    :param int offset_x: `int` in C raylib
    :param int offset_y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMouseOffset(int(offset_x), int(offset_y))


def set_mouse_scale(scale_x, scale_y):
    '''Set mouse scaling

    Raylib's C API: SetMouseScale

    :param float scale_x: `float` in C raylib
    :param float scale_y: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMouseScale(float(scale_x), float(scale_y))


def get_mouse_wheel_move():
    '''Get mouse wheel movement for X or Y, whichever is larger

    Raylib's C API: GetMouseWheelMove

    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetMouseWheelMove()
    return result


def get_mouse_wheel_move_v():
    '''Get mouse wheel movement for both X and Y

    Raylib's C API: GetMouseWheelMoveV

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetMouseWheelMoveV()
    return result


def set_mouse_cursor(cursor):
    '''Set mouse cursor

    Raylib's C API: SetMouseCursor

    :param int cursor: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMouseCursor(int(cursor))


def get_touch_x():
    '''Get touch position X for touch point 0 (relative to screen size)

    Raylib's C API: GetTouchX

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetTouchX()
    return result


def get_touch_y():
    '''Get touch position Y for touch point 0 (relative to screen size)

    Raylib's C API: GetTouchY

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetTouchY()
    return result


def get_touch_position(index):
    '''Get touch position XY for a touch point index (relative to screen size)

    Raylib's C API: GetTouchPosition

    :param int index: `int` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetTouchPosition(int(index))
    return result


def get_touch_point_id(index):
    '''Get touch point identifier for given index

    Raylib's C API: GetTouchPointId

    :param int index: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetTouchPointId(int(index))
    return result


def get_touch_point_count():
    '''Get number of touch points

    Raylib's C API: GetTouchPointCount

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetTouchPointCount()
    return result


def set_gestures_enabled(flags):
    '''Enable a set of gestures using flags

    Raylib's C API: SetGesturesEnabled

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetGesturesEnabled(int(flags))


def is_gesture_detected(gesture):
    '''Check if a gesture have been detected

    Raylib's C API: IsGestureDetected

    :param int gesture: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsGestureDetected(int(gesture))
    return result


def get_gesture_detected():
    '''Get latest detected gesture

    Raylib's C API: GetGestureDetected

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetGestureDetected()
    return result


def get_gesture_hold_duration():
    '''Get gesture hold time in milliseconds

    Raylib's C API: GetGestureHoldDuration

    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetGestureHoldDuration()
    return result


def get_gesture_drag_vector():
    '''Get gesture drag vector

    Raylib's C API: GetGestureDragVector

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetGestureDragVector()
    return result


def get_gesture_drag_angle():
    '''Get gesture drag angle

    Raylib's C API: GetGestureDragAngle

    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetGestureDragAngle()
    return result


def get_gesture_pinch_vector():
    '''Get gesture pinch delta

    Raylib's C API: GetGesturePinchVector

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.GetGesturePinchVector()
    return result


def get_gesture_pinch_angle():
    '''Get gesture pinch angle

    Raylib's C API: GetGesturePinchAngle

    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetGesturePinchAngle()
    return result


def set_camera_mode(camera, mode):
    '''Set camera mode (multiple camera modes available)

    Raylib's C API: SetCameraMode

    :param Camera camera: `Camera` in C raylib
    :param int mode: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetCameraMode(camera, int(mode))


def update_camera(camera):
    '''Update camera position for selected mode

    Raylib's C API: UpdateCamera

    :param CameraPtr camera: `Camera *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UpdateCamera(camera)


def set_camera_pan_control(key_pan):
    '''Set camera pan key to combine with mouse movement (free camera)

    Raylib's C API: SetCameraPanControl

    :param int key_pan: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetCameraPanControl(int(key_pan))


def set_camera_alt_control(key_alt):
    '''Set camera alt key to combine with mouse movement (free camera)

    Raylib's C API: SetCameraAltControl

    :param int key_alt: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetCameraAltControl(int(key_alt))


def set_camera_smooth_zoom_control(key_smooth_zoom):
    '''Set camera smooth zoom key to combine with mouse (free camera)

    Raylib's C API: SetCameraSmoothZoomControl

    :param int key_smooth_zoom: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetCameraSmoothZoomControl(int(key_smooth_zoom))


def set_camera_move_controls(key_front, key_back, key_right, key_left, key_up, key_down):
    '''Set camera move controls (1st person and 3rd person cameras)

    Raylib's C API: SetCameraMoveControls

    :param int key_front: `int` in C raylib
    :param int key_back: `int` in C raylib
    :param int key_right: `int` in C raylib
    :param int key_left: `int` in C raylib
    :param int key_up: `int` in C raylib
    :param int key_down: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetCameraMoveControls(int(key_front), int(key_back), int(key_right), int(key_left), int(key_up), int(key_down))


def set_shapes_texture(texture, source):
    '''Set texture and rectangle to be used on shapes drawing

    Raylib's C API: SetShapesTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetShapesTexture(texture, source)


def draw_pixel(pos_x, pos_y, color):
    '''Draw a pixel

    Raylib's C API: DrawPixel

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPixel(int(pos_x), int(pos_y), color)


def draw_pixel_v(position, color):
    '''Draw a pixel (Vector version)

    Raylib's C API: DrawPixelV

    :param Vector2 position: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPixelV(position, color)


def draw_line(start_pos_x, start_pos_y, end_pos_x, end_pos_y, color):
    '''Draw a line

    Raylib's C API: DrawLine

    :param int start_pos_x: `int` in C raylib
    :param int start_pos_y: `int` in C raylib
    :param int end_pos_x: `int` in C raylib
    :param int end_pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLine(int(start_pos_x), int(start_pos_y), int(end_pos_x), int(end_pos_y), color)


def draw_line_v(start_pos, end_pos, color):
    '''Draw a line (Vector version)

    Raylib's C API: DrawLineV

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLineV(start_pos, end_pos, color)


def draw_line_ex(start_pos, end_pos, thick, color):
    '''Draw a line defining thickness

    Raylib's C API: DrawLineEx

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLineEx(start_pos, end_pos, float(thick), color)


def draw_line_bezier(start_pos, end_pos, thick, color):
    '''Draw a line using cubic-bezier curves in-out

    Raylib's C API: DrawLineBezier

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLineBezier(start_pos, end_pos, float(thick), color)


def draw_line_bezier_quad(start_pos, end_pos, control_pos, thick, color):
    '''Draw line using quadratic bezier curves with a control point

    Raylib's C API: DrawLineBezierQuad

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param Vector2 control_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLineBezierQuad(start_pos, end_pos, control_pos, float(thick), color)


def draw_line_bezier_cubic(start_pos, end_pos, start_control_pos, end_control_pos, thick, color):
    '''Draw line using cubic bezier curves with 2 control points

    Raylib's C API: DrawLineBezierCubic

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param Vector2 start_control_pos: `Vector2` in C raylib
    :param Vector2 end_control_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLineBezierCubic(start_pos, end_pos, start_control_pos, end_control_pos, float(thick), color)


def draw_line_strip(points, point_count, color):
    '''Draw lines sequence

    Raylib's C API: DrawLineStrip

    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLineStrip(points, int(point_count), color)


def draw_circle(center_x, center_y, radius, color):
    '''Draw a color-filled circle

    Raylib's C API: DrawCircle

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircle(int(center_x), int(center_y), float(radius), color)


def draw_circle_sector(center, radius, start_angle, end_angle, segments, color):
    '''Draw a piece of a circle

    Raylib's C API: DrawCircleSector

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircleSector(center, float(radius), float(start_angle), float(end_angle), int(segments), color)


def draw_circle_sector_lines(center, radius, start_angle, end_angle, segments, color):
    '''Draw circle sector outline

    Raylib's C API: DrawCircleSectorLines

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircleSectorLines(center, float(radius), float(start_angle), float(end_angle), int(segments), color)


def draw_circle_gradient(center_x, center_y, radius, color1, color2):
    '''Draw a gradient-filled circle

    Raylib's C API: DrawCircleGradient

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius: `float` in C raylib
    :param Color color1: `Color` in C raylib
    :param Color color2: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircleGradient(int(center_x), int(center_y), float(radius), color1, color2)


def draw_circle_v(center, radius, color):
    '''Draw a color-filled circle (Vector version)

    Raylib's C API: DrawCircleV

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircleV(center, float(radius), color)


def draw_circle_lines(center_x, center_y, radius, color):
    '''Draw circle outline

    Raylib's C API: DrawCircleLines

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircleLines(int(center_x), int(center_y), float(radius), color)


def draw_ellipse(center_x, center_y, radius_h, radius_v, color):
    '''Draw ellipse

    Raylib's C API: DrawEllipse

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius_h: `float` in C raylib
    :param float radius_v: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawEllipse(int(center_x), int(center_y), float(radius_h), float(radius_v), color)


def draw_ellipse_lines(center_x, center_y, radius_h, radius_v, color):
    '''Draw ellipse outline

    Raylib's C API: DrawEllipseLines

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius_h: `float` in C raylib
    :param float radius_v: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawEllipseLines(int(center_x), int(center_y), float(radius_h), float(radius_v), color)


def draw_ring(center, inner_radius, outer_radius, start_angle, end_angle, segments, color):
    '''Draw ring

    Raylib's C API: DrawRing

    :param Vector2 center: `Vector2` in C raylib
    :param float inner_radius: `float` in C raylib
    :param float outer_radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRing(center, float(inner_radius), float(outer_radius), float(start_angle), float(end_angle), int(segments), color)


def draw_ring_lines(center, inner_radius, outer_radius, start_angle, end_angle, segments, color):
    '''Draw ring outline

    Raylib's C API: DrawRingLines

    :param Vector2 center: `Vector2` in C raylib
    :param float inner_radius: `float` in C raylib
    :param float outer_radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRingLines(center, float(inner_radius), float(outer_radius), float(start_angle), float(end_angle), int(segments), color)


def draw_rectangle(pos_x, pos_y, width, height, color):
    '''Draw a color-filled rectangle

    Raylib's C API: DrawRectangle

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangle(int(pos_x), int(pos_y), int(width), int(height), color)


def draw_rectangle_v(position, size, color):
    '''Draw a color-filled rectangle (Vector version)

    Raylib's C API: DrawRectangleV

    :param Vector2 position: `Vector2` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleV(position, size, color)


def draw_rectangle_rec(rec, color):
    '''Draw a color-filled rectangle

    Raylib's C API: DrawRectangleRec

    :param Rectangle rec: `Rectangle` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleRec(rec, color)


def draw_rectangle_pro(rec, origin, rotation, color):
    '''Draw a color-filled rectangle with pro parameters

    Raylib's C API: DrawRectanglePro

    :param Rectangle rec: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectanglePro(rec, origin, float(rotation), color)


def draw_rectangle_gradient_v(pos_x, pos_y, width, height, color1, color2):
    '''Draw a vertical-gradient-filled rectangle

    Raylib's C API: DrawRectangleGradientV

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color1: `Color` in C raylib
    :param Color color2: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleGradientV(int(pos_x), int(pos_y), int(width), int(height), color1, color2)


def draw_rectangle_gradient_h(pos_x, pos_y, width, height, color1, color2):
    '''Draw a horizontal-gradient-filled rectangle

    Raylib's C API: DrawRectangleGradientH

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color1: `Color` in C raylib
    :param Color color2: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleGradientH(int(pos_x), int(pos_y), int(width), int(height), color1, color2)


def draw_rectangle_gradient_ex(rec, col1, col2, col3, col4):
    '''Draw a gradient-filled rectangle with custom vertex colors

    Raylib's C API: DrawRectangleGradientEx

    :param Rectangle rec: `Rectangle` in C raylib
    :param Color col1: `Color` in C raylib
    :param Color col2: `Color` in C raylib
    :param Color col3: `Color` in C raylib
    :param Color col4: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleGradientEx(rec, col1, col2, col3, col4)


def draw_rectangle_lines(pos_x, pos_y, width, height, color):
    '''Draw rectangle outline

    Raylib's C API: DrawRectangleLines

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleLines(int(pos_x), int(pos_y), int(width), int(height), color)


def draw_rectangle_lines_ex(rec, line_thick, color):
    '''Draw rectangle outline with extended parameters

    Raylib's C API: DrawRectangleLinesEx

    :param Rectangle rec: `Rectangle` in C raylib
    :param float line_thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleLinesEx(rec, float(line_thick), color)


def draw_rectangle_rounded(rec, roundness, segments, color):
    '''Draw rectangle with rounded edges

    Raylib's C API: DrawRectangleRounded

    :param Rectangle rec: `Rectangle` in C raylib
    :param float roundness: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleRounded(rec, float(roundness), int(segments), color)


def draw_rectangle_rounded_lines(rec, roundness, segments, line_thick, color):
    '''Draw rectangle with rounded edges outline

    Raylib's C API: DrawRectangleRoundedLines

    :param Rectangle rec: `Rectangle` in C raylib
    :param float roundness: `float` in C raylib
    :param int segments: `int` in C raylib
    :param float line_thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRectangleRoundedLines(rec, float(roundness), int(segments), float(line_thick), color)


def draw_triangle(v1, v2, v3, color):
    '''Draw a color-filled triangle (vertex in counter-clockwise order!)

    Raylib's C API: DrawTriangle

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :param Vector2 v3: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTriangle(v1, v2, v3, color)


def draw_triangle_lines(v1, v2, v3, color):
    '''Draw triangle outline (vertex in counter-clockwise order!)

    Raylib's C API: DrawTriangleLines

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :param Vector2 v3: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTriangleLines(v1, v2, v3, color)


def draw_triangle_fan(points, point_count, color):
    '''Draw a triangle fan defined by points (first vertex is the center)

    Raylib's C API: DrawTriangleFan

    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTriangleFan(points, int(point_count), color)


def draw_triangle_strip(points, point_count, color):
    '''Draw a triangle strip defined by points

    Raylib's C API: DrawTriangleStrip

    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTriangleStrip(points, int(point_count), color)


def draw_poly(center, sides, radius, rotation, color):
    '''Draw a regular polygon (Vector version)

    Raylib's C API: DrawPoly

    :param Vector2 center: `Vector2` in C raylib
    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :param float rotation: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPoly(center, int(sides), float(radius), float(rotation), color)


def draw_poly_lines(center, sides, radius, rotation, color):
    '''Draw a polygon outline of n sides

    Raylib's C API: DrawPolyLines

    :param Vector2 center: `Vector2` in C raylib
    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :param float rotation: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPolyLines(center, int(sides), float(radius), float(rotation), color)


def draw_poly_lines_ex(center, sides, radius, rotation, line_thick, color):
    '''Draw a polygon outline of n sides with extended parameters

    Raylib's C API: DrawPolyLinesEx

    :param Vector2 center: `Vector2` in C raylib
    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :param float rotation: `float` in C raylib
    :param float line_thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPolyLinesEx(center, int(sides), float(radius), float(rotation), float(line_thick), color)


def check_collision_recs(rec1, rec2):
    '''Check collision between two rectangles

    Raylib's C API: CheckCollisionRecs

    :param Rectangle rec1: `Rectangle` in C raylib
    :param Rectangle rec2: `Rectangle` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionRecs(rec1, rec2)
    return result


def check_collision_circles(center1, radius1, center2, radius2):
    '''Check collision between two circles

    Raylib's C API: CheckCollisionCircles

    :param Vector2 center1: `Vector2` in C raylib
    :param float radius1: `float` in C raylib
    :param Vector2 center2: `Vector2` in C raylib
    :param float radius2: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionCircles(center1, float(radius1), center2, float(radius2))
    return result


def check_collision_circle_rec(center, radius, rec):
    '''Check collision between circle and rectangle

    Raylib's C API: CheckCollisionCircleRec

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionCircleRec(center, float(radius), rec)
    return result


def check_collision_point_rec(point, rec):
    '''Check if point is inside rectangle

    Raylib's C API: CheckCollisionPointRec

    :param Vector2 point: `Vector2` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionPointRec(point, rec)
    return result


def check_collision_point_circle(point, center, radius):
    '''Check if point is inside circle

    Raylib's C API: CheckCollisionPointCircle

    :param Vector2 point: `Vector2` in C raylib
    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionPointCircle(point, center, float(radius))
    return result


def check_collision_point_triangle(point, p1, p2, p3):
    '''Check if point is inside a triangle

    Raylib's C API: CheckCollisionPointTriangle

    :param Vector2 point: `Vector2` in C raylib
    :param Vector2 p1: `Vector2` in C raylib
    :param Vector2 p2: `Vector2` in C raylib
    :param Vector2 p3: `Vector2` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionPointTriangle(point, p1, p2, p3)
    return result


def check_collision_lines(start_pos1, end_pos1, start_pos2, end_pos2, collision_point):
    '''Check the collision between two lines defined by two points each, returns collision point by reference

    Raylib's C API: CheckCollisionLines

    :param Vector2 start_pos1: `Vector2` in C raylib
    :param Vector2 end_pos1: `Vector2` in C raylib
    :param Vector2 start_pos2: `Vector2` in C raylib
    :param Vector2 end_pos2: `Vector2` in C raylib
    :param Vector2Ptr collision_point: `Vector2 *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionLines(start_pos1, end_pos1, start_pos2, end_pos2, collision_point)
    return result


def check_collision_point_line(point, p1, p2, threshold):
    '''Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]

    Raylib's C API: CheckCollisionPointLine

    :param Vector2 point: `Vector2` in C raylib
    :param Vector2 p1: `Vector2` in C raylib
    :param Vector2 p2: `Vector2` in C raylib
    :param int threshold: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionPointLine(point, p1, p2, int(threshold))
    return result


def get_collision_rec(rec1, rec2):
    '''Get collision rectangle for two rectangles collision

    Raylib's C API: GetCollisionRec

    :param Rectangle rec1: `Rectangle` in C raylib
    :param Rectangle rec2: `Rectangle` in C raylib
    :return: Rectangle (`Rectangle` in C raylib)
    '''
    result = rlapi.GetCollisionRec(rec1, rec2)
    return result


def load_image(file_name):
    '''Load image from file into CPU memory (RAM)

    Raylib's C API: LoadImage

    :param bytes file_name: `const char *` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.LoadImage(_str_in(file_name))
    return result


def load_image_raw(file_name, width, height, format, header_size):
    '''Load image from RAW file data

    Raylib's C API: LoadImageRaw

    :param bytes file_name: `const char *` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int format: `int` in C raylib
    :param int header_size: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.LoadImageRaw(_str_in(file_name), int(width), int(height), int(format), int(header_size))
    return result


def load_image_anim(file_name, frames):
    '''Load image sequence from file (frames appended to image.data)

    Raylib's C API: LoadImageAnim

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] frames: `int *` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    frames_ref = IntPtr(frames)
    result = rlapi.LoadImageAnim(_str_in(file_name), frames_ref)
    return result, frames_ref.contents.value


def load_image_from_memory(file_type, file_data, data_size):
    '''Load image from memory buffer, fileType refers to extension: i.e. '.png'

    Raylib's C API: LoadImageFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.LoadImageFromMemory(_str_in(file_type), _str_in(file_data), int(data_size))
    return result


def load_image_from_texture(texture):
    '''Load image from GPU texture data

    Raylib's C API: LoadImageFromTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.LoadImageFromTexture(texture)
    return result


def load_image_from_screen():
    '''Load image from screen buffer and (screenshot)

    Raylib's C API: LoadImageFromScreen

    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.LoadImageFromScreen()
    return result


def unload_image(image):
    '''Unload image from CPU memory (RAM)

    Raylib's C API: UnloadImage

    :param Image image: `Image` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadImage(image)


def export_image(image, file_name):
    '''Export image data to file, returns true on success

    Raylib's C API: ExportImage

    :param Image image: `Image` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportImage(image, _str_in(file_name))
    return result


def export_image_as_code(image, file_name):
    '''Export image as code file defining an array of bytes, returns true on success

    Raylib's C API: ExportImageAsCode

    :param Image image: `Image` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportImageAsCode(image, _str_in(file_name))
    return result


def gen_image_color(width, height, color):
    '''Generate image: plain color

    Raylib's C API: GenImageColor

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageColor(int(width), int(height), color)
    return result


def gen_image_gradient_v(width, height, top, bottom):
    '''Generate image: vertical gradient

    Raylib's C API: GenImageGradientV

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color top: `Color` in C raylib
    :param Color bottom: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageGradientV(int(width), int(height), top, bottom)
    return result


def gen_image_gradient_h(width, height, left, right):
    '''Generate image: horizontal gradient

    Raylib's C API: GenImageGradientH

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color left: `Color` in C raylib
    :param Color right: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageGradientH(int(width), int(height), left, right)
    return result


def gen_image_gradient_radial(width, height, density, inner, outer):
    '''Generate image: radial gradient

    Raylib's C API: GenImageGradientRadial

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param float density: `float` in C raylib
    :param Color inner: `Color` in C raylib
    :param Color outer: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageGradientRadial(int(width), int(height), float(density), inner, outer)
    return result


def gen_image_checked(width, height, checks_x, checks_y, col1, col2):
    '''Generate image: checked

    Raylib's C API: GenImageChecked

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int checks_x: `int` in C raylib
    :param int checks_y: `int` in C raylib
    :param Color col1: `Color` in C raylib
    :param Color col2: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageChecked(int(width), int(height), int(checks_x), int(checks_y), col1, col2)
    return result


def gen_image_white_noise(width, height, factor):
    '''Generate image: white noise

    Raylib's C API: GenImageWhiteNoise

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param float factor: `float` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageWhiteNoise(int(width), int(height), float(factor))
    return result


def gen_image_cellular(width, height, tile_size):
    '''Generate image: cellular algorithm, bigger tileSize means bigger cells

    Raylib's C API: GenImageCellular

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int tile_size: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageCellular(int(width), int(height), int(tile_size))
    return result


def image_copy(image):
    '''Create an image duplicate (useful for transformations)

    Raylib's C API: ImageCopy

    :param Image image: `Image` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.ImageCopy(image)
    return result


def image_from_image(image, rec):
    '''Create an image from another image piece

    Raylib's C API: ImageFromImage

    :param Image image: `Image` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.ImageFromImage(image, rec)
    return result


def image_text(text, font_size, color):
    '''Create an image from text (default font)

    Raylib's C API: ImageText

    :param bytes text: `const char *` in C raylib
    :param int font_size: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.ImageText(_str_in(text), int(font_size), color)
    return result


def image_text_ex(font, text, font_size, spacing, tint):
    '''Create an image from text (custom sprite font)

    Raylib's C API: ImageTextEx

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.ImageTextEx(font, _str_in(text), float(font_size), float(spacing), tint)
    return result


def image_format(image, new_format):
    '''Convert image data to desired format

    Raylib's C API: ImageFormat

    :param ImagePtr image: `Image *` in C raylib
    :param int new_format: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageFormat(image, int(new_format))


def image_to_pot(image, fill):
    '''Convert image to POT (power-of-two)

    Raylib's C API: ImageToPOT

    :param ImagePtr image: `Image *` in C raylib
    :param Color fill: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageToPOT(image, fill)


def image_crop(image, crop):
    '''Crop an image to a defined rectangle

    Raylib's C API: ImageCrop

    :param ImagePtr image: `Image *` in C raylib
    :param Rectangle crop: `Rectangle` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageCrop(image, crop)


def image_alpha_crop(image, threshold):
    '''Crop image depending on alpha value

    Raylib's C API: ImageAlphaCrop

    :param ImagePtr image: `Image *` in C raylib
    :param float threshold: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageAlphaCrop(image, float(threshold))


def image_alpha_clear(image, color, threshold):
    '''Clear alpha channel to desired color

    Raylib's C API: ImageAlphaClear

    :param ImagePtr image: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :param float threshold: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageAlphaClear(image, color, float(threshold))


def image_alpha_mask(image, alpha_mask):
    '''Apply alpha mask to image

    Raylib's C API: ImageAlphaMask

    :param ImagePtr image: `Image *` in C raylib
    :param Image alpha_mask: `Image` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageAlphaMask(image, alpha_mask)


def image_alpha_premultiply(image):
    '''Premultiply alpha channel

    Raylib's C API: ImageAlphaPremultiply

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageAlphaPremultiply(image)


def image_resize(image, new_width, new_height):
    '''Resize image (Bicubic scaling algorithm)

    Raylib's C API: ImageResize

    :param ImagePtr image: `Image *` in C raylib
    :param int new_width: `int` in C raylib
    :param int new_height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageResize(image, int(new_width), int(new_height))


def image_resize_nn(image, new_width, new_height):
    '''Resize image (Nearest-Neighbor scaling algorithm)

    Raylib's C API: ImageResizeNN

    :param ImagePtr image: `Image *` in C raylib
    :param int new_width: `int` in C raylib
    :param int new_height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageResizeNN(image, int(new_width), int(new_height))


def image_resize_canvas(image, new_width, new_height, offset_x, offset_y, fill):
    '''Resize canvas and fill with color

    Raylib's C API: ImageResizeCanvas

    :param ImagePtr image: `Image *` in C raylib
    :param int new_width: `int` in C raylib
    :param int new_height: `int` in C raylib
    :param int offset_x: `int` in C raylib
    :param int offset_y: `int` in C raylib
    :param Color fill: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageResizeCanvas(image, int(new_width), int(new_height), int(offset_x), int(offset_y), fill)


def image_mipmaps(image):
    '''Compute all mipmap levels for a provided image

    Raylib's C API: ImageMipmaps

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageMipmaps(image)


def image_dither(image, r_bpp, g_bpp, b_bpp, a_bpp):
    '''Dither image data to 16bpp or lower (Floyd-Steinberg dithering)

    Raylib's C API: ImageDither

    :param ImagePtr image: `Image *` in C raylib
    :param int r_bpp: `int` in C raylib
    :param int g_bpp: `int` in C raylib
    :param int b_bpp: `int` in C raylib
    :param int a_bpp: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDither(image, int(r_bpp), int(g_bpp), int(b_bpp), int(a_bpp))


def image_flip_vertical(image):
    '''Flip image vertically

    Raylib's C API: ImageFlipVertical

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageFlipVertical(image)


def image_flip_horizontal(image):
    '''Flip image horizontally

    Raylib's C API: ImageFlipHorizontal

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageFlipHorizontal(image)


def image_rotate_cw(image):
    '''Rotate image clockwise 90deg

    Raylib's C API: ImageRotateCW

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageRotateCW(image)


def image_rotate_ccw(image):
    '''Rotate image counter-clockwise 90deg

    Raylib's C API: ImageRotateCCW

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageRotateCCW(image)


def image_color_tint(image, color):
    '''Modify image color: tint

    Raylib's C API: ImageColorTint

    :param ImagePtr image: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageColorTint(image, color)


def image_color_invert(image):
    '''Modify image color: invert

    Raylib's C API: ImageColorInvert

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageColorInvert(image)


def image_color_grayscale(image):
    '''Modify image color: grayscale

    Raylib's C API: ImageColorGrayscale

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageColorGrayscale(image)


def image_color_contrast(image, contrast):
    '''Modify image color: contrast (-100 to 100)

    Raylib's C API: ImageColorContrast

    :param ImagePtr image: `Image *` in C raylib
    :param float contrast: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageColorContrast(image, float(contrast))


def image_color_brightness(image, brightness):
    '''Modify image color: brightness (-255 to 255)

    Raylib's C API: ImageColorBrightness

    :param ImagePtr image: `Image *` in C raylib
    :param int brightness: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageColorBrightness(image, int(brightness))


def image_color_replace(image, color, replace):
    '''Modify image color: replace color

    Raylib's C API: ImageColorReplace

    :param ImagePtr image: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :param Color replace: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageColorReplace(image, color, replace)


def load_image_colors(image):
    '''Load color data from image as a Color array (RGBA - 32bit)

    Raylib's C API: LoadImageColors

    :param Image image: `Image` in C raylib
    :return: ColorPtr (`Color *` in C raylib)
    '''
    result = rlapi.LoadImageColors(image)
    return result


def load_image_palette(image, max_palette_size, color_count):
    '''Load colors palette from image as a Color array (RGBA - 32bit)

    Raylib's C API: LoadImagePalette

    :param Image image: `Image` in C raylib
    :param int max_palette_size: `int` in C raylib
    :param Sequence[int] color_count: `int *` in C raylib
    :return: ColorPtr (`Color *` in C raylib)
    '''
    color_count_ref = IntPtr(color_count)
    result = rlapi.LoadImagePalette(image, int(max_palette_size), color_count_ref)
    return result, color_count_ref.contents.value


def unload_image_colors(colors):
    '''Unload color data loaded with LoadImageColors()

    Raylib's C API: UnloadImageColors

    :param ColorPtr colors: `Color *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadImageColors(colors)


def unload_image_palette(colors):
    '''Unload colors palette loaded with LoadImagePalette()

    Raylib's C API: UnloadImagePalette

    :param ColorPtr colors: `Color *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadImagePalette(colors)


def get_image_alpha_border(image, threshold):
    '''Get image alpha border rectangle

    Raylib's C API: GetImageAlphaBorder

    :param Image image: `Image` in C raylib
    :param float threshold: `float` in C raylib
    :return: Rectangle (`Rectangle` in C raylib)
    '''
    result = rlapi.GetImageAlphaBorder(image, float(threshold))
    return result


def get_image_color(image, x, y):
    '''Get image pixel color at (x, y) position

    Raylib's C API: GetImageColor

    :param Image image: `Image` in C raylib
    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.GetImageColor(image, int(x), int(y))
    return result


def image_clear_background(dst, color):
    '''Clear image background with given color

    Raylib's C API: ImageClearBackground

    :param ImagePtr dst: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageClearBackground(dst, color)


def image_draw_pixel(dst, pos_x, pos_y, color):
    '''Draw pixel within an image

    Raylib's C API: ImageDrawPixel

    :param ImagePtr dst: `Image *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawPixel(dst, int(pos_x), int(pos_y), color)


def image_draw_pixel_v(dst, position, color):
    '''Draw pixel within an image (Vector version)

    Raylib's C API: ImageDrawPixelV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawPixelV(dst, position, color)


def image_draw_line(dst, start_pos_x, start_pos_y, end_pos_x, end_pos_y, color):
    '''Draw line within an image

    Raylib's C API: ImageDrawLine

    :param ImagePtr dst: `Image *` in C raylib
    :param int start_pos_x: `int` in C raylib
    :param int start_pos_y: `int` in C raylib
    :param int end_pos_x: `int` in C raylib
    :param int end_pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawLine(dst, int(start_pos_x), int(start_pos_y), int(end_pos_x), int(end_pos_y), color)


def image_draw_line_v(dst, start, end, color):
    '''Draw line within an image (Vector version)

    Raylib's C API: ImageDrawLineV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 start: `Vector2` in C raylib
    :param Vector2 end: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawLineV(dst, start, end, color)


def image_draw_circle(dst, center_x, center_y, radius, color):
    '''Draw circle within an image

    Raylib's C API: ImageDrawCircle

    :param ImagePtr dst: `Image *` in C raylib
    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param int radius: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawCircle(dst, int(center_x), int(center_y), int(radius), color)


def image_draw_circle_v(dst, center, radius, color):
    '''Draw circle within an image (Vector version)

    Raylib's C API: ImageDrawCircleV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 center: `Vector2` in C raylib
    :param int radius: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawCircleV(dst, center, int(radius), color)


def image_draw_rectangle(dst, pos_x, pos_y, width, height, color):
    '''Draw rectangle within an image

    Raylib's C API: ImageDrawRectangle

    :param ImagePtr dst: `Image *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawRectangle(dst, int(pos_x), int(pos_y), int(width), int(height), color)


def image_draw_rectangle_v(dst, position, size, color):
    '''Draw rectangle within an image (Vector version)

    Raylib's C API: ImageDrawRectangleV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawRectangleV(dst, position, size, color)


def image_draw_rectangle_rec(dst, rec, color):
    '''Draw rectangle within an image

    Raylib's C API: ImageDrawRectangleRec

    :param ImagePtr dst: `Image *` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawRectangleRec(dst, rec, color)


def image_draw_rectangle_lines(dst, rec, thick, color):
    '''Draw rectangle lines within an image

    Raylib's C API: ImageDrawRectangleLines

    :param ImagePtr dst: `Image *` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :param int thick: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawRectangleLines(dst, rec, int(thick), color)


def image_draw(dst, src, src_rec, dst_rec, tint):
    '''Draw a source image within a destination image (tint applied to source)

    Raylib's C API: ImageDraw

    :param ImagePtr dst: `Image *` in C raylib
    :param Image src: `Image` in C raylib
    :param Rectangle src_rec: `Rectangle` in C raylib
    :param Rectangle dst_rec: `Rectangle` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDraw(dst, src, src_rec, dst_rec, tint)


def image_draw_text(dst, text, pos_x, pos_y, font_size, color):
    '''Draw text (using default font) within an image (destination)

    Raylib's C API: ImageDrawText

    :param ImagePtr dst: `Image *` in C raylib
    :param bytes text: `const char *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawText(dst, _str_in(text), int(pos_x), int(pos_y), int(font_size), color)


def image_draw_text_ex(dst, font, text, position, font_size, spacing, tint):
    '''Draw text (custom sprite font) within an image (destination)

    Raylib's C API: ImageDrawTextEx

    :param ImagePtr dst: `Image *` in C raylib
    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ImageDrawTextEx(dst, font, _str_in(text), position, float(font_size), float(spacing), tint)


def load_texture(file_name):
    '''Load texture from file into GPU memory (VRAM)

    Raylib's C API: LoadTexture

    :param bytes file_name: `const char *` in C raylib
    :return: Texture2D (`Texture2D` in C raylib)
    '''
    result = rlapi.LoadTexture(_str_in(file_name))
    return result


def load_texture_from_image(image):
    '''Load texture from image data

    Raylib's C API: LoadTextureFromImage

    :param Image image: `Image` in C raylib
    :return: Texture2D (`Texture2D` in C raylib)
    '''
    result = rlapi.LoadTextureFromImage(image)
    return result


def load_texture_cubemap(image, layout):
    '''Load cubemap from image, multiple image cubemap layouts supported

    Raylib's C API: LoadTextureCubemap

    :param Image image: `Image` in C raylib
    :param int layout: `int` in C raylib
    :return: TextureCubemap (`TextureCubemap` in C raylib)
    '''
    result = rlapi.LoadTextureCubemap(image, int(layout))
    return result


def load_render_texture(width, height):
    '''Load texture for rendering (framebuffer)

    Raylib's C API: LoadRenderTexture

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: RenderTexture2D (`RenderTexture2D` in C raylib)
    '''
    result = rlapi.LoadRenderTexture(int(width), int(height))
    return result


def unload_texture(texture):
    '''Unload texture from GPU memory (VRAM)

    Raylib's C API: UnloadTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadTexture(texture)


def unload_render_texture(target):
    '''Unload render texture from GPU memory (VRAM)

    Raylib's C API: UnloadRenderTexture

    :param RenderTexture2D target: `RenderTexture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadRenderTexture(target)


def update_texture(texture, pixels):
    '''Update GPU texture with new data

    Raylib's C API: UpdateTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param bytes pixels: `const void *` in C raylib
    :return: None (`void` in C raylib)
    '''
    pixels_ref = VoidPtr(pixels)
    rlapi.UpdateTexture(texture, pixels_ref)
    return pixels_ref.contents.value


def update_texture_rec(texture, rec, pixels):
    '''Update GPU texture rectangle with new data

    Raylib's C API: UpdateTextureRec

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :param bytes pixels: `const void *` in C raylib
    :return: None (`void` in C raylib)
    '''
    pixels_ref = VoidPtr(pixels)
    rlapi.UpdateTextureRec(texture, rec, pixels_ref)
    return pixels_ref.contents.value


def gen_texture_mipmaps(texture):
    '''Generate GPU mipmaps for a texture

    Raylib's C API: GenTextureMipmaps

    :param Texture2DPtr texture: `Texture2D *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.GenTextureMipmaps(texture)


def set_texture_filter(texture, filter):
    '''Set texture scaling filter mode

    Raylib's C API: SetTextureFilter

    :param Texture2D texture: `Texture2D` in C raylib
    :param int filter: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetTextureFilter(texture, int(filter))


def set_texture_wrap(texture, wrap):
    '''Set texture wrapping mode

    Raylib's C API: SetTextureWrap

    :param Texture2D texture: `Texture2D` in C raylib
    :param int wrap: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetTextureWrap(texture, int(wrap))


def draw_texture(texture, pos_x, pos_y, tint):
    '''Draw a Texture2D

    Raylib's C API: DrawTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTexture(texture, int(pos_x), int(pos_y), tint)


def draw_texture_v(texture, position, tint):
    '''Draw a Texture2D with position defined as Vector2

    Raylib's C API: DrawTextureV

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextureV(texture, position, tint)


def draw_texture_ex(texture, position, rotation, scale, tint):
    '''Draw a Texture2D with extended parameters

    Raylib's C API: DrawTextureEx

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextureEx(texture, position, float(rotation), float(scale), tint)


def draw_texture_rec(texture, source, position, tint):
    '''Draw a part of a texture defined by a rectangle

    Raylib's C API: DrawTextureRec

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextureRec(texture, source, position, tint)


def draw_texture_quad(texture, tiling, offset, quad, tint):
    '''Draw texture quad with tiling and offset parameters

    Raylib's C API: DrawTextureQuad

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 tiling: `Vector2` in C raylib
    :param Vector2 offset: `Vector2` in C raylib
    :param Rectangle quad: `Rectangle` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextureQuad(texture, tiling, offset, quad, tint)


def draw_texture_tiled(texture, source, dest, origin, rotation, scale, tint):
    '''Draw part of a texture (defined by a rectangle) with rotation and scale tiled into dest.

    Raylib's C API: DrawTextureTiled

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Rectangle dest: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextureTiled(texture, source, dest, origin, float(rotation), float(scale), tint)


def draw_texture_pro(texture, source, dest, origin, rotation, tint):
    '''Draw a part of a texture defined by a rectangle with 'pro' parameters

    Raylib's C API: DrawTexturePro

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Rectangle dest: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTexturePro(texture, source, dest, origin, float(rotation), tint)


def draw_texture_npatch(texture, n_patch_info, dest, origin, rotation, tint):
    '''Draws a texture (or part of it) that stretches or shrinks nicely

    Raylib's C API: DrawTextureNPatch

    :param Texture2D texture: `Texture2D` in C raylib
    :param NPatchInfo n_patch_info: `NPatchInfo` in C raylib
    :param Rectangle dest: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextureNPatch(texture, n_patch_info, dest, origin, float(rotation), tint)


def draw_texture_poly(texture, center, points, texcoords, point_count, tint):
    '''Draw a textured polygon

    Raylib's C API: DrawTexturePoly

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 center: `Vector2` in C raylib
    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param Vector2Ptr texcoords: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTexturePoly(texture, center, points, texcoords, int(point_count), tint)


def fade(color, alpha):
    '''Get color with alpha applied, alpha goes from 0.0f to 1.0f

    Raylib's C API: Fade

    :param Color color: `Color` in C raylib
    :param float alpha: `float` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.Fade(color, float(alpha))
    return result


def color_to_int(color):
    '''Get hexadecimal value for a Color

    Raylib's C API: ColorToInt

    :param Color color: `Color` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.ColorToInt(color)
    return result


def color_normalize(color):
    '''Get Color normalized as float [0..1]

    Raylib's C API: ColorNormalize

    :param Color color: `Color` in C raylib
    :return: Vector4 (`Vector4` in C raylib)
    '''
    result = rlapi.ColorNormalize(color)
    return result


def color_from_normalized(normalized):
    '''Get Color from normalized values [0..1]

    Raylib's C API: ColorFromNormalized

    :param Vector4 normalized: `Vector4` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.ColorFromNormalized(normalized)
    return result


def color_to_hsv(color):
    '''Get HSV values for a Color, hue [0..360], saturation/value [0..1]

    Raylib's C API: ColorToHSV

    :param Color color: `Color` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = rlapi.ColorToHSV(color)
    return result


def color_from_hsv(hue, saturation, value):
    '''Get a Color from HSV values, hue [0..360], saturation/value [0..1]

    Raylib's C API: ColorFromHSV

    :param float hue: `float` in C raylib
    :param float saturation: `float` in C raylib
    :param float value: `float` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.ColorFromHSV(float(hue), float(saturation), float(value))
    return result


def color_alpha(color, alpha):
    '''Get color with alpha applied, alpha goes from 0.0f to 1.0f

    Raylib's C API: ColorAlpha

    :param Color color: `Color` in C raylib
    :param float alpha: `float` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.ColorAlpha(color, float(alpha))
    return result


def color_alpha_blend(dst, src, tint):
    '''Get src alpha-blended into dst color with tint

    Raylib's C API: ColorAlphaBlend

    :param Color dst: `Color` in C raylib
    :param Color src: `Color` in C raylib
    :param Color tint: `Color` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.ColorAlphaBlend(dst, src, tint)
    return result


def get_color(hex_value):
    '''Get Color structure from hexadecimal value

    Raylib's C API: GetColor

    :param int hex_value: `unsigned int` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = rlapi.GetColor(int(hex_value))
    return result


def get_pixel_color(src_ptr, format):
    '''Get Color from a source pixel pointer of certain format

    Raylib's C API: GetPixelColor

    :param bytes src_ptr: `void *` in C raylib
    :param int format: `int` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    src_ptr_ref = VoidPtr(src_ptr)
    result = rlapi.GetPixelColor(src_ptr_ref, int(format))
    return result, src_ptr_ref.contents.value


def set_pixel_color(dst_ptr, color, format):
    '''Set color formatted into destination pixel pointer

    Raylib's C API: SetPixelColor

    :param bytes dst_ptr: `void *` in C raylib
    :param Color color: `Color` in C raylib
    :param int format: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    dst_ptr_ref = VoidPtr(dst_ptr)
    rlapi.SetPixelColor(dst_ptr_ref, color, int(format))
    return dst_ptr_ref.contents.value


def get_pixel_data_size(width, height, format):
    '''Get pixel data size in bytes for certain format

    Raylib's C API: GetPixelDataSize

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int format: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetPixelDataSize(int(width), int(height), int(format))
    return result


def get_font_default():
    '''Get the default Font

    Raylib's C API: GetFontDefault

    :return: Font (`Font` in C raylib)
    '''
    result = rlapi.GetFontDefault()
    return result


def load_font(file_name):
    '''Load font from file into GPU memory (VRAM)

    Raylib's C API: LoadFont

    :param bytes file_name: `const char *` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    result = rlapi.LoadFont(_str_in(file_name))
    return result


def load_font_ex(file_name, font_size, font_chars, glyph_count):
    '''Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set

    Raylib's C API: LoadFontEx

    :param bytes file_name: `const char *` in C raylib
    :param int font_size: `int` in C raylib
    :param Sequence[int] font_chars: `int *` in C raylib
    :param int glyph_count: `int` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    font_chars_ref = IntPtr(font_chars)
    result = rlapi.LoadFontEx(_str_in(file_name), int(font_size), font_chars_ref, int(glyph_count))
    return result, font_chars_ref.contents.value


def load_font_from_image(image, key, first_char):
    '''Load font from Image (XNA style)

    Raylib's C API: LoadFontFromImage

    :param Image image: `Image` in C raylib
    :param Color key: `Color` in C raylib
    :param int first_char: `int` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    result = rlapi.LoadFontFromImage(image, key, int(first_char))
    return result


def load_font_from_memory(file_type, file_data, data_size, font_size, font_chars, glyph_count):
    '''Load font from memory buffer, fileType refers to extension: i.e. '.ttf'

    Raylib's C API: LoadFontFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Sequence[int] font_chars: `int *` in C raylib
    :param int glyph_count: `int` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    font_chars_ref = IntPtr(font_chars)
    result = rlapi.LoadFontFromMemory(_str_in(file_type), _str_in(file_data), int(data_size), int(font_size), font_chars_ref, int(glyph_count))
    return result, font_chars_ref.contents.value


def load_font_data(file_data, data_size, font_size, font_chars, glyph_count, type):
    '''Load font data for further use

    Raylib's C API: LoadFontData

    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Sequence[int] font_chars: `int *` in C raylib
    :param int glyph_count: `int` in C raylib
    :param int type: `int` in C raylib
    :return: GlyphInfoPtr (`GlyphInfo *` in C raylib)
    '''
    font_chars_ref = IntPtr(font_chars)
    result = rlapi.LoadFontData(_str_in(file_data), int(data_size), int(font_size), font_chars_ref, int(glyph_count), int(type))
    return result, font_chars_ref.contents.value


def gen_image_font_atlas(chars, recs, glyph_count, font_size, padding, pack_method):
    '''Generate image font atlas using chars info

    Raylib's C API: GenImageFontAtlas

    :param GlyphInfoPtr chars: `const GlyphInfo *` in C raylib
    :param Sequence[RectanglePtr] recs: `Rectangle **` in C raylib
    :param int glyph_count: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param int padding: `int` in C raylib
    :param int pack_method: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = rlapi.GenImageFontAtlas(chars, recs, int(glyph_count), int(font_size), int(padding), int(pack_method))
    return result


def unload_font_data(chars, glyph_count):
    '''Unload font chars info data (RAM)

    Raylib's C API: UnloadFontData

    :param GlyphInfoPtr chars: `GlyphInfo *` in C raylib
    :param int glyph_count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadFontData(chars, int(glyph_count))


def unload_font(font):
    '''Unload font from GPU memory (VRAM)

    Raylib's C API: UnloadFont

    :param Font font: `Font` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadFont(font)


def export_font_as_code(font, file_name):
    '''Export font as code file, returns true on success

    Raylib's C API: ExportFontAsCode

    :param Font font: `Font` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportFontAsCode(font, _str_in(file_name))
    return result


def draw_fps(pos_x, pos_y):
    '''Draw current FPS

    Raylib's C API: DrawFPS

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawFPS(int(pos_x), int(pos_y))


def draw_text(text, pos_x, pos_y, font_size, color):
    '''Draw text (using default font)

    Raylib's C API: DrawText

    :param bytes text: `const char *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawText(_str_in(text), int(pos_x), int(pos_y), int(font_size), color)


def draw_text_ex(font, text, position, font_size, spacing, tint):
    '''Draw text using font and additional parameters

    Raylib's C API: DrawTextEx

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextEx(font, _str_in(text), position, float(font_size), float(spacing), tint)


def draw_text_pro(font, text, position, origin, rotation, font_size, spacing, tint):
    '''Draw text using Font and pro parameters (rotation)

    Raylib's C API: DrawTextPro

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextPro(font, _str_in(text), position, origin, float(rotation), float(font_size), float(spacing), tint)


def draw_text_codepoint(font, codepoint, position, font_size, tint):
    '''Draw one character (codepoint)

    Raylib's C API: DrawTextCodepoint

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTextCodepoint(font, int(codepoint), position, float(font_size), tint)


def draw_text_codepoints(font, codepoints, count, position, font_size, spacing, tint):
    '''Draw multiple character (codepoint)

    Raylib's C API: DrawTextCodepoints

    :param Font font: `Font` in C raylib
    :param Sequence[int] codepoints: `const int *` in C raylib
    :param int count: `int` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    codepoints_ref = IntPtr(codepoints)
    rlapi.DrawTextCodepoints(font, codepoints_ref, int(count), position, float(font_size), float(spacing), tint)
    return codepoints_ref.contents.value


def measure_text(text, font_size):
    '''Measure string width for default font

    Raylib's C API: MeasureText

    :param bytes text: `const char *` in C raylib
    :param int font_size: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.MeasureText(_str_in(text), int(font_size))
    return result


def measure_text_ex(font, text, font_size, spacing):
    '''Measure string size for Font

    Raylib's C API: MeasureTextEx

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = rlapi.MeasureTextEx(font, _str_in(text), float(font_size), float(spacing))
    return result


def get_glyph_index(font, codepoint):
    '''Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found

    Raylib's C API: GetGlyphIndex

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetGlyphIndex(font, int(codepoint))
    return result


def get_glyph_info(font, codepoint):
    '''Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found

    Raylib's C API: GetGlyphInfo

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :return: GlyphInfo (`GlyphInfo` in C raylib)
    '''
    result = rlapi.GetGlyphInfo(font, int(codepoint))
    return result


def get_glyph_atlas_rec(font, codepoint):
    '''Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found

    Raylib's C API: GetGlyphAtlasRec

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :return: Rectangle (`Rectangle` in C raylib)
    '''
    result = rlapi.GetGlyphAtlasRec(font, int(codepoint))
    return result


def load_codepoints(text, count):
    '''Load all codepoints from a UTF-8 text string, codepoints count returned by parameter

    Raylib's C API: LoadCodepoints

    :param bytes text: `const char *` in C raylib
    :param Sequence[int] count: `int *` in C raylib
    :return: Sequence[int] (`int *` in C raylib)
    '''
    count_ref = IntPtr(count)
    result = rlapi.LoadCodepoints(_str_in(text), count_ref)
    return result, count_ref.contents.value


def unload_codepoints(codepoints):
    '''Unload codepoints data from memory

    Raylib's C API: UnloadCodepoints

    :param Sequence[int] codepoints: `int *` in C raylib
    :return: None (`void` in C raylib)
    '''
    codepoints_ref = IntPtr(codepoints)
    rlapi.UnloadCodepoints(codepoints_ref)
    return codepoints_ref.contents.value


def get_codepoint_count(text):
    '''Get total number of codepoints in a UTF-8 encoded string

    Raylib's C API: GetCodepointCount

    :param bytes text: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetCodepointCount(_str_in(text))
    return result


def get_codepoint(text, bytes_processed):
    '''Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure

    Raylib's C API: GetCodepoint

    :param bytes text: `const char *` in C raylib
    :param Sequence[int] bytes_processed: `int *` in C raylib
    :return: int (`int` in C raylib)
    '''
    bytes_processed_ref = IntPtr(bytes_processed)
    result = rlapi.GetCodepoint(_str_in(text), bytes_processed_ref)
    return result, bytes_processed_ref.contents.value


def codepoint_to_utf8(codepoint, byte_size):
    '''Encode one codepoint into UTF-8 byte array (array length returned as parameter)

    Raylib's C API: CodepointToUTF8

    :param int codepoint: `int` in C raylib
    :param Sequence[int] byte_size: `int *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    byte_size_ref = IntPtr(byte_size)
    result = rlapi.CodepointToUTF8(int(codepoint), byte_size_ref)
    return result, byte_size_ref.contents.value


def text_codepoints_to_utf8(codepoints, length):
    '''Encode text as codepoints array into UTF-8 text string (WARNING: memory must be freed!)

    Raylib's C API: TextCodepointsToUTF8

    :param Sequence[int] codepoints: `const int *` in C raylib
    :param int length: `int` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    codepoints_ref = IntPtr(codepoints)
    result = rlapi.TextCodepointsToUTF8(codepoints_ref, int(length))
    return result, codepoints_ref.contents.value


def text_copy(dst, src):
    '''Copy one string to another, returns bytes copied

    Raylib's C API: TextCopy

    :param bytes dst: `char *` in C raylib
    :param bytes src: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.TextCopy(_str_in(dst), _str_in(src))
    return result


def text_is_equal(text1, text2):
    '''Check if two text string are equal

    Raylib's C API: TextIsEqual

    :param bytes text1: `const char *` in C raylib
    :param bytes text2: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.TextIsEqual(_str_in(text1), _str_in(text2))
    return result


def text_length(text):
    '''Get text length, checks for '\0' ending

    Raylib's C API: TextLength

    :param bytes text: `const char *` in C raylib
    :return: int (`unsigned int` in C raylib)
    '''
    result = rlapi.TextLength(_str_in(text))
    return result


def text_format(text, *args):
    '''Text formatting with variables (sprintf() style)

    Raylib's C API: TextFormat

    :param bytes text: `const char *` in C raylib
    :param bytes args: `...` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.TextFormat(_str_in(text), *args)
    return result


def text_subtext(text, position, length):
    '''Get a piece of a text string

    Raylib's C API: TextSubtext

    :param bytes text: `const char *` in C raylib
    :param int position: `int` in C raylib
    :param int length: `int` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.TextSubtext(_str_in(text), int(position), int(length))
    return result


def text_replace(text, replace, by):
    '''Replace text string (WARNING: memory must be freed!)

    Raylib's C API: TextReplace

    :param bytes text: `char *` in C raylib
    :param bytes replace: `const char *` in C raylib
    :param bytes by: `const char *` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    result = rlapi.TextReplace(_str_in(text), _str_in(replace), _str_in(by))
    return result


def text_insert(text, insert, position):
    '''Insert text in a position (WARNING: memory must be freed!)

    Raylib's C API: TextInsert

    :param bytes text: `const char *` in C raylib
    :param bytes insert: `const char *` in C raylib
    :param int position: `int` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    result = rlapi.TextInsert(_str_in(text), _str_in(insert), int(position))
    return result


def text_join(text_list, count, delimiter):
    '''Join text strings with delimiter

    Raylib's C API: TextJoin

    :param Sequence[bytes] text_list: `const char **` in C raylib
    :param int count: `int` in C raylib
    :param bytes delimiter: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.TextJoin(_str_in(text_list), int(count), _str_in(delimiter))
    return result


def text_split(text, delimiter, count):
    '''Split text into multiple strings

    Raylib's C API: TextSplit

    :param bytes text: `const char *` in C raylib
    :param int delimiter: `char` in C raylib
    :param Sequence[int] count: `int *` in C raylib
    :return: Sequence[bytes] (`const char **` in C raylib)
    '''
    count_ref = IntPtr(count)
    result = rlapi.TextSplit(_str_in(text), int(delimiter), count_ref)
    return result, count_ref.contents.value


def text_append(text, append, position):
    '''Append text at specific position and move cursor!

    Raylib's C API: TextAppend

    :param bytes text: `char *` in C raylib
    :param bytes append: `const char *` in C raylib
    :param Sequence[int] position: `int *` in C raylib
    :return: None (`void` in C raylib)
    '''
    position_ref = IntPtr(position)
    rlapi.TextAppend(_str_in(text), _str_in(append), position_ref)
    return position_ref.contents.value


def text_find_index(text, find):
    '''Find first text occurrence within a string

    Raylib's C API: TextFindIndex

    :param bytes text: `const char *` in C raylib
    :param bytes find: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.TextFindIndex(_str_in(text), _str_in(find))
    return result


def text_to_upper(text):
    '''Get upper case version of provided string

    Raylib's C API: TextToUpper

    :param bytes text: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.TextToUpper(_str_in(text))
    return result


def text_to_lower(text):
    '''Get lower case version of provided string

    Raylib's C API: TextToLower

    :param bytes text: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.TextToLower(_str_in(text))
    return result


def text_to_pascal(text):
    '''Get Pascal case notation version of provided string

    Raylib's C API: TextToPascal

    :param bytes text: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = rlapi.TextToPascal(_str_in(text))
    return result


def text_to_integer(text):
    '''Get integer value from text (negative values not supported)

    Raylib's C API: TextToInteger

    :param bytes text: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = rlapi.TextToInteger(_str_in(text))
    return result


def draw_line3d(start_pos, end_pos, color):
    '''Draw a line in 3D world space

    Raylib's C API: DrawLine3D

    :param Vector3 start_pos: `Vector3` in C raylib
    :param Vector3 end_pos: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawLine3D(start_pos, end_pos, color)


def draw_point3d(position, color):
    '''Draw a point in 3D space, actually a small line

    Raylib's C API: DrawPoint3D

    :param Vector3 position: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPoint3D(position, color)


def draw_circle3d(center, radius, rotation_axis, rotation_angle, color):
    '''Draw a circle in 3D world space

    Raylib's C API: DrawCircle3D

    :param Vector3 center: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param Vector3 rotation_axis: `Vector3` in C raylib
    :param float rotation_angle: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCircle3D(center, float(radius), rotation_axis, float(rotation_angle), color)


def draw_triangle3d(v1, v2, v3, color):
    '''Draw a color-filled triangle (vertex in counter-clockwise order!)

    Raylib's C API: DrawTriangle3D

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :param Vector3 v3: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTriangle3D(v1, v2, v3, color)


def draw_triangle_strip3d(points, point_count, color):
    '''Draw a triangle strip defined by points

    Raylib's C API: DrawTriangleStrip3D

    :param Vector3Ptr points: `Vector3 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawTriangleStrip3D(points, int(point_count), color)


def draw_cube(position, width, height, length, color):
    '''Draw cube

    Raylib's C API: DrawCube

    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCube(position, float(width), float(height), float(length), color)


def draw_cube_v(position, size, color):
    '''Draw cube (Vector version)

    Raylib's C API: DrawCubeV

    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 size: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCubeV(position, size, color)


def draw_cube_wires(position, width, height, length, color):
    '''Draw cube wires

    Raylib's C API: DrawCubeWires

    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCubeWires(position, float(width), float(height), float(length), color)


def draw_cube_wires_v(position, size, color):
    '''Draw cube wires (Vector version)

    Raylib's C API: DrawCubeWiresV

    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 size: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCubeWiresV(position, size, color)


def draw_cube_texture(texture, position, width, height, length, color):
    '''Draw cube textured

    Raylib's C API: DrawCubeTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCubeTexture(texture, position, float(width), float(height), float(length), color)


def draw_cube_texture_rec(texture, source, position, width, height, length, color):
    '''Draw cube with a region of a texture

    Raylib's C API: DrawCubeTextureRec

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCubeTextureRec(texture, source, position, float(width), float(height), float(length), color)


def draw_sphere(center_pos, radius, color):
    '''Draw sphere

    Raylib's C API: DrawSphere

    :param Vector3 center_pos: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawSphere(center_pos, float(radius), color)


def draw_sphere_ex(center_pos, radius, rings, slices, color):
    '''Draw sphere with extended parameters

    Raylib's C API: DrawSphereEx

    :param Vector3 center_pos: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawSphereEx(center_pos, float(radius), int(rings), int(slices), color)


def draw_sphere_wires(center_pos, radius, rings, slices, color):
    '''Draw sphere wires

    Raylib's C API: DrawSphereWires

    :param Vector3 center_pos: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawSphereWires(center_pos, float(radius), int(rings), int(slices), color)


def draw_cylinder(position, radius_top, radius_bottom, height, slices, color):
    '''Draw a cylinder/cone

    Raylib's C API: DrawCylinder

    :param Vector3 position: `Vector3` in C raylib
    :param float radius_top: `float` in C raylib
    :param float radius_bottom: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCylinder(position, float(radius_top), float(radius_bottom), float(height), int(slices), color)


def draw_cylinder_ex(start_pos, end_pos, start_radius, end_radius, sides, color):
    '''Draw a cylinder with base at startPos and top at endPos

    Raylib's C API: DrawCylinderEx

    :param Vector3 start_pos: `Vector3` in C raylib
    :param Vector3 end_pos: `Vector3` in C raylib
    :param float start_radius: `float` in C raylib
    :param float end_radius: `float` in C raylib
    :param int sides: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCylinderEx(start_pos, end_pos, float(start_radius), float(end_radius), int(sides), color)


def draw_cylinder_wires(position, radius_top, radius_bottom, height, slices, color):
    '''Draw a cylinder/cone wires

    Raylib's C API: DrawCylinderWires

    :param Vector3 position: `Vector3` in C raylib
    :param float radius_top: `float` in C raylib
    :param float radius_bottom: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCylinderWires(position, float(radius_top), float(radius_bottom), float(height), int(slices), color)


def draw_cylinder_wires_ex(start_pos, end_pos, start_radius, end_radius, sides, color):
    '''Draw a cylinder wires with base at startPos and top at endPos

    Raylib's C API: DrawCylinderWiresEx

    :param Vector3 start_pos: `Vector3` in C raylib
    :param Vector3 end_pos: `Vector3` in C raylib
    :param float start_radius: `float` in C raylib
    :param float end_radius: `float` in C raylib
    :param int sides: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawCylinderWiresEx(start_pos, end_pos, float(start_radius), float(end_radius), int(sides), color)


def draw_plane(center_pos, size, color):
    '''Draw a plane XZ

    Raylib's C API: DrawPlane

    :param Vector3 center_pos: `Vector3` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawPlane(center_pos, size, color)


def draw_ray(ray, color):
    '''Draw a ray line

    Raylib's C API: DrawRay

    :param Ray ray: `Ray` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawRay(ray, color)


def draw_grid(slices, spacing):
    '''Draw a grid (centered at (0, 0, 0))

    Raylib's C API: DrawGrid

    :param int slices: `int` in C raylib
    :param float spacing: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawGrid(int(slices), float(spacing))


def load_model(file_name):
    '''Load model from files (meshes and materials)

    Raylib's C API: LoadModel

    :param bytes file_name: `const char *` in C raylib
    :return: Model (`Model` in C raylib)
    '''
    result = rlapi.LoadModel(_str_in(file_name))
    return result


def load_model_from_mesh(mesh):
    '''Load model from generated mesh (default material)

    Raylib's C API: LoadModelFromMesh

    :param Mesh mesh: `Mesh` in C raylib
    :return: Model (`Model` in C raylib)
    '''
    result = rlapi.LoadModelFromMesh(mesh)
    return result


def unload_model(model):
    '''Unload model (including meshes) from memory (RAM and/or VRAM)

    Raylib's C API: UnloadModel

    :param Model model: `Model` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadModel(model)


def unload_model_keep_meshes(model):
    '''Unload model (but not meshes) from memory (RAM and/or VRAM)

    Raylib's C API: UnloadModelKeepMeshes

    :param Model model: `Model` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadModelKeepMeshes(model)


def get_model_bounding_box(model):
    '''Compute model bounding box limits (considers all meshes)

    Raylib's C API: GetModelBoundingBox

    :param Model model: `Model` in C raylib
    :return: BoundingBox (`BoundingBox` in C raylib)
    '''
    result = rlapi.GetModelBoundingBox(model)
    return result


def draw_model(model, position, scale, tint):
    '''Draw a model (with texture if set)

    Raylib's C API: DrawModel

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawModel(model, position, float(scale), tint)


def draw_model_ex(model, position, rotation_axis, rotation_angle, scale, tint):
    '''Draw a model with extended parameters

    Raylib's C API: DrawModelEx

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 rotation_axis: `Vector3` in C raylib
    :param float rotation_angle: `float` in C raylib
    :param Vector3 scale: `Vector3` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawModelEx(model, position, rotation_axis, float(rotation_angle), scale, tint)


def draw_model_wires(model, position, scale, tint):
    '''Draw a model wires (with texture if set)

    Raylib's C API: DrawModelWires

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawModelWires(model, position, float(scale), tint)


def draw_model_wires_ex(model, position, rotation_axis, rotation_angle, scale, tint):
    '''Draw a model wires (with texture if set) with extended parameters

    Raylib's C API: DrawModelWiresEx

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 rotation_axis: `Vector3` in C raylib
    :param float rotation_angle: `float` in C raylib
    :param Vector3 scale: `Vector3` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawModelWiresEx(model, position, rotation_axis, float(rotation_angle), scale, tint)


def draw_bounding_box(box, color):
    '''Draw bounding box (wires)

    Raylib's C API: DrawBoundingBox

    :param BoundingBox box: `BoundingBox` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawBoundingBox(box, color)


def draw_billboard(camera, texture, position, size, tint):
    '''Draw a billboard texture

    Raylib's C API: DrawBillboard

    :param Camera camera: `Camera` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float size: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawBillboard(camera, texture, position, float(size), tint)


def draw_billboard_rec(camera, texture, source, position, size, tint):
    '''Draw a billboard texture defined by source

    Raylib's C API: DrawBillboardRec

    :param Camera camera: `Camera` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawBillboardRec(camera, texture, source, position, size, tint)


def draw_billboard_pro(camera, texture, source, position, up, size, origin, rotation, tint):
    '''Draw a billboard texture defined by source and rotation

    Raylib's C API: DrawBillboardPro

    :param Camera camera: `Camera` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 up: `Vector3` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawBillboardPro(camera, texture, source, position, up, size, origin, float(rotation), tint)


def upload_mesh(mesh, dynamic):
    '''Upload mesh vertex data in GPU and provide VAO/VBO ids

    Raylib's C API: UploadMesh

    :param MeshPtr mesh: `Mesh *` in C raylib
    :param bool dynamic: `bool` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UploadMesh(mesh, bool(dynamic))


def update_mesh_buffer(mesh, index, data, data_size, offset):
    '''Update mesh vertex data in GPU for a specific buffer index

    Raylib's C API: UpdateMeshBuffer

    :param Mesh mesh: `Mesh` in C raylib
    :param int index: `int` in C raylib
    :param bytes data: `const void *` in C raylib
    :param int data_size: `int` in C raylib
    :param int offset: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    data_ref = VoidPtr(data)
    rlapi.UpdateMeshBuffer(mesh, int(index), data_ref, int(data_size), int(offset))
    return data_ref.contents.value


def unload_mesh(mesh):
    '''Unload mesh data from CPU and GPU

    Raylib's C API: UnloadMesh

    :param Mesh mesh: `Mesh` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadMesh(mesh)


def draw_mesh(mesh, material, transform):
    '''Draw a 3d mesh with material and transform

    Raylib's C API: DrawMesh

    :param Mesh mesh: `Mesh` in C raylib
    :param Material material: `Material` in C raylib
    :param Matrix transform: `Matrix` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawMesh(mesh, material, transform)


def draw_mesh_instanced(mesh, material, transforms, instances):
    '''Draw multiple mesh instances with material and different transforms

    Raylib's C API: DrawMeshInstanced

    :param Mesh mesh: `Mesh` in C raylib
    :param Material material: `Material` in C raylib
    :param MatrixPtr transforms: `const Matrix *` in C raylib
    :param int instances: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DrawMeshInstanced(mesh, material, transforms, int(instances))


def export_mesh(mesh, file_name):
    '''Export mesh data to file, returns true on success

    Raylib's C API: ExportMesh

    :param Mesh mesh: `Mesh` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportMesh(mesh, _str_in(file_name))
    return result


def get_mesh_bounding_box(mesh):
    '''Compute mesh bounding box limits

    Raylib's C API: GetMeshBoundingBox

    :param Mesh mesh: `Mesh` in C raylib
    :return: BoundingBox (`BoundingBox` in C raylib)
    '''
    result = rlapi.GetMeshBoundingBox(mesh)
    return result


def gen_mesh_tangents(mesh):
    '''Compute mesh tangents

    Raylib's C API: GenMeshTangents

    :param MeshPtr mesh: `Mesh *` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.GenMeshTangents(mesh)


def gen_mesh_poly(sides, radius):
    '''Generate polygonal mesh

    Raylib's C API: GenMeshPoly

    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshPoly(int(sides), float(radius))
    return result


def gen_mesh_plane(width, length, res_x, res_z):
    '''Generate plane mesh (with subdivisions)

    Raylib's C API: GenMeshPlane

    :param float width: `float` in C raylib
    :param float length: `float` in C raylib
    :param int res_x: `int` in C raylib
    :param int res_z: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshPlane(float(width), float(length), int(res_x), int(res_z))
    return result


def gen_mesh_cube(width, height, length):
    '''Generate cuboid mesh

    Raylib's C API: GenMeshCube

    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshCube(float(width), float(height), float(length))
    return result


def gen_mesh_sphere(radius, rings, slices):
    '''Generate sphere mesh (standard sphere)

    Raylib's C API: GenMeshSphere

    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshSphere(float(radius), int(rings), int(slices))
    return result


def gen_mesh_hemi_sphere(radius, rings, slices):
    '''Generate half-sphere mesh (no bottom cap)

    Raylib's C API: GenMeshHemiSphere

    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshHemiSphere(float(radius), int(rings), int(slices))
    return result


def gen_mesh_cylinder(radius, height, slices):
    '''Generate cylinder mesh

    Raylib's C API: GenMeshCylinder

    :param float radius: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshCylinder(float(radius), float(height), int(slices))
    return result


def gen_mesh_cone(radius, height, slices):
    '''Generate cone/pyramid mesh

    Raylib's C API: GenMeshCone

    :param float radius: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshCone(float(radius), float(height), int(slices))
    return result


def gen_mesh_torus(radius, size, rad_seg, sides):
    '''Generate torus mesh

    Raylib's C API: GenMeshTorus

    :param float radius: `float` in C raylib
    :param float size: `float` in C raylib
    :param int rad_seg: `int` in C raylib
    :param int sides: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshTorus(float(radius), float(size), int(rad_seg), int(sides))
    return result


def gen_mesh_knot(radius, size, rad_seg, sides):
    '''Generate trefoil knot mesh

    Raylib's C API: GenMeshKnot

    :param float radius: `float` in C raylib
    :param float size: `float` in C raylib
    :param int rad_seg: `int` in C raylib
    :param int sides: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshKnot(float(radius), float(size), int(rad_seg), int(sides))
    return result


def gen_mesh_heightmap(heightmap, size):
    '''Generate heightmap mesh from image data

    Raylib's C API: GenMeshHeightmap

    :param Image heightmap: `Image` in C raylib
    :param Vector3 size: `Vector3` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshHeightmap(heightmap, size)
    return result


def gen_mesh_cubicmap(cubicmap, cube_size):
    '''Generate cubes-based map mesh from image data

    Raylib's C API: GenMeshCubicmap

    :param Image cubicmap: `Image` in C raylib
    :param Vector3 cube_size: `Vector3` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = rlapi.GenMeshCubicmap(cubicmap, cube_size)
    return result


def load_materials(file_name, material_count):
    '''Load materials from model file

    Raylib's C API: LoadMaterials

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] material_count: `int *` in C raylib
    :return: MaterialPtr (`Material *` in C raylib)
    '''
    material_count_ref = IntPtr(material_count)
    result = rlapi.LoadMaterials(_str_in(file_name), material_count_ref)
    return result, material_count_ref.contents.value


def load_material_default():
    '''Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)

    Raylib's C API: LoadMaterialDefault

    :return: Material (`Material` in C raylib)
    '''
    result = rlapi.LoadMaterialDefault()
    return result


def unload_material(material):
    '''Unload material from GPU memory (VRAM)

    Raylib's C API: UnloadMaterial

    :param Material material: `Material` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadMaterial(material)


def set_material_texture(material, map_type, texture):
    '''Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)

    Raylib's C API: SetMaterialTexture

    :param MaterialPtr material: `Material *` in C raylib
    :param int map_type: `int` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMaterialTexture(material, int(map_type), texture)


def set_model_mesh_material(model, mesh_id, material_id):
    '''Set material for a mesh

    Raylib's C API: SetModelMeshMaterial

    :param ModelPtr model: `Model *` in C raylib
    :param int mesh_id: `int` in C raylib
    :param int material_id: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetModelMeshMaterial(model, int(mesh_id), int(material_id))


def load_model_animations(file_name, anim_count):
    '''Load model animations from file

    Raylib's C API: LoadModelAnimations

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] anim_count: `unsigned int *` in C raylib
    :return: ModelAnimationPtr (`ModelAnimation *` in C raylib)
    '''
    anim_count_ref = UIntPtr(anim_count)
    result = rlapi.LoadModelAnimations(_str_in(file_name), anim_count_ref)
    return result, anim_count_ref.contents.value


def update_model_animation(model, anim, frame):
    '''Update model animation pose

    Raylib's C API: UpdateModelAnimation

    :param Model model: `Model` in C raylib
    :param ModelAnimation anim: `ModelAnimation` in C raylib
    :param int frame: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UpdateModelAnimation(model, anim, int(frame))


def unload_model_animation(anim):
    '''Unload animation data

    Raylib's C API: UnloadModelAnimation

    :param ModelAnimation anim: `ModelAnimation` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadModelAnimation(anim)


def unload_model_animations(animations, count):
    '''Unload animation array data

    Raylib's C API: UnloadModelAnimations

    :param ModelAnimationPtr animations: `ModelAnimation *` in C raylib
    :param int count: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadModelAnimations(animations, int(count))


def is_model_animation_valid(model, anim):
    '''Check model animation skeleton match

    Raylib's C API: IsModelAnimationValid

    :param Model model: `Model` in C raylib
    :param ModelAnimation anim: `ModelAnimation` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsModelAnimationValid(model, anim)
    return result


def check_collision_spheres(center1, radius1, center2, radius2):
    '''Check collision between two spheres

    Raylib's C API: CheckCollisionSpheres

    :param Vector3 center1: `Vector3` in C raylib
    :param float radius1: `float` in C raylib
    :param Vector3 center2: `Vector3` in C raylib
    :param float radius2: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionSpheres(center1, float(radius1), center2, float(radius2))
    return result


def check_collision_boxes(box1, box2):
    '''Check collision between two bounding boxes

    Raylib's C API: CheckCollisionBoxes

    :param BoundingBox box1: `BoundingBox` in C raylib
    :param BoundingBox box2: `BoundingBox` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionBoxes(box1, box2)
    return result


def check_collision_box_sphere(box, center, radius):
    '''Check collision between box and sphere

    Raylib's C API: CheckCollisionBoxSphere

    :param BoundingBox box: `BoundingBox` in C raylib
    :param Vector3 center: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.CheckCollisionBoxSphere(box, center, float(radius))
    return result


def get_ray_collision_sphere(ray, center, radius):
    '''Get collision info between ray and sphere

    Raylib's C API: GetRayCollisionSphere

    :param Ray ray: `Ray` in C raylib
    :param Vector3 center: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = rlapi.GetRayCollisionSphere(ray, center, float(radius))
    return result


def get_ray_collision_box(ray, box):
    '''Get collision info between ray and box

    Raylib's C API: GetRayCollisionBox

    :param Ray ray: `Ray` in C raylib
    :param BoundingBox box: `BoundingBox` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = rlapi.GetRayCollisionBox(ray, box)
    return result


def get_ray_collision_mesh(ray, mesh, transform):
    '''Get collision info between ray and mesh

    Raylib's C API: GetRayCollisionMesh

    :param Ray ray: `Ray` in C raylib
    :param Mesh mesh: `Mesh` in C raylib
    :param Matrix transform: `Matrix` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = rlapi.GetRayCollisionMesh(ray, mesh, transform)
    return result


def get_ray_collision_triangle(ray, p1, p2, p3):
    '''Get collision info between ray and triangle

    Raylib's C API: GetRayCollisionTriangle

    :param Ray ray: `Ray` in C raylib
    :param Vector3 p1: `Vector3` in C raylib
    :param Vector3 p2: `Vector3` in C raylib
    :param Vector3 p3: `Vector3` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = rlapi.GetRayCollisionTriangle(ray, p1, p2, p3)
    return result


def get_ray_collision_quad(ray, p1, p2, p3, p4):
    '''Get collision info between ray and quad

    Raylib's C API: GetRayCollisionQuad

    :param Ray ray: `Ray` in C raylib
    :param Vector3 p1: `Vector3` in C raylib
    :param Vector3 p2: `Vector3` in C raylib
    :param Vector3 p3: `Vector3` in C raylib
    :param Vector3 p4: `Vector3` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = rlapi.GetRayCollisionQuad(ray, p1, p2, p3, p4)
    return result


def init_audio_device():
    '''Initialize audio device and context

    Raylib's C API: InitAudioDevice

    :return: None (`void` in C raylib)
    '''
    rlapi.InitAudioDevice()


def close_audio_device():
    '''Close the audio device and context

    Raylib's C API: CloseAudioDevice

    :return: None (`void` in C raylib)
    '''
    rlapi.CloseAudioDevice()


def is_audio_device_ready():
    '''Check if audio device has been initialized successfully

    Raylib's C API: IsAudioDeviceReady

    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsAudioDeviceReady()
    return result


def set_master_volume(volume):
    '''Set master volume (listener)

    Raylib's C API: SetMasterVolume

    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMasterVolume(float(volume))


def load_wave(file_name):
    '''Load wave data from file

    Raylib's C API: LoadWave

    :param bytes file_name: `const char *` in C raylib
    :return: Wave (`Wave` in C raylib)
    '''
    result = rlapi.LoadWave(_str_in(file_name))
    return result


def load_wave_from_memory(file_type, file_data, data_size):
    '''Load wave from memory buffer, fileType refers to extension: i.e. '.wav'

    Raylib's C API: LoadWaveFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :return: Wave (`Wave` in C raylib)
    '''
    result = rlapi.LoadWaveFromMemory(_str_in(file_type), _str_in(file_data), int(data_size))
    return result


def load_sound(file_name):
    '''Load sound from file

    Raylib's C API: LoadSound

    :param bytes file_name: `const char *` in C raylib
    :return: Sound (`Sound` in C raylib)
    '''
    result = rlapi.LoadSound(_str_in(file_name))
    return result


def load_sound_from_wave(wave):
    '''Load sound from wave data

    Raylib's C API: LoadSoundFromWave

    :param Wave wave: `Wave` in C raylib
    :return: Sound (`Sound` in C raylib)
    '''
    result = rlapi.LoadSoundFromWave(wave)
    return result


def update_sound(sound, data, sample_count):
    '''Update sound buffer with new data

    Raylib's C API: UpdateSound

    :param Sound sound: `Sound` in C raylib
    :param bytes data: `const void *` in C raylib
    :param int sample_count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    data_ref = VoidPtr(data)
    rlapi.UpdateSound(sound, data_ref, int(sample_count))
    return data_ref.contents.value


def unload_wave(wave):
    '''Unload wave data

    Raylib's C API: UnloadWave

    :param Wave wave: `Wave` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadWave(wave)


def unload_sound(sound):
    '''Unload sound

    Raylib's C API: UnloadSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadSound(sound)


def export_wave(wave, file_name):
    '''Export wave data to file, returns true on success

    Raylib's C API: ExportWave

    :param Wave wave: `Wave` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportWave(wave, _str_in(file_name))
    return result


def export_wave_as_code(wave, file_name):
    '''Export wave sample data to code (.h), returns true on success

    Raylib's C API: ExportWaveAsCode

    :param Wave wave: `Wave` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.ExportWaveAsCode(wave, _str_in(file_name))
    return result


def play_sound(sound):
    '''Play a sound

    Raylib's C API: PlaySound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PlaySound(sound)


def stop_sound(sound):
    '''Stop playing a sound

    Raylib's C API: StopSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.StopSound(sound)


def pause_sound(sound):
    '''Pause a sound

    Raylib's C API: PauseSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PauseSound(sound)


def resume_sound(sound):
    '''Resume a paused sound

    Raylib's C API: ResumeSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ResumeSound(sound)


def play_sound_multi(sound):
    '''Play a sound (using multichannel buffer pool)

    Raylib's C API: PlaySoundMulti

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PlaySoundMulti(sound)


def stop_sound_multi():
    '''Stop any sound playing (using multichannel buffer pool)

    Raylib's C API: StopSoundMulti

    :return: None (`void` in C raylib)
    '''
    rlapi.StopSoundMulti()


def get_sounds_playing():
    '''Get number of sounds playing in the multichannel

    Raylib's C API: GetSoundsPlaying

    :return: int (`int` in C raylib)
    '''
    result = rlapi.GetSoundsPlaying()
    return result


def is_sound_playing(sound):
    '''Check if a sound is currently playing

    Raylib's C API: IsSoundPlaying

    :param Sound sound: `Sound` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsSoundPlaying(sound)
    return result


def set_sound_volume(sound, volume):
    '''Set volume for a sound (1.0 is max level)

    Raylib's C API: SetSoundVolume

    :param Sound sound: `Sound` in C raylib
    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetSoundVolume(sound, float(volume))


def set_sound_pitch(sound, pitch):
    '''Set pitch for a sound (1.0 is base level)

    Raylib's C API: SetSoundPitch

    :param Sound sound: `Sound` in C raylib
    :param float pitch: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetSoundPitch(sound, float(pitch))


def set_sound_pan(sound, pan):
    '''Set pan for a sound (0.5 is center)

    Raylib's C API: SetSoundPan

    :param Sound sound: `Sound` in C raylib
    :param float pan: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetSoundPan(sound, float(pan))


def wave_copy(wave):
    '''Copy a wave to a new wave

    Raylib's C API: WaveCopy

    :param Wave wave: `Wave` in C raylib
    :return: Wave (`Wave` in C raylib)
    '''
    result = rlapi.WaveCopy(wave)
    return result


def wave_crop(wave, init_sample, final_sample):
    '''Crop a wave to defined samples range

    Raylib's C API: WaveCrop

    :param WavePtr wave: `Wave *` in C raylib
    :param int init_sample: `int` in C raylib
    :param int final_sample: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.WaveCrop(wave, int(init_sample), int(final_sample))


def wave_format(wave, sample_rate, sample_size, channels):
    '''Convert wave data to desired format

    Raylib's C API: WaveFormat

    :param WavePtr wave: `Wave *` in C raylib
    :param int sample_rate: `int` in C raylib
    :param int sample_size: `int` in C raylib
    :param int channels: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.WaveFormat(wave, int(sample_rate), int(sample_size), int(channels))


def load_wave_samples(wave):
    '''Load samples data from wave as a 32bit float data array

    Raylib's C API: LoadWaveSamples

    :param Wave wave: `Wave` in C raylib
    :return: Sequence[float] (`float *` in C raylib)
    '''
    result = rlapi.LoadWaveSamples(wave)
    return result


def unload_wave_samples(samples):
    '''Unload samples data loaded with LoadWaveSamples()

    Raylib's C API: UnloadWaveSamples

    :param Sequence[float] samples: `float *` in C raylib
    :return: None (`void` in C raylib)
    '''
    samples_ref = FloatPtr(samples)
    rlapi.UnloadWaveSamples(samples_ref)
    return samples_ref.contents.value


def load_music_stream(file_name):
    '''Load music stream from file

    Raylib's C API: LoadMusicStream

    :param bytes file_name: `const char *` in C raylib
    :return: Music (`Music` in C raylib)
    '''
    result = rlapi.LoadMusicStream(_str_in(file_name))
    return result


def load_music_stream_from_memory(file_type, data, data_size):
    '''Load music stream from data

    Raylib's C API: LoadMusicStreamFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :return: Music (`Music` in C raylib)
    '''
    result = rlapi.LoadMusicStreamFromMemory(_str_in(file_type), _str_in(data), int(data_size))
    return result


def unload_music_stream(music):
    '''Unload music stream

    Raylib's C API: UnloadMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadMusicStream(music)


def play_music_stream(music):
    '''Start music playing

    Raylib's C API: PlayMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PlayMusicStream(music)


def is_music_stream_playing(music):
    '''Check if music is playing

    Raylib's C API: IsMusicStreamPlaying

    :param Music music: `Music` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsMusicStreamPlaying(music)
    return result


def update_music_stream(music):
    '''Updates buffers for music streaming

    Raylib's C API: UpdateMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UpdateMusicStream(music)


def stop_music_stream(music):
    '''Stop music playing

    Raylib's C API: StopMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.StopMusicStream(music)


def pause_music_stream(music):
    '''Pause music playing

    Raylib's C API: PauseMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PauseMusicStream(music)


def resume_music_stream(music):
    '''Resume playing paused music

    Raylib's C API: ResumeMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ResumeMusicStream(music)


def seek_music_stream(music, position):
    '''Seek music to a position (in seconds)

    Raylib's C API: SeekMusicStream

    :param Music music: `Music` in C raylib
    :param float position: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SeekMusicStream(music, float(position))


def set_music_volume(music, volume):
    '''Set volume for music (1.0 is max level)

    Raylib's C API: SetMusicVolume

    :param Music music: `Music` in C raylib
    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMusicVolume(music, float(volume))


def set_music_pitch(music, pitch):
    '''Set pitch for a music (1.0 is base level)

    Raylib's C API: SetMusicPitch

    :param Music music: `Music` in C raylib
    :param float pitch: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMusicPitch(music, float(pitch))


def set_music_pan(music, pan):
    '''Set pan for a music (0.5 is center)

    Raylib's C API: SetMusicPan

    :param Music music: `Music` in C raylib
    :param float pan: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetMusicPan(music, float(pan))


def get_music_time_length(music):
    '''Get music time length (in seconds)

    Raylib's C API: GetMusicTimeLength

    :param Music music: `Music` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetMusicTimeLength(music)
    return result


def get_music_time_played(music):
    '''Get current music time played (in seconds)

    Raylib's C API: GetMusicTimePlayed

    :param Music music: `Music` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = rlapi.GetMusicTimePlayed(music)
    return result


def load_audio_stream(sample_rate, sample_size, channels):
    '''Load audio stream (to stream raw audio pcm data)

    Raylib's C API: LoadAudioStream

    :param int sample_rate: `unsigned int` in C raylib
    :param int sample_size: `unsigned int` in C raylib
    :param int channels: `unsigned int` in C raylib
    :return: AudioStream (`AudioStream` in C raylib)
    '''
    result = rlapi.LoadAudioStream(int(sample_rate), int(sample_size), int(channels))
    return result


def unload_audio_stream(stream):
    '''Unload audio stream and free memory

    Raylib's C API: UnloadAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.UnloadAudioStream(stream)


def update_audio_stream(stream, data, frame_count):
    '''Update audio stream buffers with data

    Raylib's C API: UpdateAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :param bytes data: `const void *` in C raylib
    :param int frame_count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    data_ref = VoidPtr(data)
    rlapi.UpdateAudioStream(stream, data_ref, int(frame_count))
    return data_ref.contents.value


def is_audio_stream_processed(stream):
    '''Check if any audio stream buffers requires refill

    Raylib's C API: IsAudioStreamProcessed

    :param AudioStream stream: `AudioStream` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsAudioStreamProcessed(stream)
    return result


def play_audio_stream(stream):
    '''Play audio stream

    Raylib's C API: PlayAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PlayAudioStream(stream)


def pause_audio_stream(stream):
    '''Pause audio stream

    Raylib's C API: PauseAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.PauseAudioStream(stream)


def resume_audio_stream(stream):
    '''Resume audio stream

    Raylib's C API: ResumeAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.ResumeAudioStream(stream)


def is_audio_stream_playing(stream):
    '''Check if audio stream is playing

    Raylib's C API: IsAudioStreamPlaying

    :param AudioStream stream: `AudioStream` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = rlapi.IsAudioStreamPlaying(stream)
    return result


def stop_audio_stream(stream):
    '''Stop audio stream

    Raylib's C API: StopAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.StopAudioStream(stream)


def set_audio_stream_volume(stream, volume):
    '''Set volume for audio stream (1.0 is max level)

    Raylib's C API: SetAudioStreamVolume

    :param AudioStream stream: `AudioStream` in C raylib
    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetAudioStreamVolume(stream, float(volume))


def set_audio_stream_pitch(stream, pitch):
    '''Set pitch for audio stream (1.0 is base level)

    Raylib's C API: SetAudioStreamPitch

    :param AudioStream stream: `AudioStream` in C raylib
    :param float pitch: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetAudioStreamPitch(stream, float(pitch))


def set_audio_stream_pan(stream, pan):
    '''Set pan for audio stream (0.5 is centered)

    Raylib's C API: SetAudioStreamPan

    :param AudioStream stream: `AudioStream` in C raylib
    :param float pan: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetAudioStreamPan(stream, float(pan))


def set_audio_stream_buffer_size_default(size):
    '''Default size for new audio streams

    Raylib's C API: SetAudioStreamBufferSizeDefault

    :param int size: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetAudioStreamBufferSizeDefault(int(size))


def set_audio_stream_callback(stream, callback):
    '''Audio thread callback to request new data

    Raylib's C API: SetAudioStreamCallback

    :param AudioStream stream: `AudioStream` in C raylib
    :param AudioCallback callback: `AudioCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.SetAudioStreamCallback(stream, callback)


def attach_audio_stream_processor(stream, processor):
    '''

    Raylib's C API: AttachAudioStreamProcessor

    :param AudioStream stream: `AudioStream` in C raylib
    :param AudioCallback processor: `AudioCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.AttachAudioStreamProcessor(stream, processor)


def detach_audio_stream_processor(stream, processor):
    '''

    Raylib's C API: DetachAudioStreamProcessor

    :param AudioStream stream: `AudioStream` in C raylib
    :param AudioCallback processor: `AudioCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    rlapi.DetachAudioStreamProcessor(stream, processor)

# endregion (api)
