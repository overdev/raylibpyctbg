
import sys
import re
import os
import platform
import ctypes
from enum import IntEnum
from ctypes import (
    CDLL, wintypes,
    c_bool, c_char, c_byte, c_short, c_long, c_ubyte, c_ushort, c_ulong, c_ulong, c_float, c_double, c_char_p, c_void_p,
    Structure, POINTER, CFUNCTYPE, byref, cast
) 


__all__ = [
    'rlapi',
    'Bool',
    'BoolPtr',
    'Byte',
    'BytePtr',
    'Char',
    'CharPtr',
    'Short',
    'ShortPtr',
    'Int',
    'IntPtr',
    'Long',
    'LongPtr',
    'UByte',
    'UBytePtr',
    'UShort',
    'UShortPtr',
    'UInt',
    'UIntPtr',
    'ULong',
    'ULongPtr',
    'Float',
    'FloatPtr',
    'Double',
    'DoublePtr',
    'VoidPtr',
    'VoidPtrPtr',
    'Vector2',
    'Vector2Ptr',
    'Vector3',
    'Vector3Ptr',
    'Quaternion',
    'QuaternionPtr',
    'Vector4',
    'Vector4Ptr',
    'Matrix',
    'MatrixPtr',
    'Color',
    'ColorPtr',
    'Rectangle',
    'RectanglePtr',
    'Image',
    'ImagePtr',
    'Texture2D',
    'Texture2DPtr',
    'TextureCubemap',
    'TextureCubemapPtr',
    'Texture',
    'TexturePtr',
    'RenderTexture2D',
    'RenderTexture2DPtr',
    'RenderTexture',
    'RenderTexturePtr',
    'NPatchInfo',
    'NPatchInfoPtr',
    'GlyphInfo',
    'GlyphInfoPtr',
    'Font',
    'FontPtr',
    'Camera',
    'CameraPtr',
    'Camera3D',
    'Camera3DPtr',
    'Camera2D',
    'Camera2DPtr',
    'Mesh',
    'MeshPtr',
    'Shader',
    'ShaderPtr',
    'MaterialMap',
    'MaterialMapPtr',
    'Material',
    'MaterialPtr',
    'Transform',
    'TransformPtr',
    'BoneInfo',
    'BoneInfoPtr',
    'Model',
    'ModelPtr',
    'ModelAnimation',
    'ModelAnimationPtr',
    'Ray',
    'RayPtr',
    'RayCollision',
    'RayCollisionPtr',
    'BoundingBox',
    'BoundingBoxPtr',
    'Wave',
    'WavePtr',
    'AudioStream',
    'AudioStreamPtr',
    'Sound',
    'SoundPtr',
    'Music',
    'MusicPtr',
    'VrDeviceInfo',
    'VrDeviceInfoPtr',
    'VrStereoConfig',
    'VrStereoConfigPtr',
    'FilePathList',
    'FilePathListPtr',
    'RAYLIB_VERSION',
    'PI',
    'DEG2RAD',
    'RAD2DEG',
    'LIGHTGRAY',
    'GRAY',
    'DARKGRAY',
    'YELLOW',
    'GOLD',
    'ORANGE',
    'PINK',
    'RED',
    'MAROON',
    'GREEN',
    'LIME',
    'DARKGREEN',
    'SKYBLUE',
    'BLUE',
    'DARKBLUE',
    'PURPLE',
    'VIOLET',
    'DARKPURPLE',
    'BEIGE',
    'BROWN',
    'DARKBROWN',
    'WHITE',
    'BLACK',
    'BLANK',
    'MAGENTA',
    'RAYWHITE',
    'ConfigFlags',
    'FLAG_VSYNC_HINT',
    'FLAG_FULLSCREEN_MODE',
    'FLAG_WINDOW_RESIZABLE',
    'FLAG_WINDOW_UNDECORATED',
    'FLAG_WINDOW_HIDDEN',
    'FLAG_WINDOW_MINIMIZED',
    'FLAG_WINDOW_MAXIMIZED',
    'FLAG_WINDOW_UNFOCUSED',
    'FLAG_WINDOW_TOPMOST',
    'FLAG_WINDOW_ALWAYS_RUN',
    'FLAG_WINDOW_TRANSPARENT',
    'FLAG_WINDOW_HIGHDPI',
    'FLAG_WINDOW_MOUSE_PASSTHROUGH',
    'FLAG_MSAA_4X_HINT',
    'FLAG_INTERLACED_HINT',
    'TraceLogLevel',
    'LOG_ALL',
    'LOG_TRACE',
    'LOG_DEBUG',
    'LOG_INFO',
    'LOG_WARNING',
    'LOG_ERROR',
    'LOG_FATAL',
    'LOG_NONE',
    'KeyboardKey',
    'KEY_NULL',
    'KEY_APOSTROPHE',
    'KEY_COMMA',
    'KEY_MINUS',
    'KEY_PERIOD',
    'KEY_SLASH',
    'KEY_ZERO',
    'KEY_ONE',
    'KEY_TWO',
    'KEY_THREE',
    'KEY_FOUR',
    'KEY_FIVE',
    'KEY_SIX',
    'KEY_SEVEN',
    'KEY_EIGHT',
    'KEY_NINE',
    'KEY_SEMICOLON',
    'KEY_EQUAL',
    'KEY_A',
    'KEY_B',
    'KEY_C',
    'KEY_D',
    'KEY_E',
    'KEY_F',
    'KEY_G',
    'KEY_H',
    'KEY_I',
    'KEY_J',
    'KEY_K',
    'KEY_L',
    'KEY_M',
    'KEY_N',
    'KEY_O',
    'KEY_P',
    'KEY_Q',
    'KEY_R',
    'KEY_S',
    'KEY_T',
    'KEY_U',
    'KEY_V',
    'KEY_W',
    'KEY_X',
    'KEY_Y',
    'KEY_Z',
    'KEY_LEFT_BRACKET',
    'KEY_BACKSLASH',
    'KEY_RIGHT_BRACKET',
    'KEY_GRAVE',
    'KEY_SPACE',
    'KEY_ESCAPE',
    'KEY_ENTER',
    'KEY_TAB',
    'KEY_BACKSPACE',
    'KEY_INSERT',
    'KEY_DELETE',
    'KEY_RIGHT',
    'KEY_LEFT',
    'KEY_DOWN',
    'KEY_UP',
    'KEY_PAGE_UP',
    'KEY_PAGE_DOWN',
    'KEY_HOME',
    'KEY_END',
    'KEY_CAPS_LOCK',
    'KEY_SCROLL_LOCK',
    'KEY_NUM_LOCK',
    'KEY_PRINT_SCREEN',
    'KEY_PAUSE',
    'KEY_F1',
    'KEY_F2',
    'KEY_F3',
    'KEY_F4',
    'KEY_F5',
    'KEY_F6',
    'KEY_F7',
    'KEY_F8',
    'KEY_F9',
    'KEY_F10',
    'KEY_F11',
    'KEY_F12',
    'KEY_LEFT_SHIFT',
    'KEY_LEFT_CONTROL',
    'KEY_LEFT_ALT',
    'KEY_LEFT_SUPER',
    'KEY_RIGHT_SHIFT',
    'KEY_RIGHT_CONTROL',
    'KEY_RIGHT_ALT',
    'KEY_RIGHT_SUPER',
    'KEY_KB_MENU',
    'KEY_KP_0',
    'KEY_KP_1',
    'KEY_KP_2',
    'KEY_KP_3',
    'KEY_KP_4',
    'KEY_KP_5',
    'KEY_KP_6',
    'KEY_KP_7',
    'KEY_KP_8',
    'KEY_KP_9',
    'KEY_KP_DECIMAL',
    'KEY_KP_DIVIDE',
    'KEY_KP_MULTIPLY',
    'KEY_KP_SUBTRACT',
    'KEY_KP_ADD',
    'KEY_KP_ENTER',
    'KEY_KP_EQUAL',
    'KEY_BACK',
    'KEY_MENU',
    'KEY_VOLUME_UP',
    'KEY_VOLUME_DOWN',
    'MouseButton',
    'MOUSE_BUTTON_LEFT',
    'MOUSE_BUTTON_RIGHT',
    'MOUSE_BUTTON_MIDDLE',
    'MOUSE_BUTTON_SIDE',
    'MOUSE_BUTTON_EXTRA',
    'MOUSE_BUTTON_FORWARD',
    'MOUSE_BUTTON_BACK',
    'MouseCursor',
    'MOUSE_CURSOR_DEFAULT',
    'MOUSE_CURSOR_ARROW',
    'MOUSE_CURSOR_IBEAM',
    'MOUSE_CURSOR_CROSSHAIR',
    'MOUSE_CURSOR_POINTING_HAND',
    'MOUSE_CURSOR_RESIZE_EW',
    'MOUSE_CURSOR_RESIZE_NS',
    'MOUSE_CURSOR_RESIZE_NWSE',
    'MOUSE_CURSOR_RESIZE_NESW',
    'MOUSE_CURSOR_RESIZE_ALL',
    'MOUSE_CURSOR_NOT_ALLOWED',
    'GamepadButton',
    'GAMEPAD_BUTTON_UNKNOWN',
    'GAMEPAD_BUTTON_LEFT_FACE_UP',
    'GAMEPAD_BUTTON_LEFT_FACE_RIGHT',
    'GAMEPAD_BUTTON_LEFT_FACE_DOWN',
    'GAMEPAD_BUTTON_LEFT_FACE_LEFT',
    'GAMEPAD_BUTTON_RIGHT_FACE_UP',
    'GAMEPAD_BUTTON_RIGHT_FACE_RIGHT',
    'GAMEPAD_BUTTON_RIGHT_FACE_DOWN',
    'GAMEPAD_BUTTON_RIGHT_FACE_LEFT',
    'GAMEPAD_BUTTON_LEFT_TRIGGER_1',
    'GAMEPAD_BUTTON_LEFT_TRIGGER_2',
    'GAMEPAD_BUTTON_RIGHT_TRIGGER_1',
    'GAMEPAD_BUTTON_RIGHT_TRIGGER_2',
    'GAMEPAD_BUTTON_MIDDLE_LEFT',
    'GAMEPAD_BUTTON_MIDDLE',
    'GAMEPAD_BUTTON_MIDDLE_RIGHT',
    'GAMEPAD_BUTTON_LEFT_THUMB',
    'GAMEPAD_BUTTON_RIGHT_THUMB',
    'GamepadAxis',
    'GAMEPAD_AXIS_LEFT_X',
    'GAMEPAD_AXIS_LEFT_Y',
    'GAMEPAD_AXIS_RIGHT_X',
    'GAMEPAD_AXIS_RIGHT_Y',
    'GAMEPAD_AXIS_LEFT_TRIGGER',
    'GAMEPAD_AXIS_RIGHT_TRIGGER',
    'MaterialMapIndex',
    'MATERIAL_MAP_ALBEDO',
    'MATERIAL_MAP_METALNESS',
    'MATERIAL_MAP_NORMAL',
    'MATERIAL_MAP_ROUGHNESS',
    'MATERIAL_MAP_OCCLUSION',
    'MATERIAL_MAP_EMISSION',
    'MATERIAL_MAP_HEIGHT',
    'MATERIAL_MAP_CUBEMAP',
    'MATERIAL_MAP_IRRADIANCE',
    'MATERIAL_MAP_PREFILTER',
    'MATERIAL_MAP_BRDF',
    'ShaderLocationIndex',
    'SHADER_LOC_VERTEX_POSITION',
    'SHADER_LOC_VERTEX_TEXCOORD01',
    'SHADER_LOC_VERTEX_TEXCOORD02',
    'SHADER_LOC_VERTEX_NORMAL',
    'SHADER_LOC_VERTEX_TANGENT',
    'SHADER_LOC_VERTEX_COLOR',
    'SHADER_LOC_MATRIX_MVP',
    'SHADER_LOC_MATRIX_VIEW',
    'SHADER_LOC_MATRIX_PROJECTION',
    'SHADER_LOC_MATRIX_MODEL',
    'SHADER_LOC_MATRIX_NORMAL',
    'SHADER_LOC_VECTOR_VIEW',
    'SHADER_LOC_COLOR_DIFFUSE',
    'SHADER_LOC_COLOR_SPECULAR',
    'SHADER_LOC_COLOR_AMBIENT',
    'SHADER_LOC_MAP_ALBEDO',
    'SHADER_LOC_MAP_METALNESS',
    'SHADER_LOC_MAP_NORMAL',
    'SHADER_LOC_MAP_ROUGHNESS',
    'SHADER_LOC_MAP_OCCLUSION',
    'SHADER_LOC_MAP_EMISSION',
    'SHADER_LOC_MAP_HEIGHT',
    'SHADER_LOC_MAP_CUBEMAP',
    'SHADER_LOC_MAP_IRRADIANCE',
    'SHADER_LOC_MAP_PREFILTER',
    'SHADER_LOC_MAP_BRDF',
    'ShaderUniformDataType',
    'SHADER_UNIFORM_FLOAT',
    'SHADER_UNIFORM_VEC2',
    'SHADER_UNIFORM_VEC3',
    'SHADER_UNIFORM_VEC4',
    'SHADER_UNIFORM_INT',
    'SHADER_UNIFORM_IVEC2',
    'SHADER_UNIFORM_IVEC3',
    'SHADER_UNIFORM_IVEC4',
    'SHADER_UNIFORM_SAMPLER2D',
    'ShaderAttributeDataType',
    'SHADER_ATTRIB_FLOAT',
    'SHADER_ATTRIB_VEC2',
    'SHADER_ATTRIB_VEC3',
    'SHADER_ATTRIB_VEC4',
    'PixelFormat',
    'PIXELFORMAT_UNCOMPRESSED_GRAYSCALE',
    'PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA',
    'PIXELFORMAT_UNCOMPRESSED_R5G6B5',
    'PIXELFORMAT_UNCOMPRESSED_R8G8B8',
    'PIXELFORMAT_UNCOMPRESSED_R5G5B5A1',
    'PIXELFORMAT_UNCOMPRESSED_R4G4B4A4',
    'PIXELFORMAT_UNCOMPRESSED_R8G8B8A8',
    'PIXELFORMAT_UNCOMPRESSED_R32',
    'PIXELFORMAT_UNCOMPRESSED_R32G32B32',
    'PIXELFORMAT_UNCOMPRESSED_R32G32B32A32',
    'PIXELFORMAT_COMPRESSED_DXT1_RGB',
    'PIXELFORMAT_COMPRESSED_DXT1_RGBA',
    'PIXELFORMAT_COMPRESSED_DXT3_RGBA',
    'PIXELFORMAT_COMPRESSED_DXT5_RGBA',
    'PIXELFORMAT_COMPRESSED_ETC1_RGB',
    'PIXELFORMAT_COMPRESSED_ETC2_RGB',
    'PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA',
    'PIXELFORMAT_COMPRESSED_PVRT_RGB',
    'PIXELFORMAT_COMPRESSED_PVRT_RGBA',
    'PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA',
    'PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA',
    'TextureFilter',
    'TEXTURE_FILTER_POINT',
    'TEXTURE_FILTER_BILINEAR',
    'TEXTURE_FILTER_TRILINEAR',
    'TEXTURE_FILTER_ANISOTROPIC_4X',
    'TEXTURE_FILTER_ANISOTROPIC_8X',
    'TEXTURE_FILTER_ANISOTROPIC_16X',
    'TextureWrap',
    'TEXTURE_WRAP_REPEAT',
    'TEXTURE_WRAP_CLAMP',
    'TEXTURE_WRAP_MIRROR_REPEAT',
    'TEXTURE_WRAP_MIRROR_CLAMP',
    'CubemapLayout',
    'CUBEMAP_LAYOUT_AUTO_DETECT',
    'CUBEMAP_LAYOUT_LINE_VERTICAL',
    'CUBEMAP_LAYOUT_LINE_HORIZONTAL',
    'CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR',
    'CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE',
    'CUBEMAP_LAYOUT_PANORAMA',
    'FontType',
    'FONT_DEFAULT',
    'FONT_BITMAP',
    'FONT_SDF',
    'BlendMode',
    'BLEND_ALPHA',
    'BLEND_ADDITIVE',
    'BLEND_MULTIPLIED',
    'BLEND_ADD_COLORS',
    'BLEND_SUBTRACT_COLORS',
    'BLEND_ALPHA_PREMULTIPLY',
    'BLEND_CUSTOM',
    'Gesture',
    'GESTURE_NONE',
    'GESTURE_TAP',
    'GESTURE_DOUBLETAP',
    'GESTURE_HOLD',
    'GESTURE_DRAG',
    'GESTURE_SWIPE_RIGHT',
    'GESTURE_SWIPE_LEFT',
    'GESTURE_SWIPE_UP',
    'GESTURE_SWIPE_DOWN',
    'GESTURE_PINCH_IN',
    'GESTURE_PINCH_OUT',
    'CameraMode',
    'CAMERA_CUSTOM',
    'CAMERA_FREE',
    'CAMERA_ORBITAL',
    'CAMERA_FIRST_PERSON',
    'CAMERA_THIRD_PERSON',
    'CameraProjection',
    'CAMERA_PERSPECTIVE',
    'CAMERA_ORTHOGRAPHIC',
    'NPatchLayout',
    'NPATCH_NINE_PATCH',
    'NPATCH_THREE_PATCH_VERTICAL',
    'NPATCH_THREE_PATCH_HORIZONTAL',
    'TraceLogCallback',
    'LoadFileDataCallback',
    'SaveFileDataCallback',
    'LoadFileTextCallback',
    'SaveFileTextCallback',
    'AudioCallback',
    'init_window',
    'window_should_close',
    'close_window',
    'is_window_ready',
    'is_window_fullscreen',
    'is_window_hidden',
    'is_window_minimized',
    'is_window_maximized',
    'is_window_focused',
    'is_window_resized',
    'is_window_state',
    'set_window_state',
    'clear_window_state',
    'toggle_fullscreen',
    'maximize_window',
    'minimize_window',
    'restore_window',
    'set_window_icon',
    'set_window_title',
    'set_window_position',
    'set_window_monitor',
    'set_window_min_size',
    'set_window_size',
    'set_window_opacity',
    'get_window_handle',
    'get_screen_width',
    'get_screen_height',
    'get_render_width',
    'get_render_height',
    'get_monitor_count',
    'get_current_monitor',
    'get_monitor_position',
    'get_monitor_width',
    'get_monitor_height',
    'get_monitor_physical_width',
    'get_monitor_physical_height',
    'get_monitor_refresh_rate',
    'get_window_position',
    'get_window_scale_dpi',
    'get_monitor_name',
    'set_clipboard_text',
    'get_clipboard_text',
    'enable_event_waiting',
    'disable_event_waiting',
    'swap_screen_buffer',
    'poll_input_events',
    'wait_time',
    'show_cursor',
    'hide_cursor',
    'is_cursor_hidden',
    'enable_cursor',
    'disable_cursor',
    'is_cursor_on_screen',
    'clear_background',
    'begin_drawing',
    'end_drawing',
    'begin_mode2d',
    'end_mode2d',
    'begin_mode3d',
    'end_mode3d',
    'begin_texture_mode',
    'end_texture_mode',
    'begin_shader_mode',
    'end_shader_mode',
    'begin_blend_mode',
    'end_blend_mode',
    'begin_scissor_mode',
    'end_scissor_mode',
    'begin_vr_stereo_mode',
    'end_vr_stereo_mode',
    'load_vr_stereo_config',
    'unload_vr_stereo_config',
    'load_shader',
    'load_shader_from_memory',
    'get_shader_location',
    'get_shader_location_attrib',
    'set_shader_value',
    'set_shader_value_v',
    'set_shader_value_matrix',
    'set_shader_value_texture',
    'unload_shader',
    'get_mouse_ray',
    'get_camera_matrix',
    'get_camera_matrix2d',
    'get_world_to_screen',
    'get_screen_to_world2d',
    'get_world_to_screen_ex',
    'get_world_to_screen2d',
    'set_target_fps',
    'get_fps',
    'get_frame_time',
    'get_time',
    'get_random_value',
    'set_random_seed',
    'take_screenshot',
    'set_config_flags',
    'trace_log',
    'set_trace_log_level',
    'mem_alloc',
    'mem_realloc',
    'mem_free',
    'open_url',
    'set_trace_log_callback',
    'set_load_file_data_callback',
    'set_save_file_data_callback',
    'set_load_file_text_callback',
    'set_save_file_text_callback',
    'load_file_data',
    'unload_file_data',
    'save_file_data',
    'export_data_as_code',
    'load_file_text',
    'unload_file_text',
    'save_file_text',
    'file_exists',
    'directory_exists',
    'is_file_extension',
    'get_file_length',
    'get_file_extension',
    'get_file_name',
    'get_file_name_without_ext',
    'get_directory_path',
    'get_prev_directory_path',
    'get_working_directory',
    'get_application_directory',
    'change_directory',
    'is_path_file',
    'load_directory_files',
    'load_directory_files_ex',
    'unload_directory_files',
    'is_file_dropped',
    'load_dropped_files',
    'unload_dropped_files',
    'get_file_mod_time',
    'compress_data',
    'decompress_data',
    'encode_data_base64',
    'decode_data_base64',
    'is_key_pressed',
    'is_key_down',
    'is_key_released',
    'is_key_up',
    'set_exit_key',
    'get_key_pressed',
    'get_char_pressed',
    'is_gamepad_available',
    'get_gamepad_name',
    'is_gamepad_button_pressed',
    'is_gamepad_button_down',
    'is_gamepad_button_released',
    'is_gamepad_button_up',
    'get_gamepad_button_pressed',
    'get_gamepad_axis_count',
    'get_gamepad_axis_movement',
    'set_gamepad_mappings',
    'is_mouse_button_pressed',
    'is_mouse_button_down',
    'is_mouse_button_released',
    'is_mouse_button_up',
    'get_mouse_x',
    'get_mouse_y',
    'get_mouse_position',
    'get_mouse_delta',
    'set_mouse_position',
    'set_mouse_offset',
    'set_mouse_scale',
    'get_mouse_wheel_move',
    'get_mouse_wheel_move_v',
    'set_mouse_cursor',
    'get_touch_x',
    'get_touch_y',
    'get_touch_position',
    'get_touch_point_id',
    'get_touch_point_count',
    'set_gestures_enabled',
    'is_gesture_detected',
    'get_gesture_detected',
    'get_gesture_hold_duration',
    'get_gesture_drag_vector',
    'get_gesture_drag_angle',
    'get_gesture_pinch_vector',
    'get_gesture_pinch_angle',
    'set_camera_mode',
    'update_camera',
    'set_camera_pan_control',
    'set_camera_alt_control',
    'set_camera_smooth_zoom_control',
    'set_camera_move_controls',
    'set_shapes_texture',
    'draw_pixel',
    'draw_pixel_v',
    'draw_line',
    'draw_line_v',
    'draw_line_ex',
    'draw_line_bezier',
    'draw_line_bezier_quad',
    'draw_line_bezier_cubic',
    'draw_line_strip',
    'draw_circle',
    'draw_circle_sector',
    'draw_circle_sector_lines',
    'draw_circle_gradient',
    'draw_circle_v',
    'draw_circle_lines',
    'draw_ellipse',
    'draw_ellipse_lines',
    'draw_ring',
    'draw_ring_lines',
    'draw_rectangle',
    'draw_rectangle_v',
    'draw_rectangle_rec',
    'draw_rectangle_pro',
    'draw_rectangle_gradient_v',
    'draw_rectangle_gradient_h',
    'draw_rectangle_gradient_ex',
    'draw_rectangle_lines',
    'draw_rectangle_lines_ex',
    'draw_rectangle_rounded',
    'draw_rectangle_rounded_lines',
    'draw_triangle',
    'draw_triangle_lines',
    'draw_triangle_fan',
    'draw_triangle_strip',
    'draw_poly',
    'draw_poly_lines',
    'draw_poly_lines_ex',
    'check_collision_recs',
    'check_collision_circles',
    'check_collision_circle_rec',
    'check_collision_point_rec',
    'check_collision_point_circle',
    'check_collision_point_triangle',
    'check_collision_lines',
    'check_collision_point_line',
    'get_collision_rec',
    'load_image',
    'load_image_raw',
    'load_image_anim',
    'load_image_from_memory',
    'load_image_from_texture',
    'load_image_from_screen',
    'unload_image',
    'export_image',
    'export_image_as_code',
    'gen_image_color',
    'gen_image_gradient_v',
    'gen_image_gradient_h',
    'gen_image_gradient_radial',
    'gen_image_checked',
    'gen_image_white_noise',
    'gen_image_cellular',
    'image_copy',
    'image_from_image',
    'image_text',
    'image_text_ex',
    'image_format',
    'image_to_pot',
    'image_crop',
    'image_alpha_crop',
    'image_alpha_clear',
    'image_alpha_mask',
    'image_alpha_premultiply',
    'image_resize',
    'image_resize_nn',
    'image_resize_canvas',
    'image_mipmaps',
    'image_dither',
    'image_flip_vertical',
    'image_flip_horizontal',
    'image_rotate_cw',
    'image_rotate_ccw',
    'image_color_tint',
    'image_color_invert',
    'image_color_grayscale',
    'image_color_contrast',
    'image_color_brightness',
    'image_color_replace',
    'load_image_colors',
    'load_image_palette',
    'unload_image_colors',
    'unload_image_palette',
    'get_image_alpha_border',
    'get_image_color',
    'image_clear_background',
    'image_draw_pixel',
    'image_draw_pixel_v',
    'image_draw_line',
    'image_draw_line_v',
    'image_draw_circle',
    'image_draw_circle_v',
    'image_draw_rectangle',
    'image_draw_rectangle_v',
    'image_draw_rectangle_rec',
    'image_draw_rectangle_lines',
    'image_draw',
    'image_draw_text',
    'image_draw_text_ex',
    'load_texture',
    'load_texture_from_image',
    'load_texture_cubemap',
    'load_render_texture',
    'unload_texture',
    'unload_render_texture',
    'update_texture',
    'update_texture_rec',
    'gen_texture_mipmaps',
    'set_texture_filter',
    'set_texture_wrap',
    'draw_texture',
    'draw_texture_v',
    'draw_texture_ex',
    'draw_texture_rec',
    'draw_texture_quad',
    'draw_texture_tiled',
    'draw_texture_pro',
    'draw_texture_npatch',
    'draw_texture_poly',
    'fade',
    'color_to_int',
    'color_normalize',
    'color_from_normalized',
    'color_to_hsv',
    'color_from_hsv',
    'color_alpha',
    'color_alpha_blend',
    'get_color',
    'get_pixel_color',
    'set_pixel_color',
    'get_pixel_data_size',
    'get_font_default',
    'load_font',
    'load_font_ex',
    'load_font_from_image',
    'load_font_from_memory',
    'load_font_data',
    'gen_image_font_atlas',
    'unload_font_data',
    'unload_font',
    'export_font_as_code',
    'draw_fps',
    'draw_text',
    'draw_text_ex',
    'draw_text_pro',
    'draw_text_codepoint',
    'draw_text_codepoints',
    'measure_text',
    'measure_text_ex',
    'get_glyph_index',
    'get_glyph_info',
    'get_glyph_atlas_rec',
    'load_codepoints',
    'unload_codepoints',
    'get_codepoint_count',
    'get_codepoint',
    'codepoint_to_utf8',
    'text_codepoints_to_utf8',
    'text_copy',
    'text_is_equal',
    'text_length',
    'text_format',
    'text_subtext',
    'text_replace',
    'text_insert',
    'text_join',
    'text_split',
    'text_append',
    'text_find_index',
    'text_to_upper',
    'text_to_lower',
    'text_to_pascal',
    'text_to_integer',
    'draw_line3d',
    'draw_point3d',
    'draw_circle3d',
    'draw_triangle3d',
    'draw_triangle_strip3d',
    'draw_cube',
    'draw_cube_v',
    'draw_cube_wires',
    'draw_cube_wires_v',
    'draw_cube_texture',
    'draw_cube_texture_rec',
    'draw_sphere',
    'draw_sphere_ex',
    'draw_sphere_wires',
    'draw_cylinder',
    'draw_cylinder_ex',
    'draw_cylinder_wires',
    'draw_cylinder_wires_ex',
    'draw_plane',
    'draw_ray',
    'draw_grid',
    'load_model',
    'load_model_from_mesh',
    'unload_model',
    'unload_model_keep_meshes',
    'get_model_bounding_box',
    'draw_model',
    'draw_model_ex',
    'draw_model_wires',
    'draw_model_wires_ex',
    'draw_bounding_box',
    'draw_billboard',
    'draw_billboard_rec',
    'draw_billboard_pro',
    'upload_mesh',
    'update_mesh_buffer',
    'unload_mesh',
    'draw_mesh',
    'draw_mesh_instanced',
    'export_mesh',
    'get_mesh_bounding_box',
    'gen_mesh_tangents',
    'gen_mesh_poly',
    'gen_mesh_plane',
    'gen_mesh_cube',
    'gen_mesh_sphere',
    'gen_mesh_hemi_sphere',
    'gen_mesh_cylinder',
    'gen_mesh_cone',
    'gen_mesh_torus',
    'gen_mesh_knot',
    'gen_mesh_heightmap',
    'gen_mesh_cubicmap',
    'load_materials',
    'load_material_default',
    'unload_material',
    'set_material_texture',
    'set_model_mesh_material',
    'load_model_animations',
    'update_model_animation',
    'unload_model_animation',
    'unload_model_animations',
    'is_model_animation_valid',
    'check_collision_spheres',
    'check_collision_boxes',
    'check_collision_box_sphere',
    'get_ray_collision_sphere',
    'get_ray_collision_box',
    'get_ray_collision_mesh',
    'get_ray_collision_triangle',
    'get_ray_collision_quad',
    'init_audio_device',
    'close_audio_device',
    'is_audio_device_ready',
    'set_master_volume',
    'load_wave',
    'load_wave_from_memory',
    'load_sound',
    'load_sound_from_wave',
    'update_sound',
    'unload_wave',
    'unload_sound',
    'export_wave',
    'export_wave_as_code',
    'play_sound',
    'stop_sound',
    'pause_sound',
    'resume_sound',
    'play_sound_multi',
    'stop_sound_multi',
    'get_sounds_playing',
    'is_sound_playing',
    'set_sound_volume',
    'set_sound_pitch',
    'set_sound_pan',
    'wave_copy',
    'wave_crop',
    'wave_format',
    'load_wave_samples',
    'unload_wave_samples',
    'load_music_stream',
    'load_music_stream_from_memory',
    'unload_music_stream',
    'play_music_stream',
    'is_music_stream_playing',
    'update_music_stream',
    'stop_music_stream',
    'pause_music_stream',
    'resume_music_stream',
    'seek_music_stream',
    'set_music_volume',
    'set_music_pitch',
    'set_music_pan',
    'get_music_time_length',
    'get_music_time_played',
    'load_audio_stream',
    'unload_audio_stream',
    'update_audio_stream',
    'is_audio_stream_processed',
    'play_audio_stream',
    'pause_audio_stream',
    'resume_audio_stream',
    'is_audio_stream_playing',
    'stop_audio_stream',
    'set_audio_stream_volume',
    'set_audio_stream_pitch',
    'set_audio_stream_pan',
    'set_audio_stream_buffer_size_default',
    'set_audio_stream_callback',
    'attach_audio_stream_processor',
    'detach_audio_stream_processor',
    'clamp',
    'lerp',
    'normalize',
    'remap',
    'wrap',
    'float_equals',
    'vector2zero',
    'vector2one',
    'vector2add',
    'vector2add_value',
    'vector2subtract',
    'vector2subtract_value',
    'vector2length',
    'vector2length_sqr',
    'vector2dot_product',
    'vector2distance',
    'vector2distance_sqr',
    'vector2angle',
    'vector2scale',
    'vector2multiply',
    'vector2negate',
    'vector2divide',
    'vector2normalize',
    'vector2transform',
    'vector2lerp',
    'vector2reflect',
    'vector2rotate',
    'vector2move_towards',
    'vector2invert',
    'vector2clamp',
    'vector2clamp_value',
    'vector2equals',
    'vector3zero',
    'vector3one',
    'vector3add',
    'vector3add_value',
    'vector3subtract',
    'vector3subtract_value',
    'vector3scale',
    'vector3multiply',
    'vector3cross_product',
    'vector3perpendicular',
    'vector3length',
    'vector3length_sqr',
    'vector3dot_product',
    'vector3distance',
    'vector3distance_sqr',
    'vector3angle',
    'vector3negate',
    'vector3divide',
    'vector3normalize',
    'vector3ortho_normalize',
    'vector3transform',
    'vector3rotate_by_quaternion',
    'vector3rotate_by_axis_angle',
    'vector3lerp',
    'vector3reflect',
    'vector3min',
    'vector3max',
    'vector3barycenter',
    'vector3unproject',
    'vector3to_float_v',
    'vector3invert',
    'vector3clamp',
    'vector3clamp_value',
    'vector3equals',
    'vector3refract',
    'matrix_determinant',
    'matrix_trace',
    'matrix_transpose',
    'matrix_invert',
    'matrix_identity',
    'matrix_add',
    'matrix_subtract',
    'matrix_multiply',
    'matrix_translate',
    'matrix_rotate',
    'matrix_rotate_x',
    'matrix_rotate_y',
    'matrix_rotate_z',
    'matrix_rotate_xyz',
    'matrix_rotate_zyx',
    'matrix_scale',
    'matrix_frustum',
    'matrix_perspective',
    'matrix_ortho',
    'matrix_look_at',
    'matrix_to_float_v',
    'quaternion_add',
    'quaternion_add_value',
    'quaternion_subtract',
    'quaternion_subtract_value',
    'quaternion_identity',
    'quaternion_length',
    'quaternion_normalize',
    'quaternion_invert',
    'quaternion_multiply',
    'quaternion_scale',
    'quaternion_divide',
    'quaternion_nlerp',
    'quaternion_slerp',
    'quaternion_from_vector3to_vector3',
    'quaternion_to_matrix',
    'quaternion_from_matrix',
    'quaternion_from_axis_angle',
    'quaternion_to_axis_angle',
    'quaternion_from_euler',
    'quaternion_to_euler',
    'quaternion_transform',
    'quaternion_equals',
]

# region LIBRARY LOADING

# region CDLLEX

DONT_RESOLVE_DLL_REFERENCES = 0x00000001
LOAD_LIBRARY_AS_DATAFILE = 0x00000002
LOAD_WITH_ALTERED_SEARCH_PATH = 0x00000008
LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010  # NT 6.1
LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020  # NT 6.0
LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040  # NT 6.0

# These cannot be combined with LOAD_WITH_ALTERED_SEARCH_PATH.
# Install update KB2533623 for NT 6.0 & 6.1.
LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000

kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)


def check_bool(result, func, args):
    if not result:
        raise ctypes.WinError(ctypes.get_last_error())
    return args


kernel32.LoadLibraryExW.errcheck = check_bool
kernel32.LoadLibraryExW.restype = wintypes.HMODULE
kernel32.LoadLibraryExW.argtypes = (wintypes.LPCWSTR,
                                    wintypes.HANDLE,
                                    wintypes.DWORD)


class CDLLEx(ctypes.CDLL):
    def __init__(self, name, mode=0, handle=None,
                 use_errno=True, use_last_error=False):
        if handle is None:
            handle = kernel32.LoadLibraryExW(name, None, mode)
        super(CDLLEx, self).__init__(name, mode, handle,
                                     use_errno, use_last_error)


class WinDLLEx(ctypes.WinDLL):
    def __init__(self, name, mode=0, handle=None,
                 use_errno=False, use_last_error=True):
        if handle is None:
            handle = kernel32.LoadLibraryExW(name, None, mode)
        super(WinDLLEx, self).__init__(name, mode, handle,
                                       use_errno, use_last_error)


# endregion (cdllex)


_lib_fname = {
    'win32': 'raylib.dll',
    'linux': 'libraylib.so.3.7.0',
    'darwin': 'libraylib.3.7.0.dylib'
}

_lib_platform = sys.platform

if _lib_platform == 'win32':
    _bitness = platform.architecture()[0]
else:
    _bitness = '64bit' if sys.maxsize > 2 ** 32 else '32bit'

_lib_fname_abspath = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin', _bitness, _lib_fname[_lib_platform])
_lib_fname_abspath = os.path.normcase(os.path.normpath(_lib_fname_abspath))

print(
    """Library loading info:
    platform: {}
    bitness: {}
    absolute path: {}
    exists: {}
    is file: {}
    """.format(
        _lib_platform,
        _bitness,
        _lib_fname_abspath,
        'yes' if os.path.exists(_lib_fname_abspath) else 'no',
        'yes' if os.path.isfile(_lib_fname_abspath) else 'no'
    )
)

rlapi = None
if _lib_platform == 'win32':

    try:
        rlapi = CDLLEx(_lib_fname_abspath, LOAD_WITH_ALTERED_SEARCH_PATH)
    except OSError:
        print("Unable to load {}.".format(_lib_fname[_lib_platform]))
        rlapi = None
else:
    rlapi = CDLL(_lib_fname_abspath)

if rlapi is None:
    print("Failed to load shared library.")
    exit()
else:
    print("Shared library loaded succesfully.", rlapi)

# Vector component swizzling helppers
_VEC2_GET_SWZL = re.compile(r'[xy]{,4}')
_VEC3_GET_SWZL = re.compile(r'[xyz]{,4}')
_VEC4_GET_SWZL = re.compile(r'[xyzw]{,4}')
_RGBA_GET_SWZL = re.compile(r'[rgba]{4}')

_VEC2_SET_SWZL = re.compile(r'[xy]{,2}')
_VEC3_SET_SWZL = re.compile(r'[xyz]{,3}')
_VEC4_SET_SWZL = re.compile(r'[xyzw]{,4}')
_RGBA_SET_SWZL = re.compile(r'[rgba]{1,4}')

_number = (int, float)

# region FUNCTIONS


def _classname(obj):
    return obj.__class__.__name__


def _clsname(obj):
    return obj.__class__.__name__


def is_number(obj):
    return isinstance(obj, _number)


def is_component(value):
    return isinstance(value, int) and 0 <= value <= 255


def _clamp_rgba(*args):
    return tuple(value & 255 for value in args)


def _str_in(value):
    return value.encode('utf-8', 'ignore') if isinstance(value, str) else value


def _str_in2(values):
    return _arr(CharPtr, tuple(_str_in(value) for value in values))


def _str_out(value):
    return value.decode('utf-8', 'ignore') if isinstance(value, bytes) else value


def _arr(typ, data):
    return (typ * len(data))(*data)


def _arr2(typ, data):
    arr = typ * len(data[0])
    return (arr * len(data))(*data)

# region TYPE CAST FUNCS


def _float(value):
    return float(value)


def _int(value, ranged=None):
    if ranged:
        return max(ranged[0], min(int(value), ranged[1]))
    return int(value)


def _vec2(seq):
    if isinstance(seq, Vector2):
        return seq
    x, y = seq
    return Vector2(_float(x), _float(y))


def _vec3(seq):
    if isinstance(seq, Vector3):
        return seq
    x, y, z = seq
    return Vector3(float(x), float(y), float(z))


def _vec4(seq):
    if isinstance(seq, Vector4):
        return seq
    x, y, z, w = seq
    return Vector4(float(x), float(y), float(z), float(w))


def _rect(seq):
    if isinstance(seq, Rectangle):
        return seq
    x, y, w, h = seq
    return Rectangle(float(x), float(y), float(w), float(h))


def _color(seq):
    if isinstance(seq, Color):
        return seq
    r, g, b, q = seq
    rng = 0, 255
    return Color(_int(r, rng), _int(r, rng), _int(b, rng), _int(q, rng))

# endregion (type cast funcs)

# endregion (functions)

# region TYPES

Bool = c_bool
BoolPtr = POINTER(c_bool)
Byte = c_byte
BytePtr = POINTER(c_byte)
Char = c_char
CharPtr = POINTER(c_char)
Short = c_short
ShortPtr = POINTER(c_short)
Int = c_long
IntPtr = POINTER(c_long)
Long = c_long
LongPtr = POINTER(c_long)
UByte = c_ubyte
UBytePtr = POINTER(c_ubyte)
UShort = c_ushort
UShortPtr = POINTER(c_ushort)
UInt = c_ulong
UIntPtr = POINTER(c_ulong)
ULong = c_ulong
ULongPtr = POINTER(c_ulong)
Float = c_float
FloatPtr = POINTER(c_float)
Double = c_double
DoublePtr = POINTER(c_double)
VoidPtr = c_void_p
VoidPtrPtr = POINTER(c_void_p)
CharPtr = c_char_p
CharPtrPtr = POINTER(c_char_p)

class Vector2(Structure):
    '''Vector2, 2 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
    ]

    @classmethod
    def array_of(cls, vector2_sequence):
        '''Creates and returns an array of Vector2s'''
        arr = cls * len(vector2_sequence)
        return arr(*vector2_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Vector2'''
        return cls(0.0, 0.0)

    def __init__(self, x, y):
        '''Vector2, 2 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        '''
        super(Vector2, self).__init__(x, y)

    def __str__(self):
        return "[Vector2 at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Vector2 instance'''
        return byref(self)

    def __len__(self):
        return 2

    def __getitem__(self, key):
        return (self.x, self.y).__getitem__(key)

    def __getattr__(self, attr):
        m = _VEC2_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: float, 2: Vector2, 3: Vector3, 4: Vector4}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _VEC2_SET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Vector2, self).__setattr__(attr, float(value))
        else:
            for i, ch in enumerate(attr):
                super(Vector2, self).__setattr__(ch, float(value[i]))

    def todict(self):
        '''Returns a dict mapping this Vector2's components'''
        return {'x': self.x, 'y': self.y}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Vector2's components'''
        self.x = float(d.get('x', self.x))
        self.y = float(d.get('y', self.y))

    def __str__(self):
        return "({}, {})".format(self.x, self.y)

    def __repr__(self):
        return "Vector2".format(self.__str__())

    def length(self):
        # type: () -> float
        result = _Vector2Length(self)
        return result

    def length_sqr(self):
        # type: () -> float
        result = _Vector2LengthSqr(self)
        return result

    def dot_product(self, v2: Vector2):
        # type: (Vector2) -> float
        result = _Vector2DotProduct(self, v2)
        return result

    def distance(self, v2: Vector2):
        # type: (Vector2) -> float
        result = _Vector2Distance(self, v2)
        return result

    def distance_sqr(self, v2: Vector2):
        # type: (Vector2) -> float
        result = _Vector2DistanceSqr(self, v2)
        return result

    def angle(self, v2: Vector2):
        # type: (Vector2) -> float
        result = _Vector2Angle(self, v2)
        return result

    def normalize(self):
        # type: () -> Vector2
        result = _Vector2Normalize(self)
        return result

    def transform(self, mat: Matrix):
        # type: (Matrix) -> Vector2
        result = _Vector2Transform(self, mat)
        return result

    def lerp(self, v2: Vector2, amount: float):
        # type: (Vector2, float) -> Vector2
        result = _Vector2Lerp(self, v2, float(amount))
        return result

    def reflect(self, normal: Vector2):
        # type: (Vector2) -> Vector2
        result = _Vector2Reflect(self, normal)
        return result

    def rotate(self, angle: float):
        # type: (float) -> Vector2
        result = _Vector2Rotate(self, float(angle))
        return result

    def move_towards(self, target: Vector2, max_distance: float):
        # type: (Vector2, float) -> Vector2
        result = _Vector2MoveTowards(self, target, float(max_distance))
        return result

    def clamp(self, min_: Vector2, max_: Vector2):
        # type: (Vector2, Vector2) -> Vector2
        result = _Vector2Clamp(self, min_, max_)
        return result

    def clamp_value(self, min_: float, max_: float):
        # type: (float, float) -> Vector2
        result = _Vector2ClampValue(self, float(min_), float(max_))
        return result


# Pointer type to Vector2s
Vector2Ptr = POINTER(Vector2)



class Vector3(Structure):
    '''Vector3, 3 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
        ('z', Float),
    ]

    @classmethod
    def array_of(cls, vector3_sequence):
        '''Creates and returns an array of Vector3s'''
        arr = cls * len(vector3_sequence)
        return arr(*vector3_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Vector3'''
        return cls(0.0, 0.0, 0.0)

    def __init__(self, x, y, z):
        '''Vector3, 3 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        :param float z: `float` in C raylib
        '''
        super(Vector3, self).__init__(x, y, z)

    def __str__(self):
        return "[Vector3 at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Vector3 instance'''
        return byref(self)

    def __len__(self):
        return 3

    def __getitem__(self, key):
        return (self.x, self.y, self.z).__getitem__(key)

    def __getattr__(self, attr):
        m = _VEC3_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: float, 2: Vector2, 3: Vector3, 4: Vector4}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _VEC3_SET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Vector3, self).__setattr__(attr, float(value))
        else:
            for i, ch in enumerate(attr):
                super(Vector3, self).__setattr__(ch, float(value[i]))

    def todict(self):
        '''Returns a dict mapping this Vector3's components'''
        return {'x': self.x, 'y': self.y, 'z': self.z}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Vector3's components'''
        self.x = float(d.get('x', self.x))
        self.y = float(d.get('y', self.y))
        self.z = float(d.get('z', self.z))

    def __str__(self):
        return "({}, {}, {})".format(self.x, self.y, self.z)

    def __repr__(self):
        return "Vector3".format(self.__str__())

    def cross_product(self, v2: Vector3):
        # type: (Vector3) -> float
        result = _Vector3CrossProduct(self, v2)
        return result

    def perpendicular(self):
        # type: () -> Vector3
        result = _Vector3Perpendicular(self)
        return result

    def length(self):
        # type: () -> Vector3
        result = _Vector3Length(self)
        return result

    def length_sqr(self):
        # type: () -> Vector3
        result = _Vector3LengthSqr(self)
        return result

    def dot_product(self, v2: Vector3):
        # type: (Vector3) -> float
        result = _Vector3DotProduct(self, v2)
        return result

    def distance(self, v2: Vector3):
        # type: (Vector3) -> float
        result = _Vector3Distance(self, v2)
        return result

    def distance_sqr(self, v2: Vector3):
        # type: (Vector3) -> float
        result = _Vector3DistanceSqr(self, v2)
        return result

    def angle(self, v2: Vector3):
        # type: (Vector3) -> float
        result = _Vector3Angle(self, v2)
        return result

    def normalize(self):
        # type: () -> Vector3
        result = _Vector3Normalize(self)
        return result

    def ortho_normalize(self, v2: Vector3Ptr):
        # type: (Vector3Ptr) -> Vector3
        result = _Vector3OrthoNormalize(self, v2)
        return result

    def transform(self, mat: Matrix):
        # type: (Matrix) -> Vector3
        result = _Vector3Transform(self, mat)
        return result

    def rotate_by_quaternion(self, q: Quaternion):
        # type: (Quaternion) -> Vector3
        result = _Vector3RotateByQuaternion(self, q)
        return result

    def rotate_by_axis_angle(self, axis: Vector3, angle: float):
        # type: (Vector3, float) -> Vector3
        result = _Vector3RotateByAxisAngle(self, axis, float(angle))
        return result

    def lerp(self, v2: Vector3, amount: float):
        # type: (Vector3, float) -> Vector3
        result = _Vector3Lerp(self, v2, float(amount))
        return result

    def reflect(self, normal: Vector3):
        # type: (Vector3) -> Vector3
        result = _Vector3Reflect(self, normal)
        return result

    def min(self, v2: Vector3):
        # type: (Vector3) -> Vector3
        result = _Vector3Min(self, v2)
        return result

    def max(self, v2: Vector3):
        # type: (Vector3) -> Vector3
        result = _Vector3Max(self, v2)
        return result

    def barycenter(self, a: Vector3, b: Vector3, c: Vector3):
        # type: (Vector3, Vector3, Vector3) -> Vector3
        result = _Vector3Barycenter(self, a, b, c)
        return result

    def unproject(self, projection: Matrix, view: Matrix):
        # type: (Matrix, Matrix) -> Vector3
        result = _Vector3Unproject(self, projection, view)
        return result

    def to_float_v(self):
        # type: () -> Sequence[float]
        result = _Vector3ToFloatV(self)
        return result

    def clamp(self, min_: Vector3, max_: Vector3):
        # type: (Vector3, Vector3) -> Vector3
        result = _Vector3Clamp(self, min_, max_)
        return result

    def clamp_value(self, min_: float, max_: float):
        # type: (float, float) -> Vector3
        result = _Vector3ClampValue(self, float(min_), float(max_))
        return result

    def refract(self, n: Vector3, r: float):
        # type: (Vector3, float) -> int
        result = _Vector3Refract(self, n, float(r))
        return result


# Pointer type to Vector3s
Vector3Ptr = POINTER(Vector3)



class Vector4(Structure):
    '''Vector4, 4 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
        ('z', Float),
        ('w', Float),
    ]

    @classmethod
    def array_of(cls, vector4_sequence):
        '''Creates and returns an array of Vector4s'''
        arr = cls * len(vector4_sequence)
        return arr(*vector4_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Vector4'''
        return cls(0.0, 0.0, 0.0, 0.0)

    def __init__(self, x, y, z, w):
        '''Vector4, 4 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        :param float z: `float` in C raylib
        :param float w: `float` in C raylib
        '''
        super(Vector4, self).__init__(x, y, z, w)

    def __str__(self):
        return "[Vector4 at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Vector4 instance'''
        return byref(self)

    def __len__(self):
        return 4

    def __getitem__(self, key):
        return (self.x, self.y. self.z, self.w).__getitem__(key)

    def __getattr__(self, attr):
        m = _VEC4_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: float, 2: Vector2, 3: Vector3, 4: Vector4}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _VEC4_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Vector4, self).__setattr__(attr, float(value))
        else:
            for i, ch in enumerate(attr):
                super(Vector4, self).__setattr__(ch, float(value[i]))

    def todict(self):
        '''Returns a dict mapping this Vector4's components'''
        return {'x': self.x, 'y': self.y, 'z': self.z, 'w': self.w}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Vector4's components'''
        self.x = float(d.get('x', self.x))
        self.y = float(d.get('y', self.y))
        self.z = float(d.get('z', self.z))
        self.w = float(d.get('w', self.w))

    def __str__(self):
        return "({}, {}, {}, {})".format(self.x, self.y, self.z, self.w)

    def __repr__(self):
        return "Vector4".format(self.__str__())


# Pointer type to Vector4s
Vector4Ptr = POINTER(Vector4)

# Quaternion, 4 components (Vector4 alias)
Quaternion = Vector4
QuaternionPtr = Vector4Ptr



class Matrix(Structure):
    '''Matrix, 4x4 components, column major, OpenGL style, right handed'''
    _fields_ = [
        ('m0', Float),
        ('m4', Float),
        ('m8', Float),
        ('m12', Float),
        ('m1', Float),
        ('m5', Float),
        ('m9', Float),
        ('m13', Float),
        ('m2', Float),
        ('m6', Float),
        ('m10', Float),
        ('m14', Float),
        ('m3', Float),
        ('m7', Float),
        ('m11', Float),
        ('m15', Float),
    ]

    @classmethod
    def array_of(cls, matrix_sequence):
        '''Creates and returns an array of Matrixs'''
        arr = cls * len(matrix_sequence)
        return arr(*matrix_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Matrix'''
        return cls(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)

    def __init__(self, m0, m4, m8, m12, m1, m5, m9, m13, m2, m6, m10, m14, m3, m7, m11, m15):
        '''Matrix, 4x4 components, column major, OpenGL style, right handed

        :param float m0: `float` in C raylib
        :param float m4: `float` in C raylib
        :param float m8: `float` in C raylib
        :param float m12: `float` in C raylib
        :param float m1: `float` in C raylib
        :param float m5: `float` in C raylib
        :param float m9: `float` in C raylib
        :param float m13: `float` in C raylib
        :param float m2: `float` in C raylib
        :param float m6: `float` in C raylib
        :param float m10: `float` in C raylib
        :param float m14: `float` in C raylib
        :param float m3: `float` in C raylib
        :param float m7: `float` in C raylib
        :param float m11: `float` in C raylib
        :param float m15: `float` in C raylib
        '''
        super(Matrix, self).__init__(m0, m4, m8, m12, m1, m5, m9, m13, m2, m6, m10, m14, m3, m7, m11, m15)

    def __str__(self):
        return "[Matrix at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Matrix instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def determinant(self):
        # type: () -> float
        result = _MatrixDeterminant(self)
        return result

    def trace(self):
        # type: () -> float
        result = _MatrixTrace(self)
        return result

    def transpose(self):
        # type: () -> Matrix
        result = _MatrixTranspose(self)
        return result

    def invert(self):
        # type: () -> Matrix
        result = _MatrixInvert(self)
        return result

    @classmethod
    def translate(cls, x: float, y: float, z: float):
        # type: (float, float) -> Matrix
        result = _MatrixTranslate(float(x), float(y), float(z))
        return result

    @classmethod
    def rotate(cls, axis: Vector3, angle: float):
        # type: (float) -> Matrix
        result = _MatrixRotate(axis, float(angle))
        return result

    @classmethod
    def rotate_x(cls, angle: float):
        # type: () -> Matrix
        result = _MatrixRotateX(float(angle))
        return result

    @classmethod
    def rotate_y(cls, angle: float):
        # type: () -> Matrix
        result = _MatrixRotateY(float(angle))
        return result

    @classmethod
    def rotate_z(cls, angle: float):
        # type: () -> Matrix
        result = _MatrixRotateZ(float(angle))
        return result

    @classmethod
    def rotate_xyz(cls, angle: Vector3):
        # type: () -> Matrix
        result = _MatrixRotateXYZ(angle)
        return result

    @classmethod
    def rotate_zyx(cls, angle: Vector3):
        # type: () -> Matrix
        result = _MatrixRotateZYX(angle)
        return result

    @classmethod
    def scale(cls, x: float, y: float, z: float):
        # type: (float, float) -> Matrix
        result = _MatrixScale(float(x), float(y), float(z))
        return result

    @classmethod
    def frustum(cls, left: float, right: float, bottom: float, top: float, near: float, far: float):
        # type: (float, float, float, float, float) -> Matrix
        result = _MatrixFrustum(float(left), float(right), float(bottom), float(top), float(near), float(far))
        return result

    @classmethod
    def perspective(cls, fovy: float, aspect: float, near: float, far: float):
        # type: (float, float, float) -> Matrix
        result = _MatrixPerspective(float(fovy), float(aspect), float(near), float(far))
        return result

    @classmethod
    def ortho(cls, left: float, right: float, bottom: float, top: float, near: float, far: float):
        # type: (float, float, float, float, float) -> Matrix
        result = _MatrixOrtho(float(left), float(right), float(bottom), float(top), float(near), float(far))
        return result

    @classmethod
    def look_at(cls, eye: Vector3, target: Vector3, up: Vector3):
        # type: (Vector3, Vector3) -> Matrix
        result = _MatrixLookAt(eye, target, up)
        return result


# Pointer type to Matrixs
MatrixPtr = POINTER(Matrix)



class Color(Structure):
    '''Color, 4 components, R8G8B8A8 (32bit)'''
    _fields_ = [
        ('r', UByte),
        ('g', UByte),
        ('b', UByte),
        ('a', UByte),
    ]

    @classmethod
    def array_of(cls, color_sequence):
        '''Creates and returns an array of Colors'''
        arr = cls * len(color_sequence)
        return arr(*color_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Color'''
        return cls(0, 0, 0, 0)

    def __init__(self, r, g, b, a):
        '''Color, 4 components, R8G8B8A8 (32bit)

        :param int r: `unsigned char` in C raylib
        :param int g: `unsigned char` in C raylib
        :param int b: `unsigned char` in C raylib
        :param int a: `unsigned char` in C raylib
        '''
        super(Color, self).__init__(r, g, b, a)

    def __str__(self):
        return "[Color at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Color instance'''
        return byref(self)

    def __len__(self):
        return 4

    def __getitem__(self, key):
        return (self.r, self.g, self.b, self.a).__getitem__(key)

    def __getattr__(self, attr):
        m = _RGBA_GET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        cls = {1: int, 4: Color}.get(len(attr))
        v = self.todict()
        return cls(*(v[ch] for ch in attr))

    def __setattr__(self, attr, value):
        m = _RGBA_SET_SWZL.match(attr)
        if not m:
            raise AttributeError("{} object does not have attribute '{}'.".format(_classname(self), attr))
        if len(attr) == 1:
            super(Color, self).__setattr__(attr, int(value))
        else:
            for i, ch in enumerate(attr):
                super(Color, self).__setattr__(ch, int(value[i]))

    def todict(self):
        '''Returns a dict mapping this Color's components'''
        return {'r': self.r, 'g': self.g, 'b': self.b, 'a': self.a}

    def fromdict(self, d):
        '''Apply the mapping `d` to this Color's components'''
        self.r = int(d.get('r', self.r))
        self.g = int(d.get('g', self.g))
        self.b = int(d.get('b', self.b))
        self.a = int(d.get('a', self.a))

    def __str__(self):
        return "({: 3}, {: 3}, {: 3}, {: 3})".format(self.r, self.g, self.b, self.a)

    def __repr__(self):
        return "Color{}".format(self.__str__())

    def fade(self, alpha: float):
        # type: (float) -> Color
        result = _Fade(self, float(alpha))
        return result

    def to_int(self):
        # type: () -> int
        result = _ColorToInt(self)
        return result

    def to_hsv(self):
        # type: () -> Vector3
        result = _ColorToHSV(self)
        return result

    def from_hsv(self, saturation: float, value: float):
        # type: (float, float) -> Color
        result = _ColorFromHSV(self, float(saturation), float(value))
        return result

    def alpha(self, alpha: float):
        # type: (float) -> Color
        result = _ColorAlpha(self, float(alpha))
        return result

    def alpha_blend(self, src: Color, tint: Color):
        # type: (Color, Color) -> Color
        result = _ColorAlphaBlend(self, src, tint)
        return result


# Pointer type to Colors
ColorPtr = POINTER(Color)



class Rectangle(Structure):
    '''Rectangle, 4 components'''
    _fields_ = [
        ('x', Float),
        ('y', Float),
        ('width', Float),
        ('height', Float),
    ]

    @classmethod
    def array_of(cls, rectangle_sequence):
        '''Creates and returns an array of Rectangles'''
        arr = cls * len(rectangle_sequence)
        return arr(*rectangle_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Rectangle'''
        return cls(0.0, 0.0, 0.0, 0.0)

    def __init__(self, x, y, width, height):
        '''Rectangle, 4 components

        :param float x: `float` in C raylib
        :param float y: `float` in C raylib
        :param float width: `float` in C raylib
        :param float height: `float` in C raylib
        '''
        super(Rectangle, self).__init__(x, y, width, height)

    def __str__(self):
        return "[Rectangle at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Rectangle instance'''
        return byref(self)


# Pointer type to Rectangles
RectanglePtr = POINTER(Rectangle)



class Image(Structure):
    '''Image, pixel data stored in CPU memory (RAM)'''
    _fields_ = [
        ('data', VoidPtr),
        ('width', Int),
        ('height', Int),
        ('mipmaps', Int),
        ('format', Int),
    ]

    @classmethod
    def array_of(cls, image_sequence):
        '''Creates and returns an array of Images'''
        arr = cls * len(image_sequence)
        return arr(*image_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Image'''
        return cls(None, 0, 0, 0, 0)

    def __init__(self, data, width, height, mipmaps, format):
        '''Image, pixel data stored in CPU memory (RAM)

        :param bytes data: `void *` in C raylib
        :param int width: `int` in C raylib
        :param int height: `int` in C raylib
        :param int mipmaps: `int` in C raylib
        :param int format: `int` in C raylib
        '''
        super(Image, self).__init__(data, width, height, mipmaps, format)

    def __str__(self):
        return "[Image at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Image instance'''
        return byref(self)

    def unload(self):
        # type: () -> None
        _UnloadImage(self)

    def export(self, file_name: bytes):
        # type: (bytes) -> bool
        result = _ExportImage(self, _str_in(file_name))
        return result

    def export_as_code(self, file_name: bytes):
        # type: (bytes) -> bool
        result = _ExportImageAsCode(self, _str_in(file_name))
        return result

    def copy(self):
        # type: () -> Image
        result = _ImageCopy(self)
        return result

    def format(self, new_format: int):
        # type: (int) -> None
        _ImageFormat(self.byref, int(new_format))

    def to_pot(self, fill: Color):
        # type: (Color) -> None
        _ImageToPOT(self.byref, fill)

    def crop(self, crop: Rectangle):
        # type: (Rectangle) -> None
        _ImageCrop(self.byref, crop)

    def alpha_crop(self, threshold: float):
        # type: (float) -> None
        _ImageAlphaCrop(self.byref, float(threshold))

    def alpha_clear(self, color: Color, threshold: float):
        # type: (Color, float) -> None
        _ImageAlphaClear(self.byref, color, float(threshold))

    def alpha_mask(self, alpha_mask: Image):
        # type: (Image) -> None
        _ImageAlphaMask(self.byref, alpha_mask)

    def alpha_premultiply(self):
        # type: () -> None
        _ImageAlphaPremultiply(self.byref)

    def resize(self, new_width: int, new_height: int):
        # type: (int, int) -> None
        _ImageResize(self.byref, int(new_width), int(new_height))

    def resize_nn(self, new_width: int, new_height: int):
        # type: (int, int) -> None
        _ImageResizeNN(self.byref, int(new_width), int(new_height))

    def resize_canvas(self, new_width: int, new_height: int, offset_x: int, offset_y: int, fill: Color):
        # type: (int, int, int, int, Color) -> None
        _ImageResizeCanvas(self.byref, int(new_width), int(new_height), int(offset_x), int(offset_y), fill)

    def mipmaps(self):
        # type: () -> None
        _ImageMipmaps(self.byref)

    def dither(self, r_bpp: int, g_bpp: int, b_bpp: int, a_bpp: int):
        # type: (int, int, int, int) -> None
        _ImageDither(self.byref, int(r_bpp), int(g_bpp), int(b_bpp), int(a_bpp))

    def flip_vertical(self):
        # type: () -> None
        _ImageFlipVertical(self.byref)

    def flip_horizontal(self):
        # type: () -> None
        _ImageFlipHorizontal(self.byref)

    def rotate_cw(self):
        # type: () -> None
        _ImageRotateCW(self.byref)

    def rotate_ccw(self):
        # type: () -> None
        _ImageRotateCCW(self.byref)

    def color_tint(self, color: Color):
        # type: (Color) -> None
        _ImageColorTint(self.byref, color)

    def color_invert(self):
        # type: () -> None
        _ImageColorInvert(self.byref)

    def color_grayscale(self):
        # type: () -> None
        _ImageColorGrayscale(self.byref)

    def color_contrast(self, contrast: float):
        # type: (float) -> None
        _ImageColorContrast(self.byref, float(contrast))

    def color_brightness(self, brightness: int):
        # type: (int) -> None
        _ImageColorBrightness(self.byref, int(brightness))

    def color_replace(self, color: Color, replace: Color):
        # type: (Color, Color) -> None
        _ImageColorReplace(self.byref, color, replace)

    def clear_background(self, color: Color):
        # type: (Color) -> None
        _ImageClearBackground(self.byref, color)

    def draw_pixel(self, pos_x: int, pos_y: int, color: Color):
        # type: (int, int, Color) -> None
        _ImageDrawPixel(self.byref, int(pos_x), int(pos_y), color)

    def draw_pixel_v(self, position: Vector2, color: Color):
        # type: (Vector2, Color) -> None
        _ImageDrawPixelV(self.byref, position, color)

    def draw_line(self, start_pos_x: int, start_pos_y: int, end_pos_x: int, end_pos_y: int, color: Color):
        # type: (int, int, int, int, Color) -> None
        _ImageDrawLine(self.byref, int(start_pos_x), int(start_pos_y), int(end_pos_x), int(end_pos_y), color)

    def draw_line_v(self, start: Vector2, end: Vector2, color: Color):
        # type: (Vector2, Vector2, Color) -> None
        _ImageDrawLineV(self.byref, start, end, color)

    def draw_circle(self, center_x: int, center_y: int, radius: int, color: Color):
        # type: (int, int, int, Color) -> None
        _ImageDrawCircle(self.byref, int(center_x), int(center_y), int(radius), color)

    def draw_circle_v(self, center: Vector2, radius: int, color: Color):
        # type: (Vector2, int, Color) -> None
        _ImageDrawCircleV(self.byref, center, int(radius), color)

    def draw_rectangle(self, pos_x: int, pos_y: int, width: int, height: int, color: Color):
        # type: (int, int, int, int, Color) -> None
        _ImageDrawRectangle(self.byref, int(pos_x), int(pos_y), int(width), int(height), color)

    def draw_rectangle_v(self, position: Vector2, size: Vector2, color: Color):
        # type: (Vector2, Vector2, Color) -> None
        _ImageDrawRectangleV(self.byref, position, size, color)

    def draw_rectangle_rec(self, rec: Rectangle, color: Color):
        # type: (Rectangle, Color) -> None
        _ImageDrawRectangleRec(self.byref, rec, color)

    def draw_rectangle_lines(self, rec: Rectangle, thick: int, color: Color):
        # type: (Rectangle, int, Color) -> None
        _ImageDrawRectangleLines(self.byref, rec, int(thick), color)

    def draw(self, src: Image, src_rec: Rectangle, dst_rec: Rectangle, tint: Color):
        # type: (Image, Rectangle, Rectangle, Color) -> None
        _ImageDraw(self.byref, src, src_rec, dst_rec, tint)

    def draw_text(self, text: bytes, pos_x: int, pos_y: int, font_size: int, color: Color):
        # type: (bytes, int, int, int, Color) -> None
        _ImageDrawText(self.byref, _str_in(text), int(pos_x), int(pos_y), int(font_size), color)

    def draw_text_ex(self, font: Font, text: bytes, position: Vector2, font_size: float, spacing: float, tint: Color):
        # type: (Font, bytes, Vector2, float, float, Color) -> None
        _ImageDrawTextEx(self.byref, font, _str_in(text), position, float(font_size), float(spacing), tint)

    def load_colors(self):
        # type: () -> ColorPtr
        result = _LoadImageColors(self)
        return result

    def load_palette(self, max_palette_size: int, color_count: Sequence[int]):
        # type: (int, Sequence[int]) -> ColorPtr
        result = _LoadImagePalette(self, int(max_palette_size), color_count_ref)
        return result

    def get_alpha_border(self, threshold: float):
        # type: (float) -> Rectangle
        result = _GetImageAlphaBorder(self, float(threshold))
        return result

    def get_color(self, x: int, y: int):
        # type: (int, int) -> Color
        result = _GetImageColor(self, int(x), int(y))
        return result

    @classmethod
    def load(cls, file_name: bytes):
        # type: () -> Image
        result = _LoadImage(_str_in(file_name))
        return result

    @classmethod
    def load_raw(cls, file_name: bytes, width: int, height: int, format: int, header_size: int):
        # type: (int, int, int, int) -> Image
        result = _LoadImageRaw(_str_in(file_name), int(width), int(height), int(format), int(header_size))
        return result

    @classmethod
    def load_anim(cls, file_name: bytes, frames: Sequence[int]):
        # type: (Sequence[int]) -> Image
        result = _LoadImageAnim(_str_in(file_name), frames_ref)
        return result

    @classmethod
    def load_from_memory(cls, file_type: bytes, file_data: bytes, data_size: int):
        # type: (bytes, int) -> Image
        result = _LoadImageFromMemory(_str_in(file_type), _str_in(file_data), int(data_size))
        return result

    @classmethod
    def load_from_texture(cls, texture: Texture2D):
        # type: () -> Image
        result = _LoadImageFromTexture(texture)
        return result

    @classmethod
    def gen_color(cls, width: int, height: int, color: Color):
        # type: (int, Color) -> Image
        result = _GenImageColor(int(width), int(height), color)
        return result

    @classmethod
    def gen_gradient_h(cls, width: int, height: int, left: Color, right: Color):
        # type: (int, Color, Color) -> Image
        result = _GenImageGradientH(int(width), int(height), left, right)
        return result

    @classmethod
    def gen_gradient_v(cls, width: int, height: int, top: Color, bottom: Color):
        # type: (int, Color, Color) -> Image
        result = _GenImageGradientV(int(width), int(height), top, bottom)
        return result

    @classmethod
    def gen_gradient_radial(cls, width: int, height: int, density: float, inner: Color, outer: Color):
        # type: (int, float, Color, Color) -> Image
        result = _GenImageGradientRadial(int(width), int(height), float(density), inner, outer)
        return result

    @classmethod
    def gen_checked(cls, width: int, height: int, checks_x: int, checks_y: int, col1: Color, col2: Color):
        # type: (int, int, int, Color, Color) -> Image
        result = _GenImageChecked(int(width), int(height), int(checks_x), int(checks_y), col1, col2)
        return result

    @classmethod
    def gen_white_noise(cls, width: int, height: int, factor: float):
        # type: (int, float) -> Image
        result = _GenImageWhiteNoise(int(width), int(height), float(factor))
        return result

    @classmethod
    def gen_cellular(cls, width: int, height: int, tile_size: int):
        # type: (int, int) -> Image
        result = _GenImageCellular(int(width), int(height), int(tile_size))
        return result

    @classmethod
    def from_image(cls, image: Image, rec: Rectangle):
        # type: (Rectangle) -> Image
        result = _ImageFromImage(image, rec)
        return result

    @classmethod
    def text(cls, text: bytes, font_size: int, color: Color):
        # type: (int, Color) -> Image
        result = _ImageText(_str_in(text), int(font_size), color)
        return result

    @classmethod
    def text_ex(cls, font: Font, text: bytes, font_size: float, spacing: float, tint: Color):
        # type: (bytes, float, float, Color) -> Image
        result = _ImageTextEx(font, _str_in(text), float(font_size), float(spacing), tint)
        return result


# Pointer type to Images
ImagePtr = POINTER(Image)



class Texture(Structure):
    '''Texture, tex data stored in GPU memory (VRAM)'''
    _fields_ = [
        ('id', UInt),
        ('width', Int),
        ('height', Int),
        ('mipmaps', Int),
        ('format', Int),
    ]

    @classmethod
    def array_of(cls, texture_sequence):
        '''Creates and returns an array of Textures'''
        arr = cls * len(texture_sequence)
        return arr(*texture_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Texture'''
        return cls(0, 0, 0, 0, 0)

    def __init__(self, id, width, height, mipmaps, format):
        '''Texture, tex data stored in GPU memory (VRAM)

        :param int id: `unsigned int` in C raylib
        :param int width: `int` in C raylib
        :param int height: `int` in C raylib
        :param int mipmaps: `int` in C raylib
        :param int format: `int` in C raylib
        '''
        super(Texture, self).__init__(id, width, height, mipmaps, format)

    def __str__(self):
        return "[Texture at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Texture instance'''
        return byref(self)


# Pointer type to Textures
TexturePtr = POINTER(Texture)

# Texture2D, same as Texture
Texture2D = Texture
Texture2DPtr = TexturePtr


# TextureCubemap, same as Texture
TextureCubemap = Texture
TextureCubemapPtr = TexturePtr



class RenderTexture(Structure):
    '''RenderTexture, fbo for texture rendering'''
    _fields_ = [
        ('id', UInt),
        ('texture', Texture),
        ('depth', Texture),
    ]

    @classmethod
    def array_of(cls, render_texture_sequence):
        '''Creates and returns an array of RenderTextures'''
        arr = cls * len(render_texture_sequence)
        return arr(*render_texture_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized RenderTexture'''
        return cls(0, Texture.zero(), Texture.zero())

    def __init__(self, id, texture, depth):
        '''RenderTexture, fbo for texture rendering

        :param int id: `unsigned int` in C raylib
        :param Texture texture: `Texture` in C raylib
        :param Texture depth: `Texture` in C raylib
        '''
        super(RenderTexture, self).__init__(id, texture, depth)

    def __str__(self):
        return "[RenderTexture at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this RenderTexture instance'''
        return byref(self)


# Pointer type to RenderTextures
RenderTexturePtr = POINTER(RenderTexture)

# RenderTexture2D, same as RenderTexture
RenderTexture2D = RenderTexture
RenderTexture2DPtr = RenderTexturePtr



class NPatchInfo(Structure):
    '''NPatchInfo, n-patch layout info'''
    _fields_ = [
        ('source', Rectangle),
        ('left', Int),
        ('top', Int),
        ('right', Int),
        ('bottom', Int),
        ('layout', Int),
    ]

    @classmethod
    def array_of(cls, npatch_info_sequence):
        '''Creates and returns an array of NPatchInfos'''
        arr = cls * len(npatch_info_sequence)
        return arr(*npatch_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized NPatchInfo'''
        return cls(Rectangle.zero(), 0, 0, 0, 0, 0)

    def __init__(self, source, left, top, right, bottom, layout):
        '''NPatchInfo, n-patch layout info

        :param Rectangle source: `Rectangle` in C raylib
        :param int left: `int` in C raylib
        :param int top: `int` in C raylib
        :param int right: `int` in C raylib
        :param int bottom: `int` in C raylib
        :param int layout: `int` in C raylib
        '''
        super(NPatchInfo, self).__init__(source, left, top, right, bottom, layout)

    def __str__(self):
        return "[NPatchInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this NPatchInfo instance'''
        return byref(self)


# Pointer type to NPatchInfos
NPatchInfoPtr = POINTER(NPatchInfo)



class GlyphInfo(Structure):
    '''GlyphInfo, font characters glyphs info'''
    _fields_ = [
        ('value', Int),
        ('offset_x', Int),
        ('offset_y', Int),
        ('advance_x', Int),
        ('image', Image),
    ]

    @classmethod
    def array_of(cls, glyph_info_sequence):
        '''Creates and returns an array of GlyphInfos'''
        arr = cls * len(glyph_info_sequence)
        return arr(*glyph_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized GlyphInfo'''
        return cls(0, 0, 0, 0, Image.zero())

    def __init__(self, value, offset_x, offset_y, advance_x, image):
        '''GlyphInfo, font characters glyphs info

        :param int value: `int` in C raylib
        :param int offsetX: `int` in C raylib
        :param int offsetY: `int` in C raylib
        :param int advanceX: `int` in C raylib
        :param Image image: `Image` in C raylib
        '''
        super(GlyphInfo, self).__init__(value, offset_x, offset_y, advance_x, image)

    def __str__(self):
        return "[GlyphInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this GlyphInfo instance'''
        return byref(self)


# Pointer type to GlyphInfos
GlyphInfoPtr = POINTER(GlyphInfo)



class Font(Structure):
    '''Font, font texture and GlyphInfo array data'''
    _fields_ = [
        ('base_size', Int),
        ('glyph_count', Int),
        ('glyph_padding', Int),
        ('texture', Texture2D),
        ('recs', RectanglePtr),
        ('glyphs', GlyphInfoPtr),
    ]

    @classmethod
    def array_of(cls, font_sequence):
        '''Creates and returns an array of Fonts'''
        arr = cls * len(font_sequence)
        return arr(*font_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Font'''
        return cls(0, 0, 0, Texture2D.zero(), Rectangle.zero(), GlyphInfo.zero())

    def __init__(self, base_size, glyph_count, glyph_padding, texture, recs, glyphs):
        '''Font, font texture and GlyphInfo array data

        :param int baseSize: `int` in C raylib
        :param int glyphCount: `int` in C raylib
        :param int glyphPadding: `int` in C raylib
        :param Texture2D texture: `Texture2D` in C raylib
        :param RectanglePtr recs: `Rectangle *` in C raylib
        :param GlyphInfoPtr glyphs: `GlyphInfo *` in C raylib
        '''
        super(Font, self).__init__(base_size, glyph_count, glyph_padding, texture, recs, glyphs)

    def __str__(self):
        return "[Font at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Font instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def unload(self):
        # type: () -> None
        _UnloadFont(self)

    def draw_text_ex(self, text: bytes, position: Vector2, font_size: float, spacing: float, tint: Color):
        # type: (bytes, Vector2, float, float, Color) -> None
        _DrawTextEx(self, _str_in(text), position, float(font_size), float(spacing), tint)

    def draw_text_pro(self, text: bytes, position: Vector2, origin: Vector2, rotation: float, font_size: float, spacing: float, tint: Color):
        # type: (bytes, Vector2, Vector2, float, float, float, Color) -> None
        _DrawTextPro(self, _str_in(text), position, origin, float(rotation), float(font_size), float(spacing), tint)

    def draw_text_codepoint(self, codepoint: int, position: Vector2, font_size: float, tint: Color):
        # type: (int, Vector2, float, Color) -> None
        _DrawTextCodepoint(self, int(codepoint), position, float(font_size), tint)

    def draw_text_codepoints(self, codepoints: Sequence[int], count: int, position: Vector2, font_size: float, spacing: float, tint: Color):
        # type: (Sequence[int], int, Vector2, float, float, Color) -> None
        _DrawTextCodepoints(self, codepoints_ref, int(count), position, float(font_size), float(spacing), tint)

    def measure_text_ex(self, text: bytes, font_size: float, spacing: float):
        # type: (bytes, float, float) -> Vector2
        result = _MeasureTextEx(self, _str_in(text), float(font_size), float(spacing))
        return result

    def get_glyph_index(self, codepoint: int):
        # type: (int) -> int
        result = _GetGlyphIndex(self, int(codepoint))
        return result

    def get_glyph_info(self, codepoint: int):
        # type: (int) -> GlyphInfo
        result = _GetGlyphInfo(self, int(codepoint))
        return result

    def get_glyph_atlas_rec(self, codepoint: int):
        # type: (int) -> Rectangle
        result = _GetGlyphAtlasRec(self, int(codepoint))
        return result

    @classmethod
    def load(cls, file_name: bytes):
        # type: () -> Font
        result = _LoadFont(_str_in(file_name))
        return result

    @classmethod
    def load_ex(cls, file_name: bytes, font_size: int, font_chars: Sequence[int], glyph_count: int):
        # type: (int, Sequence[int], int) -> Font
        result = _LoadFontEx(_str_in(file_name), int(font_size), font_chars_ref, int(glyph_count))
        return result

    @classmethod
    def load_from_image(cls, image: Image, key: Color, first_char: int):
        # type: (Color, int) -> Font
        result = _LoadFontFromImage(image, key, int(first_char))
        return result

    @classmethod
    def load_from_memory(cls, file_type: bytes, file_data: bytes, data_size: int, font_size: int, font_chars: Sequence[int], glyph_count: int):
        # type: (bytes, int, int, Sequence[int], int) -> Font
        result = _LoadFontFromMemory(_str_in(file_type), _str_in(file_data), int(data_size), int(font_size), font_chars_ref, int(glyph_count))
        return result


# Pointer type to Fonts
FontPtr = POINTER(Font)



class Camera3D(Structure):
    '''Camera, defines position/orientation in 3d space'''
    _fields_ = [
        ('position', Vector3),
        ('target', Vector3),
        ('up', Vector3),
        ('fovy', Float),
        ('projection', Int),
    ]

    @classmethod
    def array_of(cls, camera3d_sequence):
        '''Creates and returns an array of Camera3Ds'''
        arr = cls * len(camera3d_sequence)
        return arr(*camera3d_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Camera3D'''
        return cls(Vector3.zero(), Vector3.zero(), Vector3.zero(), 0.0, 0)

    def __init__(self, position, target, up, fovy, projection):
        '''Camera, defines position/orientation in 3d space

        :param Vector3 position: `Vector3` in C raylib
        :param Vector3 target: `Vector3` in C raylib
        :param Vector3 up: `Vector3` in C raylib
        :param float fovy: `float` in C raylib
        :param int projection: `int` in C raylib
        '''
        super(Camera3D, self).__init__(position, target, up, fovy, projection)

    def __str__(self):
        return "[Camera3D at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Camera3D instance'''
        return byref(self)

    def set_mode(self, mode: int):
        # type: (int) -> None
        _SetCameraMode(self, int(mode))


# Pointer type to Camera3Ds
Camera3DPtr = POINTER(Camera3D)

# Camera type fallback, defaults to Camera3D
Camera = Camera3D
CameraPtr = Camera3DPtr



class Camera2D(Structure):
    '''Camera2D, defines position/orientation in 2d space'''
    _fields_ = [
        ('offset', Vector2),
        ('target', Vector2),
        ('rotation', Float),
        ('zoom', Float),
    ]

    @classmethod
    def array_of(cls, camera2d_sequence):
        '''Creates and returns an array of Camera2Ds'''
        arr = cls * len(camera2d_sequence)
        return arr(*camera2d_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Camera2D'''
        return cls(Vector2.zero(), Vector2.zero(), 0.0, 0.0)

    def __init__(self, offset, target, rotation, zoom):
        '''Camera2D, defines position/orientation in 2d space

        :param Vector2 offset: `Vector2` in C raylib
        :param Vector2 target: `Vector2` in C raylib
        :param float rotation: `float` in C raylib
        :param float zoom: `float` in C raylib
        '''
        super(Camera2D, self).__init__(offset, target, rotation, zoom)

    def __str__(self):
        return "[Camera2D at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Camera2D instance'''
        return byref(self)


# Pointer type to Camera2Ds
Camera2DPtr = POINTER(Camera2D)



class Mesh(Structure):
    '''Mesh, vertex data and vao/vbo'''
    _fields_ = [
        ('vertex_count', Int),
        ('triangle_count', Int),
        ('vertices', FloatPtr),
        ('texcoords', FloatPtr),
        ('texcoords2', FloatPtr),
        ('normals', FloatPtr),
        ('tangents', FloatPtr),
        ('colors', UBytePtr),
        ('indices', UShortPtr),
        ('anim_vertices', FloatPtr),
        ('anim_normals', FloatPtr),
        ('bone_ids', UBytePtr),
        ('bone_weights', FloatPtr),
        ('vao_id', UInt),
        ('vbo_id', UIntPtr),
    ]

    @classmethod
    def array_of(cls, mesh_sequence):
        '''Creates and returns an array of Meshs'''
        arr = cls * len(mesh_sequence)
        return arr(*mesh_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Mesh'''
        return cls(0, 0, None, None, None, None, None, None, None, None, None, None, None, 0, None)

    def __init__(self, vertex_count, triangle_count, vertices, texcoords, texcoords2, normals, tangents, colors, indices, anim_vertices, anim_normals, bone_ids, bone_weights, vao_id, vbo_id):
        '''Mesh, vertex data and vao/vbo

        :param int vertexCount: `int` in C raylib
        :param int triangleCount: `int` in C raylib
        :param Sequence[float] vertices: `float *` in C raylib
        :param Sequence[float] texcoords: `float *` in C raylib
        :param Sequence[float] texcoords2: `float *` in C raylib
        :param Sequence[float] normals: `float *` in C raylib
        :param Sequence[float] tangents: `float *` in C raylib
        :param bytes colors: `unsigned char *` in C raylib
        :param Sequence[int] indices: `unsigned short *` in C raylib
        :param Sequence[float] animVertices: `float *` in C raylib
        :param Sequence[float] animNormals: `float *` in C raylib
        :param bytes boneIds: `unsigned char *` in C raylib
        :param Sequence[float] boneWeights: `float *` in C raylib
        :param int vaoId: `unsigned int` in C raylib
        :param Sequence[int] vboId: `unsigned int *` in C raylib
        '''
        super(Mesh, self).__init__(vertex_count, triangle_count, vertices, texcoords, texcoords2, normals, tangents, colors, indices, anim_vertices, anim_normals, bone_ids, bone_weights, vao_id, vbo_id)

    def __str__(self):
        return "[Mesh at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Mesh instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def upload(self, dynamic: bool):
        # type: (bool) -> None
        _UploadMesh(self.byref, bool(dynamic))

    def update_buffer(self, index: int, data: bytes, data_size: int, offset: int):
        # type: (int, bytes, int, int) -> None
        _UpdateMeshBuffer(self, int(index), data_ref, int(data_size), int(offset))

    def unload(self):
        # type: () -> None
        _UnloadMesh(self)

    def draw(self, material: Material, transform: Matrix):
        # type: (Material, Matrix) -> None
        _DrawMesh(self, material, transform)

    def draw_instanced(self, material: Material, transforms: MatrixPtr, instances: int):
        # type: (Material, MatrixPtr, int) -> None
        _DrawMeshInstanced(self, material, transforms, int(instances))

    def export(self, file_name: bytes):
        # type: (bytes) -> bool
        result = _ExportMesh(self, _str_in(file_name))
        return result

    def get_bounding_box(self):
        # type: () -> BoundingBox
        result = _GetMeshBoundingBox(self)
        return result

    def gen_tangents(self):
        # type: () -> None
        _GenMeshTangents(self.byref)

    @classmethod
    def gen_poly(cls, sides: int, radius: float):
        # type: (float) -> Mesh
        result = _GenMeshPoly(int(sides), float(radius))
        return result

    @classmethod
    def gen_plane(cls, width: float, length: float, res_x: int, res_z: int):
        # type: (float, int, int) -> Mesh
        result = _GenMeshPlane(float(width), float(length), int(res_x), int(res_z))
        return result

    @classmethod
    def gen_cube(cls, width: float, height: float, length: float):
        # type: (float, float) -> Mesh
        result = _GenMeshCube(float(width), float(height), float(length))
        return result

    @classmethod
    def gen_sphere(cls, radius: float, rings: int, slices: int):
        # type: (int, int) -> Mesh
        result = _GenMeshSphere(float(radius), int(rings), int(slices))
        return result

    @classmethod
    def gen_hemi_sphere(cls, radius: float, rings: int, slices: int):
        # type: (int, int) -> Mesh
        result = _GenMeshHemiSphere(float(radius), int(rings), int(slices))
        return result

    @classmethod
    def gen_cylinder(cls, radius: float, height: float, slices: int):
        # type: (float, int) -> Mesh
        result = _GenMeshCylinder(float(radius), float(height), int(slices))
        return result

    @classmethod
    def gen_cone(cls, radius: float, height: float, slices: int):
        # type: (float, int) -> Mesh
        result = _GenMeshCone(float(radius), float(height), int(slices))
        return result

    @classmethod
    def gen_torus(cls, radius: float, size: float, rad_seg: int, sides: int):
        # type: (float, int, int) -> Mesh
        result = _GenMeshTorus(float(radius), float(size), int(rad_seg), int(sides))
        return result

    @classmethod
    def gen_knot(cls, radius: float, size: float, rad_seg: int, sides: int):
        # type: (float, int, int) -> Mesh
        result = _GenMeshKnot(float(radius), float(size), int(rad_seg), int(sides))
        return result

    @classmethod
    def gen_heightmap(cls, heightmap: Image, size: Vector3):
        # type: (Vector3) -> Mesh
        result = _GenMeshHeightmap(heightmap, size)
        return result

    @classmethod
    def gen_cubicmap(cls, cubicmap: Image, cube_size: Vector3):
        # type: (Vector3) -> Mesh
        result = _GenMeshCubicmap(cubicmap, cube_size)
        return result


# Pointer type to Meshs
MeshPtr = POINTER(Mesh)



class Shader(Structure):
    '''Shader'''
    _fields_ = [
        ('id', UInt),
        ('locs', IntPtr),
    ]

    @classmethod
    def array_of(cls, shader_sequence):
        '''Creates and returns an array of Shaders'''
        arr = cls * len(shader_sequence)
        return arr(*shader_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Shader'''
        return cls(0, None)

    def __init__(self, id, locs):
        '''Shader

        :param int id: `unsigned int` in C raylib
        :param Sequence[int] locs: `int *` in C raylib
        '''
        super(Shader, self).__init__(id, locs)

    def __str__(self):
        return "[Shader at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Shader instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def get_location(self, uniform_name: bytes):
        # type: (bytes) -> int
        result = _GetShaderLocation(self, _str_in(uniform_name))
        return result

    def get_location_attrib(self, attrib_name: bytes):
        # type: (bytes) -> int
        result = _GetShaderLocationAttrib(self, _str_in(attrib_name))
        return result

    def set_value(self, loc_index: int, value: bytes, uniform_type: int):
        # type: (int, bytes, int) -> None
        _SetShaderValue(self, int(loc_index), value_ref, int(uniform_type))

    def set_value_v(self, loc_index: int, value: bytes, uniform_type: int, count: int):
        # type: (int, bytes, int, int) -> None
        _SetShaderValueV(self, int(loc_index), value_ref, int(uniform_type), int(count))

    def set_value_matrix(self, loc_index: int, mat: Matrix):
        # type: (int, Matrix) -> None
        _SetShaderValueMatrix(self, int(loc_index), mat)

    def set_value_texture(self, loc_index: int, texture: Texture2D):
        # type: (int, Texture2D) -> None
        _SetShaderValueTexture(self, int(loc_index), texture)

    def unload(self):
        # type: () -> None
        _UnloadShader(self)

    @classmethod
    def load(cls, vs_file_name: bytes, fs_file_name: bytes):
        # type: (bytes) -> Shader
        result = _LoadShader(_str_in(vs_file_name), _str_in(fs_file_name))
        return result

    @classmethod
    def load_from_memory(cls, vs_code: bytes, fs_code: bytes):
        # type: (bytes) -> Shader
        result = _LoadShaderFromMemory(_str_in(vs_code), _str_in(fs_code))
        return result


# Pointer type to Shaders
ShaderPtr = POINTER(Shader)



class MaterialMap(Structure):
    '''MaterialMap'''
    _fields_ = [
        ('texture', Texture2D),
        ('color', Color),
        ('value', Float),
    ]

    @classmethod
    def array_of(cls, material_map_sequence):
        '''Creates and returns an array of MaterialMaps'''
        arr = cls * len(material_map_sequence)
        return arr(*material_map_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized MaterialMap'''
        return cls(Texture2D.zero(), Color.zero(), 0.0)

    def __init__(self, texture, color, value):
        '''MaterialMap

        :param Texture2D texture: `Texture2D` in C raylib
        :param Color color: `Color` in C raylib
        :param float value: `float` in C raylib
        '''
        super(MaterialMap, self).__init__(texture, color, value)

    def __str__(self):
        return "[MaterialMap at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this MaterialMap instance'''
        return byref(self)


# Pointer type to MaterialMaps
MaterialMapPtr = POINTER(MaterialMap)



class Material(Structure):
    '''Material, includes shader and maps'''
    _fields_ = [
        ('shader', Shader),
        ('maps', MaterialMapPtr),
        ('params', Float * 4),
    ]

    @classmethod
    def array_of(cls, material_sequence):
        '''Creates and returns an array of Materials'''
        arr = cls * len(material_sequence)
        return arr(*material_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Material'''
        return cls(Shader.zero(), MaterialMap.zero(), None)

    def __init__(self, shader, maps, params):
        '''Material, includes shader and maps

        :param Shader shader: `Shader` in C raylib
        :param MaterialMapPtr maps: `MaterialMap *` in C raylib
        :param Sequence[float] params: `float[4]` in C raylib
        '''
        super(Material, self).__init__(shader, maps, params)

    def __str__(self):
        return "[Material at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Material instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def unload(self):
        # type: () -> None
        _UnloadMaterial(self)

    def set_texture(self, map_type: int, texture: Texture2D):
        # type: (int, Texture2D) -> None
        _SetMaterialTexture(self, int(map_type), texture)

    @classmethod
    def load_materials(cls, file_name: bytes, material_count: Sequence[int]):
        # type: (Sequence[int]) -> MaterialPtr
        result = _LoadMaterials(_str_in(file_name), material_count_ref)
        return result


# Pointer type to Materials
MaterialPtr = POINTER(Material)



class Transform(Structure):
    '''Transform, vectex transformation data'''
    _fields_ = [
        ('translation', Vector3),
        ('rotation', Quaternion),
        ('scale', Vector3),
    ]

    @classmethod
    def array_of(cls, transform_sequence):
        '''Creates and returns an array of Transforms'''
        arr = cls * len(transform_sequence)
        return arr(*transform_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Transform'''
        return cls(Vector3.zero(), Quaternion.zero(), Vector3.zero())

    def __init__(self, translation, rotation, scale):
        '''Transform, vectex transformation data

        :param Vector3 translation: `Vector3` in C raylib
        :param Quaternion rotation: `Quaternion` in C raylib
        :param Vector3 scale: `Vector3` in C raylib
        '''
        super(Transform, self).__init__(translation, rotation, scale)

    def __str__(self):
        return "[Transform at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Transform instance'''
        return byref(self)


# Pointer type to Transforms
TransformPtr = POINTER(Transform)



class BoneInfo(Structure):
    '''Bone, skeletal animation bone'''
    _fields_ = [
        ('name', Char * 32),
        ('parent', Int),
    ]

    @classmethod
    def array_of(cls, bone_info_sequence):
        '''Creates and returns an array of BoneInfos'''
        arr = cls * len(bone_info_sequence)
        return arr(*bone_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized BoneInfo'''
        return cls(None, 0)

    def __init__(self, name, parent):
        '''Bone, skeletal animation bone

        :param Sequence[bytes] name: `char[32]` in C raylib
        :param int parent: `int` in C raylib
        '''
        super(BoneInfo, self).__init__(name, parent)

    def __str__(self):
        return "[BoneInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this BoneInfo instance'''
        return byref(self)


# Pointer type to BoneInfos
BoneInfoPtr = POINTER(BoneInfo)



class Model(Structure):
    '''Model, meshes, materials and animation data'''
    _fields_ = [
        ('transform', Matrix),
        ('mesh_count', Int),
        ('material_count', Int),
        ('meshes', MeshPtr),
        ('materials', MaterialPtr),
        ('mesh_material', IntPtr),
        ('bone_count', Int),
        ('bones', BoneInfoPtr),
        ('bind_pose', TransformPtr),
    ]

    @classmethod
    def array_of(cls, model_sequence):
        '''Creates and returns an array of Models'''
        arr = cls * len(model_sequence)
        return arr(*model_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Model'''
        return cls(Matrix.zero(), 0, 0, Mesh.zero(), Material.zero(), None, 0, BoneInfo.zero(), Transform.zero())

    def __init__(self, transform, mesh_count, material_count, meshes, materials, mesh_material, bone_count, bones, bind_pose):
        '''Model, meshes, materials and animation data

        :param Matrix transform: `Matrix` in C raylib
        :param int meshCount: `int` in C raylib
        :param int materialCount: `int` in C raylib
        :param MeshPtr meshes: `Mesh *` in C raylib
        :param MaterialPtr materials: `Material *` in C raylib
        :param Sequence[int] meshMaterial: `int *` in C raylib
        :param int boneCount: `int` in C raylib
        :param BoneInfoPtr bones: `BoneInfo *` in C raylib
        :param TransformPtr bindPose: `Transform *` in C raylib
        '''
        super(Model, self).__init__(transform, mesh_count, material_count, meshes, materials, mesh_material, bone_count, bones, bind_pose)

    def __str__(self):
        return "[Model at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Model instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def is_animation_valid(self, anim: ModelAnimation):
        # type: (ModelAnimation) -> bool
        result = _IsModelAnimationValid(self, anim)
        return result

    def update_animation(self, anim: ModelAnimation, frame: int):
        # type: (ModelAnimation, int) -> None
        _UpdateModelAnimation(self, anim, int(frame))

    def set_mesh_material(self, mesh_id: int, material_id: int):
        # type: (int, int) -> None
        _SetModelMeshMaterial(self.byref, int(mesh_id), int(material_id))

    def unload(self):
        # type: () -> None
        _UnloadModel(self)

    def unload_keep_meshes(self):
        # type: () -> None
        _UnloadModelKeepMeshes(self)

    def get_bounding_box(self):
        # type: () -> BoundingBox
        result = _GetModelBoundingBox(self)
        return result

    def draw(self, position: Vector3, scale: float, tint: Color):
        # type: (Vector3, float, Color) -> None
        _DrawModel(self, position, float(scale), tint)

    def draw_ex(self, position: Vector3, rotation_axis: Vector3, rotation_angle: float, scale: Vector3, tint: Color):
        # type: (Vector3, Vector3, float, Vector3, Color) -> None
        _DrawModelEx(self, position, rotation_axis, float(rotation_angle), scale, tint)

    def draw_wires(self, position: Vector3, scale: float, tint: Color):
        # type: (Vector3, float, Color) -> None
        _DrawModelWires(self, position, float(scale), tint)

    def draw_wires_ex(self, position: Vector3, rotation_axis: Vector3, rotation_angle: float, scale: Vector3, tint: Color):
        # type: (Vector3, Vector3, float, Vector3, Color) -> None
        _DrawModelWiresEx(self, position, rotation_axis, float(rotation_angle), scale, tint)

    @classmethod
    def load(cls, file_name: bytes):
        # type: () -> Model
        result = _LoadModel(_str_in(file_name))
        return result

    @classmethod
    def load_from_mesh(cls, mesh: Mesh):
        # type: () -> Model
        result = _LoadModelFromMesh(mesh)
        return result


# Pointer type to Models
ModelPtr = POINTER(Model)



class ModelAnimation(Structure):
    '''ModelAnimation'''
    _fields_ = [
        ('bone_count', Int),
        ('frame_count', Int),
        ('bones', BoneInfoPtr),
        ('frame_poses', POINTER(TransformPtr)),
    ]

    @classmethod
    def array_of(cls, model_animation_sequence):
        '''Creates and returns an array of ModelAnimations'''
        arr = cls * len(model_animation_sequence)
        return arr(*model_animation_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized ModelAnimation'''
        return cls(0, 0, BoneInfo.zero(), Transform.zero())

    def __init__(self, bone_count, frame_count, bones, frame_poses):
        '''ModelAnimation

        :param int boneCount: `int` in C raylib
        :param int frameCount: `int` in C raylib
        :param BoneInfoPtr bones: `BoneInfo *` in C raylib
        :param Sequence[TransformPtr] framePoses: `Transform **` in C raylib
        '''
        super(ModelAnimation, self).__init__(bone_count, frame_count, bones, frame_poses)

    def __str__(self):
        return "[ModelAnimation at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this ModelAnimation instance'''
        return byref(self)


# Pointer type to ModelAnimations
ModelAnimationPtr = POINTER(ModelAnimation)



class Ray(Structure):
    '''Ray, ray for raycasting'''
    _fields_ = [
        ('position', Vector3),
        ('direction', Vector3),
    ]

    @classmethod
    def array_of(cls, ray_sequence):
        '''Creates and returns an array of Rays'''
        arr = cls * len(ray_sequence)
        return arr(*ray_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Ray'''
        return cls(Vector3.zero(), Vector3.zero())

    def __init__(self, position, direction):
        '''Ray, ray for raycasting

        :param Vector3 position: `Vector3` in C raylib
        :param Vector3 direction: `Vector3` in C raylib
        '''
        super(Ray, self).__init__(position, direction)

    def __str__(self):
        return "[Ray at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Ray instance'''
        return byref(self)


# Pointer type to Rays
RayPtr = POINTER(Ray)



class RayCollision(Structure):
    '''RayCollision, ray hit information'''
    _fields_ = [
        ('hit', Bool),
        ('distance', Float),
        ('point', Vector3),
        ('normal', Vector3),
    ]

    @classmethod
    def array_of(cls, ray_collision_sequence):
        '''Creates and returns an array of RayCollisions'''
        arr = cls * len(ray_collision_sequence)
        return arr(*ray_collision_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized RayCollision'''
        return cls(0, 0.0, Vector3.zero(), Vector3.zero())

    def __init__(self, hit, distance, point, normal):
        '''RayCollision, ray hit information

        :param bool hit: `bool` in C raylib
        :param float distance: `float` in C raylib
        :param Vector3 point: `Vector3` in C raylib
        :param Vector3 normal: `Vector3` in C raylib
        '''
        super(RayCollision, self).__init__(hit, distance, point, normal)

    def __str__(self):
        return "[RayCollision at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this RayCollision instance'''
        return byref(self)


# Pointer type to RayCollisions
RayCollisionPtr = POINTER(RayCollision)



class BoundingBox(Structure):
    '''BoundingBox'''
    _fields_ = [
        ('min', Vector3),
        ('max', Vector3),
    ]

    @classmethod
    def array_of(cls, bounding_box_sequence):
        '''Creates and returns an array of BoundingBoxs'''
        arr = cls * len(bounding_box_sequence)
        return arr(*bounding_box_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized BoundingBox'''
        return cls(Vector3.zero(), Vector3.zero())

    def __init__(self, min, max):
        '''BoundingBox

        :param Vector3 min: `Vector3` in C raylib
        :param Vector3 max: `Vector3` in C raylib
        '''
        super(BoundingBox, self).__init__(min, max)

    def __str__(self):
        return "[BoundingBox at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this BoundingBox instance'''
        return byref(self)


# Pointer type to BoundingBoxs
BoundingBoxPtr = POINTER(BoundingBox)



class Wave(Structure):
    '''Wave, audio wave data'''
    _fields_ = [
        ('frame_count', UInt),
        ('sample_rate', UInt),
        ('sample_size', UInt),
        ('channels', UInt),
        ('data', VoidPtr),
    ]

    @classmethod
    def array_of(cls, wave_sequence):
        '''Creates and returns an array of Waves'''
        arr = cls * len(wave_sequence)
        return arr(*wave_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Wave'''
        return cls(0, 0, 0, 0, None)

    def __init__(self, frame_count, sample_rate, sample_size, channels, data):
        '''Wave, audio wave data

        :param int frameCount: `unsigned int` in C raylib
        :param int sampleRate: `unsigned int` in C raylib
        :param int sampleSize: `unsigned int` in C raylib
        :param int channels: `unsigned int` in C raylib
        :param bytes data: `void *` in C raylib
        '''
        super(Wave, self).__init__(frame_count, sample_rate, sample_size, channels, data)

    def __str__(self):
        return "[Wave at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Wave instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def copy(self):
        # type: () -> Wave
        result = _WaveCopy(self)
        return result

    def crop(self, init_sample: int, final_sample: int):
        # type: (int, int) -> None
        _WaveCrop(self.byref, int(init_sample), int(final_sample))

    def format(self, sample_rate: int, sample_size: int, channels: int):
        # type: (int, int, int) -> None
        _WaveFormat(self.byref, int(sample_rate), int(sample_size), int(channels))

    def format(self):
        # type: () -> Sequence[float]
        result = _LoadWaveSamples(self.byref)
        return result

    def export(self, file_name: bytes):
        # type: (bytes) -> bool
        result = _ExportWave(self, _str_in(file_name))
        return result

    def export_as_code(self, file_name: bytes):
        # type: (bytes) -> bool
        result = _ExportWaveAsCode(self, _str_in(file_name))
        return result

    def unload(self):
        # type: () -> None
        _UnloadWave(self)

    def unload_samples(self):
        # type: () -> None
        _UnloadWaveSamples(self)

    @classmethod
    def load(cls, file_name: bytes):
        # type: () -> Wave
        result = _LoadWave(_str_in(file_name))
        return result

    @classmethod
    def load_from_memory(cls, file_type: bytes, file_data: bytes, data_size: int):
        # type: (bytes, int) -> Wave
        result = _LoadWaveFromMemory(_str_in(file_type), _str_in(file_data), int(data_size))
        return result


# Pointer type to Waves
WavePtr = POINTER(Wave)



class AudioStream(Structure):
    '''AudioStream, custom audio stream'''
    _fields_ = [
        ('buffer', VoidPtr),
        ('processor', VoidPtr),
        ('sample_rate', UInt),
        ('sample_size', UInt),
        ('channels', UInt),
    ]

    @classmethod
    def array_of(cls, audio_stream_sequence):
        '''Creates and returns an array of AudioStreams'''
        arr = cls * len(audio_stream_sequence)
        return arr(*audio_stream_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized AudioStream'''
        return cls(rAudioBuffer.zero(), rAudioProcessor.zero(), 0, 0, 0)

    def __init__(self, buffer, processor, sample_rate, sample_size, channels):
        '''AudioStream, custom audio stream

        :param bytes buffer: `rAudioBuffer *` in C raylib
        :param bytes processor: `rAudioProcessor *` in C raylib
        :param int sampleRate: `unsigned int` in C raylib
        :param int sampleSize: `unsigned int` in C raylib
        :param int channels: `unsigned int` in C raylib
        '''
        super(AudioStream, self).__init__(buffer, processor, sample_rate, sample_size, channels)

    def __str__(self):
        return "[AudioStream at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this AudioStream instance'''
        return byref(self)

    def __str__(self):
        return "[{} Playing: {}]".format(self.__class__.__name__, _IsAudioStreamPlaying(self))

    def __repr__(self):
        return self.__str__()

    def unload(self):
        # type: () -> None
        _UnloadAudioStream(self)

    def update(self, data: bytes, frame_count: int):
        # type: (bytes, int) -> None
        _UpdateAudioStream(self, data_ref, int(frame_count))

    def is_processed(self):
        # type: () -> bool
        result = _IsAudioStreamProcessed(self)
        return result

    def play(self):
        # type: () -> None
        _PlayAudioStream(self)

    def pause(self):
        # type: () -> None
        _PauseAudioStream(self)

    def resume(self):
        # type: () -> None
        _ResumeAudioStream(self)

    def is_playing(self):
        # type: () -> bool
        result = _IsAudioStreamPlaying(self)
        return result

    def stop(self):
        # type: () -> None
        _StopAudioStream(self)

    def set_volume(self, volume: float):
        # type: (float) -> None
        _SetAudioStreamVolume(self, float(volume))

    def set_pitch(self, pitch: float):
        # type: (float) -> None
        _SetAudioStreamPitch(self, float(pitch))

    def set_pan(self, pan: float):
        # type: (float) -> None
        _SetAudioStreamPan(self, float(pan))

    def set_buffer_size_default(self):
        # type: () -> None
        _SetAudioStreamBufferSizeDefault(self)

    def set_callback(self, callback: AudioCallback):
        # type: (AudioCallback) -> None
        _SetAudioStreamCallback(self, callback)

    def attach_processor(self, processor: AudioCallback):
        # type: (AudioCallback) -> None
        _AttachAudioStreamProcessor(self, processor)

    def detach_processor(self, processor: AudioCallback):
        # type: (AudioCallback) -> None
        _DetachAudioStreamProcessor(self, processor)

    @classmethod
    def load(cls, sample_rate: int, sample_size: int, channels: int):
        # type: (int, int) -> AudioStream
        result = _LoadAudioStream(int(sample_rate), int(sample_size), int(channels))
        return result


# Pointer type to AudioStreams
AudioStreamPtr = POINTER(AudioStream)



class Sound(Structure):
    '''Sound'''
    _fields_ = [
        ('stream', AudioStream),
        ('frame_count', UInt),
    ]

    @classmethod
    def array_of(cls, sound_sequence):
        '''Creates and returns an array of Sounds'''
        arr = cls * len(sound_sequence)
        return arr(*sound_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Sound'''
        return cls(AudioStream.zero(), 0)

    def __init__(self, stream, frame_count):
        '''Sound

        :param AudioStream stream: `AudioStream` in C raylib
        :param int frameCount: `unsigned int` in C raylib
        '''
        super(Sound, self).__init__(stream, frame_count)

    def __str__(self):
        return "[Sound at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Sound instance'''
        return byref(self)

    def __str__(self):
        return "[{} Playing: {}]".format(self.__class__.__name__, _IsSoundPlaying(self))

    def __repr__(self):
        return self.__str__()

    def play(self):
        # type: () -> None
        _PlaySound(self)

    def stop(self):
        # type: () -> None
        _StopSound(self)

    def pause(self):
        # type: () -> None
        _PauseSound(self)

    def resume(self):
        # type: () -> None
        _ResumeSound(self)

    def play_multi(self):
        # type: () -> None
        _PlaySoundMulti(self)

    def is_playing(self):
        # type: () -> bool
        result = _IsSoundPlaying(self)
        return result

    def set_volume(self, volume: float):
        # type: (float) -> None
        _SetSoundVolume(self, float(volume))

    def set_pitch(self, pitch: float):
        # type: (float) -> None
        _SetSoundPitch(self, float(pitch))

    def set_pan(self, pan: float):
        # type: (float) -> None
        _SetSoundPan(self, float(pan))

    def unload(self):
        # type: () -> None
        _UnloadSound(self)

    def update(self, data: bytes, sample_count: int):
        # type: (bytes, int) -> None
        _UpdateSound(self, data_ref, int(sample_count))

    @classmethod
    def load(cls, file_name: bytes):
        # type: () -> Sound
        result = _LoadSound(_str_in(file_name))
        return result

    @classmethod
    def load_from_wave(cls, wave: Wave):
        # type: () -> Sound
        result = _LoadSoundFromWave(wave)
        return result


# Pointer type to Sounds
SoundPtr = POINTER(Sound)



class Music(Structure):
    '''Music, audio stream, anything longer than ~10 seconds should be streamed'''
    _fields_ = [
        ('stream', AudioStream),
        ('frame_count', UInt),
        ('looping', Bool),
        ('ctx_type', Int),
        ('ctx_data', VoidPtr),
    ]

    @classmethod
    def array_of(cls, music_sequence):
        '''Creates and returns an array of Musics'''
        arr = cls * len(music_sequence)
        return arr(*music_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized Music'''
        return cls(AudioStream.zero(), 0, 0, 0, None)

    def __init__(self, stream, frame_count, looping, ctx_type, ctx_data):
        '''Music, audio stream, anything longer than ~10 seconds should be streamed

        :param AudioStream stream: `AudioStream` in C raylib
        :param int frameCount: `unsigned int` in C raylib
        :param bool looping: `bool` in C raylib
        :param int ctxType: `int` in C raylib
        :param bytes ctxData: `void *` in C raylib
        '''
        super(Music, self).__init__(stream, frame_count, looping, ctx_type, ctx_data)

    def __str__(self):
        return "[Music at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this Music instance'''
        return byref(self)

    def __str__(self):
        return "[{} at {}]".format(self.__class__.__name__, id(self))

    def __repr__(self):
        return self.__str__()

    def play(self):
        # type: () -> None
        _PlayMusicStream(self)

    def is_playing(self):
        # type: () -> bool
        result = _IsMusicStreamPlaying(self)
        return result

    def update(self):
        # type: () -> None
        _UpdateMusicStream(self)

    def stop(self):
        # type: () -> None
        _StopMusicStream(self)

    def pause(self):
        # type: () -> None
        _PauseMusicStream(self)

    def resume(self):
        # type: () -> None
        _ResumeMusicStream(self)

    def seek(self, position: float):
        # type: (float) -> None
        _SeekMusicStream(self, float(position))

    def set_volume(self, volume: float):
        # type: (float) -> None
        _SetMusicVolume(self, float(volume))

    def set_pitch(self, pitch: float):
        # type: (float) -> None
        _SetMusicPitch(self, float(pitch))

    def set_pan(self, pan: float):
        # type: (float) -> None
        _SetMusicPan(self, float(pan))

    def get_time_length(self):
        # type: () -> float
        result = _GetMusicTimeLength(self)
        return result

    def get_time_played(self):
        # type: () -> float
        result = _GetMusicTimePlayed(self)
        return result


# Pointer type to Musics
MusicPtr = POINTER(Music)



class VrDeviceInfo(Structure):
    '''VrDeviceInfo, Head-Mounted-Display device parameters'''
    _fields_ = [
        ('h_resolution', Int),
        ('v_resolution', Int),
        ('h_screen_size', Float),
        ('v_screen_size', Float),
        ('v_screen_center', Float),
        ('eye_to_screen_distance', Float),
        ('lens_separation_distance', Float),
        ('interpupillary_distance', Float),
        ('lens_distortion_values', Float * 4),
        ('chroma_ab_correction', Float * 4),
    ]

    @classmethod
    def array_of(cls, vr_device_info_sequence):
        '''Creates and returns an array of VrDeviceInfos'''
        arr = cls * len(vr_device_info_sequence)
        return arr(*vr_device_info_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized VrDeviceInfo'''
        return cls(0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, None, None)

    def __init__(self, h_resolution, v_resolution, h_screen_size, v_screen_size, v_screen_center, eye_to_screen_distance, lens_separation_distance, interpupillary_distance, lens_distortion_values, chroma_ab_correction):
        '''VrDeviceInfo, Head-Mounted-Display device parameters

        :param int hResolution: `int` in C raylib
        :param int vResolution: `int` in C raylib
        :param float hScreenSize: `float` in C raylib
        :param float vScreenSize: `float` in C raylib
        :param float vScreenCenter: `float` in C raylib
        :param float eyeToScreenDistance: `float` in C raylib
        :param float lensSeparationDistance: `float` in C raylib
        :param float interpupillaryDistance: `float` in C raylib
        :param Sequence[float] lensDistortionValues: `float[4]` in C raylib
        :param Sequence[float] chromaAbCorrection: `float[4]` in C raylib
        '''
        super(VrDeviceInfo, self).__init__(h_resolution, v_resolution, h_screen_size, v_screen_size, v_screen_center, eye_to_screen_distance, lens_separation_distance, interpupillary_distance, lens_distortion_values, chroma_ab_correction)

    def __str__(self):
        return "[VrDeviceInfo at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this VrDeviceInfo instance'''
        return byref(self)


# Pointer type to VrDeviceInfos
VrDeviceInfoPtr = POINTER(VrDeviceInfo)



class VrStereoConfig(Structure):
    '''VrStereoConfig, VR stereo rendering configuration for simulator'''
    _fields_ = [
        ('projection', Matrix * 2),
        ('view_offset', Matrix * 2),
        ('left_lens_center', Float * 2),
        ('right_lens_center', Float * 2),
        ('left_screen_center', Float * 2),
        ('right_screen_center', Float * 2),
        ('scale', Float * 2),
        ('scale_in', Float * 2),
    ]

    @classmethod
    def array_of(cls, vr_stereo_config_sequence):
        '''Creates and returns an array of VrStereoConfigs'''
        arr = cls * len(vr_stereo_config_sequence)
        return arr(*vr_stereo_config_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized VrStereoConfig'''
        return cls(Matrix.zero(), Matrix.zero(), None, None, None, None, None, None)

    def __init__(self, projection, view_offset, left_lens_center, right_lens_center, left_screen_center, right_screen_center, scale, scale_in):
        '''VrStereoConfig, VR stereo rendering configuration for simulator

        :param Sequence[Matrix] projection: `Matrix[2]` in C raylib
        :param Sequence[Matrix] viewOffset: `Matrix[2]` in C raylib
        :param Sequence[float] leftLensCenter: `float[2]` in C raylib
        :param Sequence[float] rightLensCenter: `float[2]` in C raylib
        :param Sequence[float] leftScreenCenter: `float[2]` in C raylib
        :param Sequence[float] rightScreenCenter: `float[2]` in C raylib
        :param Sequence[float] scale: `float[2]` in C raylib
        :param Sequence[float] scaleIn: `float[2]` in C raylib
        '''
        super(VrStereoConfig, self).__init__(projection, view_offset, left_lens_center, right_lens_center, left_screen_center, right_screen_center, scale, scale_in)

    def __str__(self):
        return "[VrStereoConfig at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this VrStereoConfig instance'''
        return byref(self)


# Pointer type to VrStereoConfigs
VrStereoConfigPtr = POINTER(VrStereoConfig)



class FilePathList(Structure):
    '''File path list'''
    _fields_ = [
        ('capacity', UInt),
        ('count', UInt),
        ('paths', POINTER(CharPtr)),
    ]

    @classmethod
    def array_of(cls, file_path_list_sequence):
        '''Creates and returns an array of FilePathLists'''
        arr = cls * len(file_path_list_sequence)
        return arr(*file_path_list_sequence)

    @classmethod
    def zero(cls):
        '''Creates and returns a zero initialized FilePathList'''
        return cls(0, 0, None)

    def __init__(self, capacity, count, paths):
        '''File path list

        :param int capacity: `unsigned int` in C raylib
        :param int count: `unsigned int` in C raylib
        :param Sequence[bytes] paths: `char **` in C raylib
        '''
        super(FilePathList, self).__init__(capacity, count, paths)

    def __str__(self):
        return "[FilePathList at {}]".format(id(self))

    @property
    def byref(self):
        '''Gets a reference to this FilePathList instance'''
        return byref(self)


# Pointer type to FilePathLists
FilePathListPtr = POINTER(FilePathList)



# endregion (types)
# region CONSTANTS AND ENUMS


class ConfigFlags(IntEnum):
    FLAG_VSYNC_HINT = 64
    FLAG_FULLSCREEN_MODE = 2
    FLAG_WINDOW_RESIZABLE = 4
    FLAG_WINDOW_UNDECORATED = 8
    FLAG_WINDOW_HIDDEN = 128
    FLAG_WINDOW_MINIMIZED = 512
    FLAG_WINDOW_MAXIMIZED = 1024
    FLAG_WINDOW_UNFOCUSED = 2048
    FLAG_WINDOW_TOPMOST = 4096
    FLAG_WINDOW_ALWAYS_RUN = 256
    FLAG_WINDOW_TRANSPARENT = 16
    FLAG_WINDOW_HIGHDPI = 8192
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384
    FLAG_MSAA_4X_HINT = 32
    FLAG_INTERLACED_HINT = 65536


# Set to try enabling V-Sync on GPU
FLAG_VSYNC_HINT = ConfigFlags.FLAG_VSYNC_HINT
# Set to run program in fullscreen
FLAG_FULLSCREEN_MODE = ConfigFlags.FLAG_FULLSCREEN_MODE
# Set to allow resizable window
FLAG_WINDOW_RESIZABLE = ConfigFlags.FLAG_WINDOW_RESIZABLE
# Set to disable window decoration (frame and buttons)
FLAG_WINDOW_UNDECORATED = ConfigFlags.FLAG_WINDOW_UNDECORATED
# Set to hide window
FLAG_WINDOW_HIDDEN = ConfigFlags.FLAG_WINDOW_HIDDEN
# Set to minimize window (iconify)
FLAG_WINDOW_MINIMIZED = ConfigFlags.FLAG_WINDOW_MINIMIZED
# Set to maximize window (expanded to monitor)
FLAG_WINDOW_MAXIMIZED = ConfigFlags.FLAG_WINDOW_MAXIMIZED
# Set to window non focused
FLAG_WINDOW_UNFOCUSED = ConfigFlags.FLAG_WINDOW_UNFOCUSED
# Set to window always on top
FLAG_WINDOW_TOPMOST = ConfigFlags.FLAG_WINDOW_TOPMOST
# Set to allow windows running while minimized
FLAG_WINDOW_ALWAYS_RUN = ConfigFlags.FLAG_WINDOW_ALWAYS_RUN
# Set to allow transparent framebuffer
FLAG_WINDOW_TRANSPARENT = ConfigFlags.FLAG_WINDOW_TRANSPARENT
# Set to support HighDPI
FLAG_WINDOW_HIGHDPI = ConfigFlags.FLAG_WINDOW_HIGHDPI
# Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
FLAG_WINDOW_MOUSE_PASSTHROUGH = ConfigFlags.FLAG_WINDOW_MOUSE_PASSTHROUGH
# Set to try enabling MSAA 4X
FLAG_MSAA_4X_HINT = ConfigFlags.FLAG_MSAA_4X_HINT
# Set to try enabling interlaced video format (for V3D)
FLAG_INTERLACED_HINT = ConfigFlags.FLAG_INTERLACED_HINT


class TraceLogLevel(IntEnum):
    LOG_ALL = 0
    LOG_TRACE = 1
    LOG_DEBUG = 2
    LOG_INFO = 3
    LOG_WARNING = 4
    LOG_ERROR = 5
    LOG_FATAL = 6
    LOG_NONE = 7


# Display all logs
LOG_ALL = TraceLogLevel.LOG_ALL
# Trace logging, intended for internal use only
LOG_TRACE = TraceLogLevel.LOG_TRACE
# Debug logging, used for internal debugging, it should be disabled on release builds
LOG_DEBUG = TraceLogLevel.LOG_DEBUG
# Info logging, used for program execution info
LOG_INFO = TraceLogLevel.LOG_INFO
# Warning logging, used on recoverable failures
LOG_WARNING = TraceLogLevel.LOG_WARNING
# Error logging, used on unrecoverable failures
LOG_ERROR = TraceLogLevel.LOG_ERROR
# Fatal logging, used to abort program: exit(EXIT_FAILURE)
LOG_FATAL = TraceLogLevel.LOG_FATAL
# Disable logging
LOG_NONE = TraceLogLevel.LOG_NONE


class KeyboardKey(IntEnum):
    KEY_NULL = 0
    KEY_APOSTROPHE = 39
    KEY_COMMA = 44
    KEY_MINUS = 45
    KEY_PERIOD = 46
    KEY_SLASH = 47
    KEY_ZERO = 48
    KEY_ONE = 49
    KEY_TWO = 50
    KEY_THREE = 51
    KEY_FOUR = 52
    KEY_FIVE = 53
    KEY_SIX = 54
    KEY_SEVEN = 55
    KEY_EIGHT = 56
    KEY_NINE = 57
    KEY_SEMICOLON = 59
    KEY_EQUAL = 61
    KEY_A = 65
    KEY_B = 66
    KEY_C = 67
    KEY_D = 68
    KEY_E = 69
    KEY_F = 70
    KEY_G = 71
    KEY_H = 72
    KEY_I = 73
    KEY_J = 74
    KEY_K = 75
    KEY_L = 76
    KEY_M = 77
    KEY_N = 78
    KEY_O = 79
    KEY_P = 80
    KEY_Q = 81
    KEY_R = 82
    KEY_S = 83
    KEY_T = 84
    KEY_U = 85
    KEY_V = 86
    KEY_W = 87
    KEY_X = 88
    KEY_Y = 89
    KEY_Z = 90
    KEY_LEFT_BRACKET = 91
    KEY_BACKSLASH = 92
    KEY_RIGHT_BRACKET = 93
    KEY_GRAVE = 96
    KEY_SPACE = 32
    KEY_ESCAPE = 256
    KEY_ENTER = 257
    KEY_TAB = 258
    KEY_BACKSPACE = 259
    KEY_INSERT = 260
    KEY_DELETE = 261
    KEY_RIGHT = 262
    KEY_LEFT = 263
    KEY_DOWN = 264
    KEY_UP = 265
    KEY_PAGE_UP = 266
    KEY_PAGE_DOWN = 267
    KEY_HOME = 268
    KEY_END = 269
    KEY_CAPS_LOCK = 280
    KEY_SCROLL_LOCK = 281
    KEY_NUM_LOCK = 282
    KEY_PRINT_SCREEN = 283
    KEY_PAUSE = 284
    KEY_F1 = 290
    KEY_F2 = 291
    KEY_F3 = 292
    KEY_F4 = 293
    KEY_F5 = 294
    KEY_F6 = 295
    KEY_F7 = 296
    KEY_F8 = 297
    KEY_F9 = 298
    KEY_F10 = 299
    KEY_F11 = 300
    KEY_F12 = 301
    KEY_LEFT_SHIFT = 340
    KEY_LEFT_CONTROL = 341
    KEY_LEFT_ALT = 342
    KEY_LEFT_SUPER = 343
    KEY_RIGHT_SHIFT = 344
    KEY_RIGHT_CONTROL = 345
    KEY_RIGHT_ALT = 346
    KEY_RIGHT_SUPER = 347
    KEY_KB_MENU = 348
    KEY_KP_0 = 320
    KEY_KP_1 = 321
    KEY_KP_2 = 322
    KEY_KP_3 = 323
    KEY_KP_4 = 324
    KEY_KP_5 = 325
    KEY_KP_6 = 326
    KEY_KP_7 = 327
    KEY_KP_8 = 328
    KEY_KP_9 = 329
    KEY_KP_DECIMAL = 330
    KEY_KP_DIVIDE = 331
    KEY_KP_MULTIPLY = 332
    KEY_KP_SUBTRACT = 333
    KEY_KP_ADD = 334
    KEY_KP_ENTER = 335
    KEY_KP_EQUAL = 336
    KEY_BACK = 4
    KEY_MENU = 82
    KEY_VOLUME_UP = 24
    KEY_VOLUME_DOWN = 25


# Key: NULL, used for no key pressed
KEY_NULL = KeyboardKey.KEY_NULL
# Key: '
KEY_APOSTROPHE = KeyboardKey.KEY_APOSTROPHE
# Key: ,
KEY_COMMA = KeyboardKey.KEY_COMMA
# Key: -
KEY_MINUS = KeyboardKey.KEY_MINUS
# Key: .
KEY_PERIOD = KeyboardKey.KEY_PERIOD
# Key: /
KEY_SLASH = KeyboardKey.KEY_SLASH
# Key: 0
KEY_ZERO = KeyboardKey.KEY_ZERO
# Key: 1
KEY_ONE = KeyboardKey.KEY_ONE
# Key: 2
KEY_TWO = KeyboardKey.KEY_TWO
# Key: 3
KEY_THREE = KeyboardKey.KEY_THREE
# Key: 4
KEY_FOUR = KeyboardKey.KEY_FOUR
# Key: 5
KEY_FIVE = KeyboardKey.KEY_FIVE
# Key: 6
KEY_SIX = KeyboardKey.KEY_SIX
# Key: 7
KEY_SEVEN = KeyboardKey.KEY_SEVEN
# Key: 8
KEY_EIGHT = KeyboardKey.KEY_EIGHT
# Key: 9
KEY_NINE = KeyboardKey.KEY_NINE
# Key: ;
KEY_SEMICOLON = KeyboardKey.KEY_SEMICOLON
# Key: =
KEY_EQUAL = KeyboardKey.KEY_EQUAL
# Key: A | a
KEY_A = KeyboardKey.KEY_A
# Key: B | b
KEY_B = KeyboardKey.KEY_B
# Key: C | c
KEY_C = KeyboardKey.KEY_C
# Key: D | d
KEY_D = KeyboardKey.KEY_D
# Key: E | e
KEY_E = KeyboardKey.KEY_E
# Key: F | f
KEY_F = KeyboardKey.KEY_F
# Key: G | g
KEY_G = KeyboardKey.KEY_G
# Key: H | h
KEY_H = KeyboardKey.KEY_H
# Key: I | i
KEY_I = KeyboardKey.KEY_I
# Key: J | j
KEY_J = KeyboardKey.KEY_J
# Key: K | k
KEY_K = KeyboardKey.KEY_K
# Key: L | l
KEY_L = KeyboardKey.KEY_L
# Key: M | m
KEY_M = KeyboardKey.KEY_M
# Key: N | n
KEY_N = KeyboardKey.KEY_N
# Key: O | o
KEY_O = KeyboardKey.KEY_O
# Key: P | p
KEY_P = KeyboardKey.KEY_P
# Key: Q | q
KEY_Q = KeyboardKey.KEY_Q
# Key: R | r
KEY_R = KeyboardKey.KEY_R
# Key: S | s
KEY_S = KeyboardKey.KEY_S
# Key: T | t
KEY_T = KeyboardKey.KEY_T
# Key: U | u
KEY_U = KeyboardKey.KEY_U
# Key: V | v
KEY_V = KeyboardKey.KEY_V
# Key: W | w
KEY_W = KeyboardKey.KEY_W
# Key: X | x
KEY_X = KeyboardKey.KEY_X
# Key: Y | y
KEY_Y = KeyboardKey.KEY_Y
# Key: Z | z
KEY_Z = KeyboardKey.KEY_Z
# Key: [
KEY_LEFT_BRACKET = KeyboardKey.KEY_LEFT_BRACKET
# Key: '\'
KEY_BACKSLASH = KeyboardKey.KEY_BACKSLASH
# Key: ]
KEY_RIGHT_BRACKET = KeyboardKey.KEY_RIGHT_BRACKET
# Key: `
KEY_GRAVE = KeyboardKey.KEY_GRAVE
# Key: Space
KEY_SPACE = KeyboardKey.KEY_SPACE
# Key: Esc
KEY_ESCAPE = KeyboardKey.KEY_ESCAPE
# Key: Enter
KEY_ENTER = KeyboardKey.KEY_ENTER
# Key: Tab
KEY_TAB = KeyboardKey.KEY_TAB
# Key: Backspace
KEY_BACKSPACE = KeyboardKey.KEY_BACKSPACE
# Key: Ins
KEY_INSERT = KeyboardKey.KEY_INSERT
# Key: Del
KEY_DELETE = KeyboardKey.KEY_DELETE
# Key: Cursor right
KEY_RIGHT = KeyboardKey.KEY_RIGHT
# Key: Cursor left
KEY_LEFT = KeyboardKey.KEY_LEFT
# Key: Cursor down
KEY_DOWN = KeyboardKey.KEY_DOWN
# Key: Cursor up
KEY_UP = KeyboardKey.KEY_UP
# Key: Page up
KEY_PAGE_UP = KeyboardKey.KEY_PAGE_UP
# Key: Page down
KEY_PAGE_DOWN = KeyboardKey.KEY_PAGE_DOWN
# Key: Home
KEY_HOME = KeyboardKey.KEY_HOME
# Key: End
KEY_END = KeyboardKey.KEY_END
# Key: Caps lock
KEY_CAPS_LOCK = KeyboardKey.KEY_CAPS_LOCK
# Key: Scroll down
KEY_SCROLL_LOCK = KeyboardKey.KEY_SCROLL_LOCK
# Key: Num lock
KEY_NUM_LOCK = KeyboardKey.KEY_NUM_LOCK
# Key: Print screen
KEY_PRINT_SCREEN = KeyboardKey.KEY_PRINT_SCREEN
# Key: Pause
KEY_PAUSE = KeyboardKey.KEY_PAUSE
# Key: F1
KEY_F1 = KeyboardKey.KEY_F1
# Key: F2
KEY_F2 = KeyboardKey.KEY_F2
# Key: F3
KEY_F3 = KeyboardKey.KEY_F3
# Key: F4
KEY_F4 = KeyboardKey.KEY_F4
# Key: F5
KEY_F5 = KeyboardKey.KEY_F5
# Key: F6
KEY_F6 = KeyboardKey.KEY_F6
# Key: F7
KEY_F7 = KeyboardKey.KEY_F7
# Key: F8
KEY_F8 = KeyboardKey.KEY_F8
# Key: F9
KEY_F9 = KeyboardKey.KEY_F9
# Key: F10
KEY_F10 = KeyboardKey.KEY_F10
# Key: F11
KEY_F11 = KeyboardKey.KEY_F11
# Key: F12
KEY_F12 = KeyboardKey.KEY_F12
# Key: Shift left
KEY_LEFT_SHIFT = KeyboardKey.KEY_LEFT_SHIFT
# Key: Control left
KEY_LEFT_CONTROL = KeyboardKey.KEY_LEFT_CONTROL
# Key: Alt left
KEY_LEFT_ALT = KeyboardKey.KEY_LEFT_ALT
# Key: Super left
KEY_LEFT_SUPER = KeyboardKey.KEY_LEFT_SUPER
# Key: Shift right
KEY_RIGHT_SHIFT = KeyboardKey.KEY_RIGHT_SHIFT
# Key: Control right
KEY_RIGHT_CONTROL = KeyboardKey.KEY_RIGHT_CONTROL
# Key: Alt right
KEY_RIGHT_ALT = KeyboardKey.KEY_RIGHT_ALT
# Key: Super right
KEY_RIGHT_SUPER = KeyboardKey.KEY_RIGHT_SUPER
# Key: KB menu
KEY_KB_MENU = KeyboardKey.KEY_KB_MENU
# Key: Keypad 0
KEY_KP_0 = KeyboardKey.KEY_KP_0
# Key: Keypad 1
KEY_KP_1 = KeyboardKey.KEY_KP_1
# Key: Keypad 2
KEY_KP_2 = KeyboardKey.KEY_KP_2
# Key: Keypad 3
KEY_KP_3 = KeyboardKey.KEY_KP_3
# Key: Keypad 4
KEY_KP_4 = KeyboardKey.KEY_KP_4
# Key: Keypad 5
KEY_KP_5 = KeyboardKey.KEY_KP_5
# Key: Keypad 6
KEY_KP_6 = KeyboardKey.KEY_KP_6
# Key: Keypad 7
KEY_KP_7 = KeyboardKey.KEY_KP_7
# Key: Keypad 8
KEY_KP_8 = KeyboardKey.KEY_KP_8
# Key: Keypad 9
KEY_KP_9 = KeyboardKey.KEY_KP_9
# Key: Keypad .
KEY_KP_DECIMAL = KeyboardKey.KEY_KP_DECIMAL
# Key: Keypad /
KEY_KP_DIVIDE = KeyboardKey.KEY_KP_DIVIDE
# Key: Keypad *
KEY_KP_MULTIPLY = KeyboardKey.KEY_KP_MULTIPLY
# Key: Keypad -
KEY_KP_SUBTRACT = KeyboardKey.KEY_KP_SUBTRACT
# Key: Keypad +
KEY_KP_ADD = KeyboardKey.KEY_KP_ADD
# Key: Keypad Enter
KEY_KP_ENTER = KeyboardKey.KEY_KP_ENTER
# Key: Keypad =
KEY_KP_EQUAL = KeyboardKey.KEY_KP_EQUAL
# Key: Android back button
KEY_BACK = KeyboardKey.KEY_BACK
# Key: Android menu button
KEY_MENU = KeyboardKey.KEY_MENU
# Key: Android volume up button
KEY_VOLUME_UP = KeyboardKey.KEY_VOLUME_UP
# Key: Android volume down button
KEY_VOLUME_DOWN = KeyboardKey.KEY_VOLUME_DOWN


class MouseButton(IntEnum):
    MOUSE_BUTTON_LEFT = 0
    MOUSE_BUTTON_RIGHT = 1
    MOUSE_BUTTON_MIDDLE = 2
    MOUSE_BUTTON_SIDE = 3
    MOUSE_BUTTON_EXTRA = 4
    MOUSE_BUTTON_FORWARD = 5
    MOUSE_BUTTON_BACK = 6


# Mouse button left
MOUSE_BUTTON_LEFT = MouseButton.MOUSE_BUTTON_LEFT
# Mouse button right
MOUSE_BUTTON_RIGHT = MouseButton.MOUSE_BUTTON_RIGHT
# Mouse button middle (pressed wheel)
MOUSE_BUTTON_MIDDLE = MouseButton.MOUSE_BUTTON_MIDDLE
# Mouse button side (advanced mouse device)
MOUSE_BUTTON_SIDE = MouseButton.MOUSE_BUTTON_SIDE
# Mouse button extra (advanced mouse device)
MOUSE_BUTTON_EXTRA = MouseButton.MOUSE_BUTTON_EXTRA
# Mouse button fordward (advanced mouse device)
MOUSE_BUTTON_FORWARD = MouseButton.MOUSE_BUTTON_FORWARD
# Mouse button back (advanced mouse device)
MOUSE_BUTTON_BACK = MouseButton.MOUSE_BUTTON_BACK


class MouseCursor(IntEnum):
    MOUSE_CURSOR_DEFAULT = 0
    MOUSE_CURSOR_ARROW = 1
    MOUSE_CURSOR_IBEAM = 2
    MOUSE_CURSOR_CROSSHAIR = 3
    MOUSE_CURSOR_POINTING_HAND = 4
    MOUSE_CURSOR_RESIZE_EW = 5
    MOUSE_CURSOR_RESIZE_NS = 6
    MOUSE_CURSOR_RESIZE_NWSE = 7
    MOUSE_CURSOR_RESIZE_NESW = 8
    MOUSE_CURSOR_RESIZE_ALL = 9
    MOUSE_CURSOR_NOT_ALLOWED = 10


# Default pointer shape
MOUSE_CURSOR_DEFAULT = MouseCursor.MOUSE_CURSOR_DEFAULT
# Arrow shape
MOUSE_CURSOR_ARROW = MouseCursor.MOUSE_CURSOR_ARROW
# Text writing cursor shape
MOUSE_CURSOR_IBEAM = MouseCursor.MOUSE_CURSOR_IBEAM
# Cross shape
MOUSE_CURSOR_CROSSHAIR = MouseCursor.MOUSE_CURSOR_CROSSHAIR
# Pointing hand cursor
MOUSE_CURSOR_POINTING_HAND = MouseCursor.MOUSE_CURSOR_POINTING_HAND
# Horizontal resize/move arrow shape
MOUSE_CURSOR_RESIZE_EW = MouseCursor.MOUSE_CURSOR_RESIZE_EW
# Vertical resize/move arrow shape
MOUSE_CURSOR_RESIZE_NS = MouseCursor.MOUSE_CURSOR_RESIZE_NS
# Top-left to bottom-right diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NWSE = MouseCursor.MOUSE_CURSOR_RESIZE_NWSE
# The top-right to bottom-left diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NESW = MouseCursor.MOUSE_CURSOR_RESIZE_NESW
# The omni-directional resize/move cursor shape
MOUSE_CURSOR_RESIZE_ALL = MouseCursor.MOUSE_CURSOR_RESIZE_ALL
# The operation-not-allowed shape
MOUSE_CURSOR_NOT_ALLOWED = MouseCursor.MOUSE_CURSOR_NOT_ALLOWED


class GamepadButton(IntEnum):
    GAMEPAD_BUTTON_UNKNOWN = 0
    GAMEPAD_BUTTON_LEFT_FACE_UP = 1
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2
    GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3
    GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4
    GAMEPAD_BUTTON_RIGHT_FACE_UP = 5
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8
    GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9
    GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12
    GAMEPAD_BUTTON_MIDDLE_LEFT = 13
    GAMEPAD_BUTTON_MIDDLE = 14
    GAMEPAD_BUTTON_MIDDLE_RIGHT = 15
    GAMEPAD_BUTTON_LEFT_THUMB = 16
    GAMEPAD_BUTTON_RIGHT_THUMB = 17


# Unknown button, just for error checking
GAMEPAD_BUTTON_UNKNOWN = GamepadButton.GAMEPAD_BUTTON_UNKNOWN
# Gamepad left DPAD up button
GAMEPAD_BUTTON_LEFT_FACE_UP = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_UP
# Gamepad left DPAD right button
GAMEPAD_BUTTON_LEFT_FACE_RIGHT = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_RIGHT
# Gamepad left DPAD down button
GAMEPAD_BUTTON_LEFT_FACE_DOWN = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_DOWN
# Gamepad left DPAD left button
GAMEPAD_BUTTON_LEFT_FACE_LEFT = GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_LEFT
# Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
GAMEPAD_BUTTON_RIGHT_FACE_UP = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_UP
# Gamepad right button right (i.e. PS3: Square, Xbox: X)
GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_RIGHT
# Gamepad right button down (i.e. PS3: Cross, Xbox: A)
GAMEPAD_BUTTON_RIGHT_FACE_DOWN = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_DOWN
# Gamepad right button left (i.e. PS3: Circle, Xbox: B)
GAMEPAD_BUTTON_RIGHT_FACE_LEFT = GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_LEFT
# Gamepad top/back trigger left (first), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_1 = GamepadButton.GAMEPAD_BUTTON_LEFT_TRIGGER_1
# Gamepad top/back trigger left (second), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_2 = GamepadButton.GAMEPAD_BUTTON_LEFT_TRIGGER_2
# Gamepad top/back trigger right (one), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = GamepadButton.GAMEPAD_BUTTON_RIGHT_TRIGGER_1
# Gamepad top/back trigger right (second), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = GamepadButton.GAMEPAD_BUTTON_RIGHT_TRIGGER_2
# Gamepad center buttons, left one (i.e. PS3: Select)
GAMEPAD_BUTTON_MIDDLE_LEFT = GamepadButton.GAMEPAD_BUTTON_MIDDLE_LEFT
# Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
GAMEPAD_BUTTON_MIDDLE = GamepadButton.GAMEPAD_BUTTON_MIDDLE
# Gamepad center buttons, right one (i.e. PS3: Start)
GAMEPAD_BUTTON_MIDDLE_RIGHT = GamepadButton.GAMEPAD_BUTTON_MIDDLE_RIGHT
# Gamepad joystick pressed button left
GAMEPAD_BUTTON_LEFT_THUMB = GamepadButton.GAMEPAD_BUTTON_LEFT_THUMB
# Gamepad joystick pressed button right
GAMEPAD_BUTTON_RIGHT_THUMB = GamepadButton.GAMEPAD_BUTTON_RIGHT_THUMB


class GamepadAxis(IntEnum):
    GAMEPAD_AXIS_LEFT_X = 0
    GAMEPAD_AXIS_LEFT_Y = 1
    GAMEPAD_AXIS_RIGHT_X = 2
    GAMEPAD_AXIS_RIGHT_Y = 3
    GAMEPAD_AXIS_LEFT_TRIGGER = 4
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5


# Gamepad left stick X axis
GAMEPAD_AXIS_LEFT_X = GamepadAxis.GAMEPAD_AXIS_LEFT_X
# Gamepad left stick Y axis
GAMEPAD_AXIS_LEFT_Y = GamepadAxis.GAMEPAD_AXIS_LEFT_Y
# Gamepad right stick X axis
GAMEPAD_AXIS_RIGHT_X = GamepadAxis.GAMEPAD_AXIS_RIGHT_X
# Gamepad right stick Y axis
GAMEPAD_AXIS_RIGHT_Y = GamepadAxis.GAMEPAD_AXIS_RIGHT_Y
# Gamepad back trigger left, pressure level: [1..-1]
GAMEPAD_AXIS_LEFT_TRIGGER = GamepadAxis.GAMEPAD_AXIS_LEFT_TRIGGER
# Gamepad back trigger right, pressure level: [1..-1]
GAMEPAD_AXIS_RIGHT_TRIGGER = GamepadAxis.GAMEPAD_AXIS_RIGHT_TRIGGER


class MaterialMapIndex(IntEnum):
    MATERIAL_MAP_ALBEDO = 0
    MATERIAL_MAP_METALNESS = 1
    MATERIAL_MAP_NORMAL = 2
    MATERIAL_MAP_ROUGHNESS = 3
    MATERIAL_MAP_OCCLUSION = 4
    MATERIAL_MAP_EMISSION = 5
    MATERIAL_MAP_HEIGHT = 6
    MATERIAL_MAP_CUBEMAP = 7
    MATERIAL_MAP_IRRADIANCE = 8
    MATERIAL_MAP_PREFILTER = 9
    MATERIAL_MAP_BRDF = 10


# Albedo material (same as: MATERIAL_MAP_DIFFUSE)
MATERIAL_MAP_ALBEDO = MaterialMapIndex.MATERIAL_MAP_ALBEDO
# Metalness material (same as: MATERIAL_MAP_SPECULAR)
MATERIAL_MAP_METALNESS = MaterialMapIndex.MATERIAL_MAP_METALNESS
# Normal material
MATERIAL_MAP_NORMAL = MaterialMapIndex.MATERIAL_MAP_NORMAL
# Roughness material
MATERIAL_MAP_ROUGHNESS = MaterialMapIndex.MATERIAL_MAP_ROUGHNESS
# Ambient occlusion material
MATERIAL_MAP_OCCLUSION = MaterialMapIndex.MATERIAL_MAP_OCCLUSION
# Emission material
MATERIAL_MAP_EMISSION = MaterialMapIndex.MATERIAL_MAP_EMISSION
# Heightmap material
MATERIAL_MAP_HEIGHT = MaterialMapIndex.MATERIAL_MAP_HEIGHT
# Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_CUBEMAP = MaterialMapIndex.MATERIAL_MAP_CUBEMAP
# Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_IRRADIANCE = MaterialMapIndex.MATERIAL_MAP_IRRADIANCE
# Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_PREFILTER = MaterialMapIndex.MATERIAL_MAP_PREFILTER
# Brdf material
MATERIAL_MAP_BRDF = MaterialMapIndex.MATERIAL_MAP_BRDF


class ShaderLocationIndex(IntEnum):
    SHADER_LOC_VERTEX_POSITION = 0
    SHADER_LOC_VERTEX_TEXCOORD01 = 1
    SHADER_LOC_VERTEX_TEXCOORD02 = 2
    SHADER_LOC_VERTEX_NORMAL = 3
    SHADER_LOC_VERTEX_TANGENT = 4
    SHADER_LOC_VERTEX_COLOR = 5
    SHADER_LOC_MATRIX_MVP = 6
    SHADER_LOC_MATRIX_VIEW = 7
    SHADER_LOC_MATRIX_PROJECTION = 8
    SHADER_LOC_MATRIX_MODEL = 9
    SHADER_LOC_MATRIX_NORMAL = 10
    SHADER_LOC_VECTOR_VIEW = 11
    SHADER_LOC_COLOR_DIFFUSE = 12
    SHADER_LOC_COLOR_SPECULAR = 13
    SHADER_LOC_COLOR_AMBIENT = 14
    SHADER_LOC_MAP_ALBEDO = 15
    SHADER_LOC_MAP_METALNESS = 16
    SHADER_LOC_MAP_NORMAL = 17
    SHADER_LOC_MAP_ROUGHNESS = 18
    SHADER_LOC_MAP_OCCLUSION = 19
    SHADER_LOC_MAP_EMISSION = 20
    SHADER_LOC_MAP_HEIGHT = 21
    SHADER_LOC_MAP_CUBEMAP = 22
    SHADER_LOC_MAP_IRRADIANCE = 23
    SHADER_LOC_MAP_PREFILTER = 24
    SHADER_LOC_MAP_BRDF = 25


# Shader location: vertex attribute: position
SHADER_LOC_VERTEX_POSITION = ShaderLocationIndex.SHADER_LOC_VERTEX_POSITION
# Shader location: vertex attribute: texcoord01
SHADER_LOC_VERTEX_TEXCOORD01 = ShaderLocationIndex.SHADER_LOC_VERTEX_TEXCOORD01
# Shader location: vertex attribute: texcoord02
SHADER_LOC_VERTEX_TEXCOORD02 = ShaderLocationIndex.SHADER_LOC_VERTEX_TEXCOORD02
# Shader location: vertex attribute: normal
SHADER_LOC_VERTEX_NORMAL = ShaderLocationIndex.SHADER_LOC_VERTEX_NORMAL
# Shader location: vertex attribute: tangent
SHADER_LOC_VERTEX_TANGENT = ShaderLocationIndex.SHADER_LOC_VERTEX_TANGENT
# Shader location: vertex attribute: color
SHADER_LOC_VERTEX_COLOR = ShaderLocationIndex.SHADER_LOC_VERTEX_COLOR
# Shader location: matrix uniform: model-view-projection
SHADER_LOC_MATRIX_MVP = ShaderLocationIndex.SHADER_LOC_MATRIX_MVP
# Shader location: matrix uniform: view (camera transform)
SHADER_LOC_MATRIX_VIEW = ShaderLocationIndex.SHADER_LOC_MATRIX_VIEW
# Shader location: matrix uniform: projection
SHADER_LOC_MATRIX_PROJECTION = ShaderLocationIndex.SHADER_LOC_MATRIX_PROJECTION
# Shader location: matrix uniform: model (transform)
SHADER_LOC_MATRIX_MODEL = ShaderLocationIndex.SHADER_LOC_MATRIX_MODEL
# Shader location: matrix uniform: normal
SHADER_LOC_MATRIX_NORMAL = ShaderLocationIndex.SHADER_LOC_MATRIX_NORMAL
# Shader location: vector uniform: view
SHADER_LOC_VECTOR_VIEW = ShaderLocationIndex.SHADER_LOC_VECTOR_VIEW
# Shader location: vector uniform: diffuse color
SHADER_LOC_COLOR_DIFFUSE = ShaderLocationIndex.SHADER_LOC_COLOR_DIFFUSE
# Shader location: vector uniform: specular color
SHADER_LOC_COLOR_SPECULAR = ShaderLocationIndex.SHADER_LOC_COLOR_SPECULAR
# Shader location: vector uniform: ambient color
SHADER_LOC_COLOR_AMBIENT = ShaderLocationIndex.SHADER_LOC_COLOR_AMBIENT
# Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
SHADER_LOC_MAP_ALBEDO = ShaderLocationIndex.SHADER_LOC_MAP_ALBEDO
# Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
SHADER_LOC_MAP_METALNESS = ShaderLocationIndex.SHADER_LOC_MAP_METALNESS
# Shader location: sampler2d texture: normal
SHADER_LOC_MAP_NORMAL = ShaderLocationIndex.SHADER_LOC_MAP_NORMAL
# Shader location: sampler2d texture: roughness
SHADER_LOC_MAP_ROUGHNESS = ShaderLocationIndex.SHADER_LOC_MAP_ROUGHNESS
# Shader location: sampler2d texture: occlusion
SHADER_LOC_MAP_OCCLUSION = ShaderLocationIndex.SHADER_LOC_MAP_OCCLUSION
# Shader location: sampler2d texture: emission
SHADER_LOC_MAP_EMISSION = ShaderLocationIndex.SHADER_LOC_MAP_EMISSION
# Shader location: sampler2d texture: height
SHADER_LOC_MAP_HEIGHT = ShaderLocationIndex.SHADER_LOC_MAP_HEIGHT
# Shader location: samplerCube texture: cubemap
SHADER_LOC_MAP_CUBEMAP = ShaderLocationIndex.SHADER_LOC_MAP_CUBEMAP
# Shader location: samplerCube texture: irradiance
SHADER_LOC_MAP_IRRADIANCE = ShaderLocationIndex.SHADER_LOC_MAP_IRRADIANCE
# Shader location: samplerCube texture: prefilter
SHADER_LOC_MAP_PREFILTER = ShaderLocationIndex.SHADER_LOC_MAP_PREFILTER
# Shader location: sampler2d texture: brdf
SHADER_LOC_MAP_BRDF = ShaderLocationIndex.SHADER_LOC_MAP_BRDF


class ShaderUniformDataType(IntEnum):
    SHADER_UNIFORM_FLOAT = 0
    SHADER_UNIFORM_VEC2 = 1
    SHADER_UNIFORM_VEC3 = 2
    SHADER_UNIFORM_VEC4 = 3
    SHADER_UNIFORM_INT = 4
    SHADER_UNIFORM_IVEC2 = 5
    SHADER_UNIFORM_IVEC3 = 6
    SHADER_UNIFORM_IVEC4 = 7
    SHADER_UNIFORM_SAMPLER2D = 8


# Shader uniform type: float
SHADER_UNIFORM_FLOAT = ShaderUniformDataType.SHADER_UNIFORM_FLOAT
# Shader uniform type: vec2 (2 float)
SHADER_UNIFORM_VEC2 = ShaderUniformDataType.SHADER_UNIFORM_VEC2
# Shader uniform type: vec3 (3 float)
SHADER_UNIFORM_VEC3 = ShaderUniformDataType.SHADER_UNIFORM_VEC3
# Shader uniform type: vec4 (4 float)
SHADER_UNIFORM_VEC4 = ShaderUniformDataType.SHADER_UNIFORM_VEC4
# Shader uniform type: int
SHADER_UNIFORM_INT = ShaderUniformDataType.SHADER_UNIFORM_INT
# Shader uniform type: ivec2 (2 int)
SHADER_UNIFORM_IVEC2 = ShaderUniformDataType.SHADER_UNIFORM_IVEC2
# Shader uniform type: ivec3 (3 int)
SHADER_UNIFORM_IVEC3 = ShaderUniformDataType.SHADER_UNIFORM_IVEC3
# Shader uniform type: ivec4 (4 int)
SHADER_UNIFORM_IVEC4 = ShaderUniformDataType.SHADER_UNIFORM_IVEC4
# Shader uniform type: sampler2d
SHADER_UNIFORM_SAMPLER2D = ShaderUniformDataType.SHADER_UNIFORM_SAMPLER2D


class ShaderAttributeDataType(IntEnum):
    SHADER_ATTRIB_FLOAT = 0
    SHADER_ATTRIB_VEC2 = 1
    SHADER_ATTRIB_VEC3 = 2
    SHADER_ATTRIB_VEC4 = 3


# Shader attribute type: float
SHADER_ATTRIB_FLOAT = ShaderAttributeDataType.SHADER_ATTRIB_FLOAT
# Shader attribute type: vec2 (2 float)
SHADER_ATTRIB_VEC2 = ShaderAttributeDataType.SHADER_ATTRIB_VEC2
# Shader attribute type: vec3 (3 float)
SHADER_ATTRIB_VEC3 = ShaderAttributeDataType.SHADER_ATTRIB_VEC3
# Shader attribute type: vec4 (4 float)
SHADER_ATTRIB_VEC4 = ShaderAttributeDataType.SHADER_ATTRIB_VEC4


class PixelFormat(IntEnum):
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2
    PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3
    PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7
    PIXELFORMAT_UNCOMPRESSED_R32 = 8
    PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10
    PIXELFORMAT_COMPRESSED_DXT1_RGB = 11
    PIXELFORMAT_COMPRESSED_DXT1_RGBA = 12
    PIXELFORMAT_COMPRESSED_DXT3_RGBA = 13
    PIXELFORMAT_COMPRESSED_DXT5_RGBA = 14
    PIXELFORMAT_COMPRESSED_ETC1_RGB = 15
    PIXELFORMAT_COMPRESSED_ETC2_RGB = 16
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 17
    PIXELFORMAT_COMPRESSED_PVRT_RGB = 18
    PIXELFORMAT_COMPRESSED_PVRT_RGBA = 19
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 20
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 21


# 8 bit per pixel (no alpha)
PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = PixelFormat.PIXELFORMAT_UNCOMPRESSED_GRAYSCALE
# 8*2 bpp (2 channels)
PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = PixelFormat.PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA
# 16 bpp
PIXELFORMAT_UNCOMPRESSED_R5G6B5 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R5G6B5
# 24 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R8G8B8
# 16 bpp (1 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R5G5B5A1
# 16 bpp (4 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R4G4B4A4
# 32 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R8G8B8A8
# 32 bpp (1 channel - float)
PIXELFORMAT_UNCOMPRESSED_R32 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R32
# 32*3 bpp (3 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R32G32B32
# 32*4 bpp (4 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = PixelFormat.PIXELFORMAT_UNCOMPRESSED_R32G32B32A32
# 4 bpp (no alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_DXT1_RGB
# 4 bpp (1 bit alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_DXT1_RGBA
# 8 bpp
PIXELFORMAT_COMPRESSED_DXT3_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_DXT3_RGBA
# 8 bpp
PIXELFORMAT_COMPRESSED_DXT5_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_DXT5_RGBA
# 4 bpp
PIXELFORMAT_COMPRESSED_ETC1_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_ETC1_RGB
# 4 bpp
PIXELFORMAT_COMPRESSED_ETC2_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_ETC2_RGB
# 8 bpp
PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGB = PixelFormat.PIXELFORMAT_COMPRESSED_PVRT_RGB
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_PVRT_RGBA
# 8 bpp
PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA
# 2 bpp
PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = PixelFormat.PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA


class TextureFilter(IntEnum):
    TEXTURE_FILTER_POINT = 0
    TEXTURE_FILTER_BILINEAR = 1
    TEXTURE_FILTER_TRILINEAR = 2
    TEXTURE_FILTER_ANISOTROPIC_4X = 3
    TEXTURE_FILTER_ANISOTROPIC_8X = 4
    TEXTURE_FILTER_ANISOTROPIC_16X = 5


# No filter, just pixel approximation
TEXTURE_FILTER_POINT = TextureFilter.TEXTURE_FILTER_POINT
# Linear filtering
TEXTURE_FILTER_BILINEAR = TextureFilter.TEXTURE_FILTER_BILINEAR
# Trilinear filtering (linear with mipmaps)
TEXTURE_FILTER_TRILINEAR = TextureFilter.TEXTURE_FILTER_TRILINEAR
# Anisotropic filtering 4x
TEXTURE_FILTER_ANISOTROPIC_4X = TextureFilter.TEXTURE_FILTER_ANISOTROPIC_4X
# Anisotropic filtering 8x
TEXTURE_FILTER_ANISOTROPIC_8X = TextureFilter.TEXTURE_FILTER_ANISOTROPIC_8X
# Anisotropic filtering 16x
TEXTURE_FILTER_ANISOTROPIC_16X = TextureFilter.TEXTURE_FILTER_ANISOTROPIC_16X


class TextureWrap(IntEnum):
    TEXTURE_WRAP_REPEAT = 0
    TEXTURE_WRAP_CLAMP = 1
    TEXTURE_WRAP_MIRROR_REPEAT = 2
    TEXTURE_WRAP_MIRROR_CLAMP = 3


# Repeats texture in tiled mode
TEXTURE_WRAP_REPEAT = TextureWrap.TEXTURE_WRAP_REPEAT
# Clamps texture to edge pixel in tiled mode
TEXTURE_WRAP_CLAMP = TextureWrap.TEXTURE_WRAP_CLAMP
# Mirrors and repeats the texture in tiled mode
TEXTURE_WRAP_MIRROR_REPEAT = TextureWrap.TEXTURE_WRAP_MIRROR_REPEAT
# Mirrors and clamps to border the texture in tiled mode
TEXTURE_WRAP_MIRROR_CLAMP = TextureWrap.TEXTURE_WRAP_MIRROR_CLAMP


class CubemapLayout(IntEnum):
    CUBEMAP_LAYOUT_AUTO_DETECT = 0
    CUBEMAP_LAYOUT_LINE_VERTICAL = 1
    CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4
    CUBEMAP_LAYOUT_PANORAMA = 5


# Automatically detect layout type
CUBEMAP_LAYOUT_AUTO_DETECT = CubemapLayout.CUBEMAP_LAYOUT_AUTO_DETECT
# Layout is defined by a vertical line with faces
CUBEMAP_LAYOUT_LINE_VERTICAL = CubemapLayout.CUBEMAP_LAYOUT_LINE_VERTICAL
# Layout is defined by an horizontal line with faces
CUBEMAP_LAYOUT_LINE_HORIZONTAL = CubemapLayout.CUBEMAP_LAYOUT_LINE_HORIZONTAL
# Layout is defined by a 3x4 cross with cubemap faces
CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = CubemapLayout.CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR
# Layout is defined by a 4x3 cross with cubemap faces
CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = CubemapLayout.CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE
# Layout is defined by a panorama image (equirectangular map)
CUBEMAP_LAYOUT_PANORAMA = CubemapLayout.CUBEMAP_LAYOUT_PANORAMA


class FontType(IntEnum):
    FONT_DEFAULT = 0
    FONT_BITMAP = 1
    FONT_SDF = 2


# Default font generation, anti-aliased
FONT_DEFAULT = FontType.FONT_DEFAULT
# Bitmap font generation, no anti-aliasing
FONT_BITMAP = FontType.FONT_BITMAP
# SDF font generation, requires external shader
FONT_SDF = FontType.FONT_SDF


class BlendMode(IntEnum):
    BLEND_ALPHA = 0
    BLEND_ADDITIVE = 1
    BLEND_MULTIPLIED = 2
    BLEND_ADD_COLORS = 3
    BLEND_SUBTRACT_COLORS = 4
    BLEND_ALPHA_PREMULTIPLY = 5
    BLEND_CUSTOM = 6


# Blend textures considering alpha (default)
BLEND_ALPHA = BlendMode.BLEND_ALPHA
# Blend textures adding colors
BLEND_ADDITIVE = BlendMode.BLEND_ADDITIVE
# Blend textures multiplying colors
BLEND_MULTIPLIED = BlendMode.BLEND_MULTIPLIED
# Blend textures adding colors (alternative)
BLEND_ADD_COLORS = BlendMode.BLEND_ADD_COLORS
# Blend textures subtracting colors (alternative)
BLEND_SUBTRACT_COLORS = BlendMode.BLEND_SUBTRACT_COLORS
# Blend premultiplied textures considering alpha
BLEND_ALPHA_PREMULTIPLY = BlendMode.BLEND_ALPHA_PREMULTIPLY
# Blend textures using custom src/dst factors (use rlSetBlendMode())
BLEND_CUSTOM = BlendMode.BLEND_CUSTOM


class Gesture(IntEnum):
    GESTURE_NONE = 0
    GESTURE_TAP = 1
    GESTURE_DOUBLETAP = 2
    GESTURE_HOLD = 4
    GESTURE_DRAG = 8
    GESTURE_SWIPE_RIGHT = 16
    GESTURE_SWIPE_LEFT = 32
    GESTURE_SWIPE_UP = 64
    GESTURE_SWIPE_DOWN = 128
    GESTURE_PINCH_IN = 256
    GESTURE_PINCH_OUT = 512


# No gesture
GESTURE_NONE = Gesture.GESTURE_NONE
# Tap gesture
GESTURE_TAP = Gesture.GESTURE_TAP
# Double tap gesture
GESTURE_DOUBLETAP = Gesture.GESTURE_DOUBLETAP
# Hold gesture
GESTURE_HOLD = Gesture.GESTURE_HOLD
# Drag gesture
GESTURE_DRAG = Gesture.GESTURE_DRAG
# Swipe right gesture
GESTURE_SWIPE_RIGHT = Gesture.GESTURE_SWIPE_RIGHT
# Swipe left gesture
GESTURE_SWIPE_LEFT = Gesture.GESTURE_SWIPE_LEFT
# Swipe up gesture
GESTURE_SWIPE_UP = Gesture.GESTURE_SWIPE_UP
# Swipe down gesture
GESTURE_SWIPE_DOWN = Gesture.GESTURE_SWIPE_DOWN
# Pinch in gesture
GESTURE_PINCH_IN = Gesture.GESTURE_PINCH_IN
# Pinch out gesture
GESTURE_PINCH_OUT = Gesture.GESTURE_PINCH_OUT


class CameraMode(IntEnum):
    CAMERA_CUSTOM = 0
    CAMERA_FREE = 1
    CAMERA_ORBITAL = 2
    CAMERA_FIRST_PERSON = 3
    CAMERA_THIRD_PERSON = 4


# Custom camera
CAMERA_CUSTOM = CameraMode.CAMERA_CUSTOM
# Free camera
CAMERA_FREE = CameraMode.CAMERA_FREE
# Orbital camera
CAMERA_ORBITAL = CameraMode.CAMERA_ORBITAL
# First person camera
CAMERA_FIRST_PERSON = CameraMode.CAMERA_FIRST_PERSON
# Third person camera
CAMERA_THIRD_PERSON = CameraMode.CAMERA_THIRD_PERSON


class CameraProjection(IntEnum):
    CAMERA_PERSPECTIVE = 0
    CAMERA_ORTHOGRAPHIC = 1


# Perspective projection
CAMERA_PERSPECTIVE = CameraProjection.CAMERA_PERSPECTIVE
# Orthographic projection
CAMERA_ORTHOGRAPHIC = CameraProjection.CAMERA_ORTHOGRAPHIC


class NPatchLayout(IntEnum):
    NPATCH_NINE_PATCH = 0
    NPATCH_THREE_PATCH_VERTICAL = 1
    NPATCH_THREE_PATCH_HORIZONTAL = 2


# Npatch layout: 3x3 tiles
NPATCH_NINE_PATCH = NPatchLayout.NPATCH_NINE_PATCH
# Npatch layout: 1x3 tiles
NPATCH_THREE_PATCH_VERTICAL = NPatchLayout.NPATCH_THREE_PATCH_VERTICAL
# Npatch layout: 3x1 tiles
NPATCH_THREE_PATCH_HORIZONTAL = NPatchLayout.NPATCH_THREE_PATCH_HORIZONTAL


RAYLIB_VERSION = "4.2"
PI = 3.141592653589793
DEG2RAD = (PI / 180.0)
RAD2DEG = (180.0 / PI)
# Light Gray
LIGHTGRAY = Color(200, 200, 200, 255)
# Gray
GRAY = Color(130, 130, 130, 255)
# Dark Gray
DARKGRAY = Color(80, 80, 80, 255)
# Yellow
YELLOW = Color(253, 249, 0, 255)
# Gold
GOLD = Color(255, 203, 0, 255)
# Orange
ORANGE = Color(255, 161, 0, 255)
# Pink
PINK = Color(255, 109, 194, 255)
# Red
RED = Color(230, 41, 55, 255)
# Maroon
MAROON = Color(190, 33, 55, 255)
# Green
GREEN = Color(0, 228, 48, 255)
# Lime
LIME = Color(0, 158, 47, 255)
# Dark Green
DARKGREEN = Color(0, 117, 44, 255)
# Sky Blue
SKYBLUE = Color(102, 191, 255, 255)
# Blue
BLUE = Color(0, 121, 241, 255)
# Dark Blue
DARKBLUE = Color(0, 82, 172, 255)
# Purple
PURPLE = Color(200, 122, 255, 255)
# Violet
VIOLET = Color(135, 60, 190, 255)
# Dark Purple
DARKPURPLE = Color(112, 31, 126, 255)
# Beige
BEIGE = Color(211, 176, 131, 255)
# Brown
BROWN = Color(127, 106, 79, 255)
# Dark Brown
DARKBROWN = Color(76, 63, 47, 255)
# White
WHITE = Color(255, 255, 255, 255)
# Black
BLACK = Color(0, 0, 0, 255)
# Blank (Transparent)
BLANK = Color(0, 0, 0, 0)
# Magenta
MAGENTA = Color(255, 0, 255, 255)
# My own White (raylib logo)
RAYWHITE = Color(245, 245, 245, 255)
# endregion (constants and enums)
# region CALLBACKS


# Logging: Redirect trace log messages
TraceLogCallback = CFUNCTYPE(Int, CharPtr, VoidPtr)
# FileIO: Load binary data
LoadFileDataCallback = CFUNCTYPE(CharPtr, UIntPtr)
# FileIO: Save binary data
SaveFileDataCallback = CFUNCTYPE(CharPtr, VoidPtr, UInt)
# FileIO: Load text data
LoadFileTextCallback = CFUNCTYPE(CharPtr)
# FileIO: Save text data
SaveFileTextCallback = CFUNCTYPE(CharPtr, CharPtr)
# 
AudioCallback = CFUNCTYPE(VoidPtr, UInt)
# endregion (callbacks)

# region PROTOTYPES


def _wrap(api, name, argtypes, restype):
    globals()[name] = api
    api.argtypes = argtypes
    api.restype = restype


_wrap(rlapi.InitWindow, '_InitWindow', [Int, Int, CharPtr], None)
_wrap(rlapi.WindowShouldClose, '_WindowShouldClose', [], Bool)
_wrap(rlapi.CloseWindow, '_CloseWindow', [], None)
_wrap(rlapi.IsWindowReady, '_IsWindowReady', [], Bool)
_wrap(rlapi.IsWindowFullscreen, '_IsWindowFullscreen', [], Bool)
_wrap(rlapi.IsWindowHidden, '_IsWindowHidden', [], Bool)
_wrap(rlapi.IsWindowMinimized, '_IsWindowMinimized', [], Bool)
_wrap(rlapi.IsWindowMaximized, '_IsWindowMaximized', [], Bool)
_wrap(rlapi.IsWindowFocused, '_IsWindowFocused', [], Bool)
_wrap(rlapi.IsWindowResized, '_IsWindowResized', [], Bool)
_wrap(rlapi.IsWindowState, '_IsWindowState', [UInt], Bool)
_wrap(rlapi.SetWindowState, '_SetWindowState', [UInt], None)
_wrap(rlapi.ClearWindowState, '_ClearWindowState', [UInt], None)
_wrap(rlapi.ToggleFullscreen, '_ToggleFullscreen', [], None)
_wrap(rlapi.MaximizeWindow, '_MaximizeWindow', [], None)
_wrap(rlapi.MinimizeWindow, '_MinimizeWindow', [], None)
_wrap(rlapi.RestoreWindow, '_RestoreWindow', [], None)
_wrap(rlapi.SetWindowIcon, '_SetWindowIcon', [Image], None)
_wrap(rlapi.SetWindowTitle, '_SetWindowTitle', [CharPtr], None)
_wrap(rlapi.SetWindowPosition, '_SetWindowPosition', [Int, Int], None)
_wrap(rlapi.SetWindowMonitor, '_SetWindowMonitor', [Int], None)
_wrap(rlapi.SetWindowMinSize, '_SetWindowMinSize', [Int, Int], None)
_wrap(rlapi.SetWindowSize, '_SetWindowSize', [Int, Int], None)
_wrap(rlapi.SetWindowOpacity, '_SetWindowOpacity', [Float], None)
_wrap(rlapi.GetWindowHandle, '_GetWindowHandle', [], VoidPtr)
_wrap(rlapi.GetScreenWidth, '_GetScreenWidth', [], Int)
_wrap(rlapi.GetScreenHeight, '_GetScreenHeight', [], Int)
_wrap(rlapi.GetRenderWidth, '_GetRenderWidth', [], Int)
_wrap(rlapi.GetRenderHeight, '_GetRenderHeight', [], Int)
_wrap(rlapi.GetMonitorCount, '_GetMonitorCount', [], Int)
_wrap(rlapi.GetCurrentMonitor, '_GetCurrentMonitor', [], Int)
_wrap(rlapi.GetMonitorPosition, '_GetMonitorPosition', [Int], Vector2)
_wrap(rlapi.GetMonitorWidth, '_GetMonitorWidth', [Int], Int)
_wrap(rlapi.GetMonitorHeight, '_GetMonitorHeight', [Int], Int)
_wrap(rlapi.GetMonitorPhysicalWidth, '_GetMonitorPhysicalWidth', [Int], Int)
_wrap(rlapi.GetMonitorPhysicalHeight, '_GetMonitorPhysicalHeight', [Int], Int)
_wrap(rlapi.GetMonitorRefreshRate, '_GetMonitorRefreshRate', [Int], Int)
_wrap(rlapi.GetWindowPosition, '_GetWindowPosition', [], Vector2)
_wrap(rlapi.GetWindowScaleDPI, '_GetWindowScaleDPI', [], Vector2)
_wrap(rlapi.GetMonitorName, '_GetMonitorName', [Int], CharPtr)
_wrap(rlapi.SetClipboardText, '_SetClipboardText', [CharPtr], None)
_wrap(rlapi.GetClipboardText, '_GetClipboardText', [], CharPtr)
_wrap(rlapi.EnableEventWaiting, '_EnableEventWaiting', [], None)
_wrap(rlapi.DisableEventWaiting, '_DisableEventWaiting', [], None)
_wrap(rlapi.SwapScreenBuffer, '_SwapScreenBuffer', [], None)
_wrap(rlapi.PollInputEvents, '_PollInputEvents', [], None)
_wrap(rlapi.WaitTime, '_WaitTime', [Double], None)
_wrap(rlapi.ShowCursor, '_ShowCursor', [], None)
_wrap(rlapi.HideCursor, '_HideCursor', [], None)
_wrap(rlapi.IsCursorHidden, '_IsCursorHidden', [], Bool)
_wrap(rlapi.EnableCursor, '_EnableCursor', [], None)
_wrap(rlapi.DisableCursor, '_DisableCursor', [], None)
_wrap(rlapi.IsCursorOnScreen, '_IsCursorOnScreen', [], Bool)
_wrap(rlapi.ClearBackground, '_ClearBackground', [Color], None)
_wrap(rlapi.BeginDrawing, '_BeginDrawing', [], None)
_wrap(rlapi.EndDrawing, '_EndDrawing', [], None)
_wrap(rlapi.BeginMode2D, '_BeginMode2D', [Camera2D], None)
_wrap(rlapi.EndMode2D, '_EndMode2D', [], None)
_wrap(rlapi.BeginMode3D, '_BeginMode3D', [Camera3D], None)
_wrap(rlapi.EndMode3D, '_EndMode3D', [], None)
_wrap(rlapi.BeginTextureMode, '_BeginTextureMode', [RenderTexture2D], None)
_wrap(rlapi.EndTextureMode, '_EndTextureMode', [], None)
_wrap(rlapi.BeginShaderMode, '_BeginShaderMode', [Shader], None)
_wrap(rlapi.EndShaderMode, '_EndShaderMode', [], None)
_wrap(rlapi.BeginBlendMode, '_BeginBlendMode', [Int], None)
_wrap(rlapi.EndBlendMode, '_EndBlendMode', [], None)
_wrap(rlapi.BeginScissorMode, '_BeginScissorMode', [Int, Int, Int, Int], None)
_wrap(rlapi.EndScissorMode, '_EndScissorMode', [], None)
_wrap(rlapi.BeginVrStereoMode, '_BeginVrStereoMode', [VrStereoConfig], None)
_wrap(rlapi.EndVrStereoMode, '_EndVrStereoMode', [], None)
_wrap(rlapi.LoadVrStereoConfig, '_LoadVrStereoConfig', [VrDeviceInfo], VrStereoConfig)
_wrap(rlapi.UnloadVrStereoConfig, '_UnloadVrStereoConfig', [VrStereoConfig], None)
_wrap(rlapi.LoadShader, '_LoadShader', [CharPtr, CharPtr], Shader)
_wrap(rlapi.LoadShaderFromMemory, '_LoadShaderFromMemory', [CharPtr, CharPtr], Shader)
_wrap(rlapi.GetShaderLocation, '_GetShaderLocation', [Shader, CharPtr], Int)
_wrap(rlapi.GetShaderLocationAttrib, '_GetShaderLocationAttrib', [Shader, CharPtr], Int)
_wrap(rlapi.SetShaderValue, '_SetShaderValue', [Shader, Int, VoidPtr, Int], None)
_wrap(rlapi.SetShaderValueV, '_SetShaderValueV', [Shader, Int, VoidPtr, Int, Int], None)
_wrap(rlapi.SetShaderValueMatrix, '_SetShaderValueMatrix', [Shader, Int, Matrix], None)
_wrap(rlapi.SetShaderValueTexture, '_SetShaderValueTexture', [Shader, Int, Texture2D], None)
_wrap(rlapi.UnloadShader, '_UnloadShader', [Shader], None)
_wrap(rlapi.GetMouseRay, '_GetMouseRay', [Vector2, Camera], Ray)
_wrap(rlapi.GetCameraMatrix, '_GetCameraMatrix', [Camera], Matrix)
_wrap(rlapi.GetCameraMatrix2D, '_GetCameraMatrix2D', [Camera2D], Matrix)
_wrap(rlapi.GetWorldToScreen, '_GetWorldToScreen', [Vector3, Camera], Vector2)
_wrap(rlapi.GetScreenToWorld2D, '_GetScreenToWorld2D', [Vector2, Camera2D], Vector2)
_wrap(rlapi.GetWorldToScreenEx, '_GetWorldToScreenEx', [Vector3, Camera, Int, Int], Vector2)
_wrap(rlapi.GetWorldToScreen2D, '_GetWorldToScreen2D', [Vector2, Camera2D], Vector2)
_wrap(rlapi.SetTargetFPS, '_SetTargetFPS', [Int], None)
_wrap(rlapi.GetFPS, '_GetFPS', [], Int)
_wrap(rlapi.GetFrameTime, '_GetFrameTime', [], Float)
_wrap(rlapi.GetTime, '_GetTime', [], Double)
_wrap(rlapi.GetRandomValue, '_GetRandomValue', [Int, Int], Int)
_wrap(rlapi.SetRandomSeed, '_SetRandomSeed', [UInt], None)
_wrap(rlapi.TakeScreenshot, '_TakeScreenshot', [CharPtr], None)
_wrap(rlapi.SetConfigFlags, '_SetConfigFlags', [UInt], None)
_wrap(rlapi.TraceLog, '_TraceLog', [Int, CharPtr, VoidPtr], None)
_wrap(rlapi.SetTraceLogLevel, '_SetTraceLogLevel', [Int], None)
_wrap(rlapi.MemAlloc, '_MemAlloc', [Int], VoidPtr)
_wrap(rlapi.MemRealloc, '_MemRealloc', [VoidPtr, Int], VoidPtr)
_wrap(rlapi.MemFree, '_MemFree', [VoidPtr], None)
_wrap(rlapi.OpenURL, '_OpenURL', [CharPtr], None)
_wrap(rlapi.SetTraceLogCallback, '_SetTraceLogCallback', [TraceLogCallback], None)
_wrap(rlapi.SetLoadFileDataCallback, '_SetLoadFileDataCallback', [LoadFileDataCallback], None)
_wrap(rlapi.SetSaveFileDataCallback, '_SetSaveFileDataCallback', [SaveFileDataCallback], None)
_wrap(rlapi.SetLoadFileTextCallback, '_SetLoadFileTextCallback', [LoadFileTextCallback], None)
_wrap(rlapi.SetSaveFileTextCallback, '_SetSaveFileTextCallback', [SaveFileTextCallback], None)
_wrap(rlapi.LoadFileData, '_LoadFileData', [CharPtr, UIntPtr], UBytePtr)
_wrap(rlapi.UnloadFileData, '_UnloadFileData', [UBytePtr], None)
_wrap(rlapi.SaveFileData, '_SaveFileData', [CharPtr, VoidPtr, UInt], Bool)
_wrap(rlapi.ExportDataAsCode, '_ExportDataAsCode', [CharPtr, UInt, CharPtr], Bool)
_wrap(rlapi.LoadFileText, '_LoadFileText', [CharPtr], CharPtr)
_wrap(rlapi.UnloadFileText, '_UnloadFileText', [CharPtr], None)
_wrap(rlapi.SaveFileText, '_SaveFileText', [CharPtr, CharPtr], Bool)
_wrap(rlapi.FileExists, '_FileExists', [CharPtr], Bool)
_wrap(rlapi.DirectoryExists, '_DirectoryExists', [CharPtr], Bool)
_wrap(rlapi.IsFileExtension, '_IsFileExtension', [CharPtr, CharPtr], Bool)
_wrap(rlapi.GetFileLength, '_GetFileLength', [CharPtr], Int)
_wrap(rlapi.GetFileExtension, '_GetFileExtension', [CharPtr], CharPtr)
_wrap(rlapi.GetFileName, '_GetFileName', [CharPtr], CharPtr)
_wrap(rlapi.GetFileNameWithoutExt, '_GetFileNameWithoutExt', [CharPtr], CharPtr)
_wrap(rlapi.GetDirectoryPath, '_GetDirectoryPath', [CharPtr], CharPtr)
_wrap(rlapi.GetPrevDirectoryPath, '_GetPrevDirectoryPath', [CharPtr], CharPtr)
_wrap(rlapi.GetWorkingDirectory, '_GetWorkingDirectory', [], CharPtr)
_wrap(rlapi.GetApplicationDirectory, '_GetApplicationDirectory', [], CharPtr)
_wrap(rlapi.ChangeDirectory, '_ChangeDirectory', [CharPtr], Bool)
_wrap(rlapi.IsPathFile, '_IsPathFile', [CharPtr], Bool)
_wrap(rlapi.LoadDirectoryFiles, '_LoadDirectoryFiles', [CharPtr], FilePathList)
_wrap(rlapi.LoadDirectoryFilesEx, '_LoadDirectoryFilesEx', [CharPtr, CharPtr, Bool], FilePathList)
_wrap(rlapi.UnloadDirectoryFiles, '_UnloadDirectoryFiles', [FilePathList], None)
_wrap(rlapi.IsFileDropped, '_IsFileDropped', [], Bool)
_wrap(rlapi.LoadDroppedFiles, '_LoadDroppedFiles', [], FilePathList)
_wrap(rlapi.UnloadDroppedFiles, '_UnloadDroppedFiles', [FilePathList], None)
_wrap(rlapi.GetFileModTime, '_GetFileModTime', [CharPtr], Long)
_wrap(rlapi.CompressData, '_CompressData', [UBytePtr, Int, IntPtr], UBytePtr)
_wrap(rlapi.DecompressData, '_DecompressData', [UBytePtr, Int, IntPtr], UBytePtr)
_wrap(rlapi.EncodeDataBase64, '_EncodeDataBase64', [UBytePtr, Int, IntPtr], CharPtr)
_wrap(rlapi.DecodeDataBase64, '_DecodeDataBase64', [UBytePtr, IntPtr], UBytePtr)
_wrap(rlapi.IsKeyPressed, '_IsKeyPressed', [Int], Bool)
_wrap(rlapi.IsKeyDown, '_IsKeyDown', [Int], Bool)
_wrap(rlapi.IsKeyReleased, '_IsKeyReleased', [Int], Bool)
_wrap(rlapi.IsKeyUp, '_IsKeyUp', [Int], Bool)
_wrap(rlapi.SetExitKey, '_SetExitKey', [Int], None)
_wrap(rlapi.GetKeyPressed, '_GetKeyPressed', [], Int)
_wrap(rlapi.GetCharPressed, '_GetCharPressed', [], Int)
_wrap(rlapi.IsGamepadAvailable, '_IsGamepadAvailable', [Int], Bool)
_wrap(rlapi.GetGamepadName, '_GetGamepadName', [Int], CharPtr)
_wrap(rlapi.IsGamepadButtonPressed, '_IsGamepadButtonPressed', [Int, Int], Bool)
_wrap(rlapi.IsGamepadButtonDown, '_IsGamepadButtonDown', [Int, Int], Bool)
_wrap(rlapi.IsGamepadButtonReleased, '_IsGamepadButtonReleased', [Int, Int], Bool)
_wrap(rlapi.IsGamepadButtonUp, '_IsGamepadButtonUp', [Int, Int], Bool)
_wrap(rlapi.GetGamepadButtonPressed, '_GetGamepadButtonPressed', [], Int)
_wrap(rlapi.GetGamepadAxisCount, '_GetGamepadAxisCount', [Int], Int)
_wrap(rlapi.GetGamepadAxisMovement, '_GetGamepadAxisMovement', [Int, Int], Float)
_wrap(rlapi.SetGamepadMappings, '_SetGamepadMappings', [CharPtr], Int)
_wrap(rlapi.IsMouseButtonPressed, '_IsMouseButtonPressed', [Int], Bool)
_wrap(rlapi.IsMouseButtonDown, '_IsMouseButtonDown', [Int], Bool)
_wrap(rlapi.IsMouseButtonReleased, '_IsMouseButtonReleased', [Int], Bool)
_wrap(rlapi.IsMouseButtonUp, '_IsMouseButtonUp', [Int], Bool)
_wrap(rlapi.GetMouseX, '_GetMouseX', [], Int)
_wrap(rlapi.GetMouseY, '_GetMouseY', [], Int)
_wrap(rlapi.GetMousePosition, '_GetMousePosition', [], Vector2)
_wrap(rlapi.GetMouseDelta, '_GetMouseDelta', [], Vector2)
_wrap(rlapi.SetMousePosition, '_SetMousePosition', [Int, Int], None)
_wrap(rlapi.SetMouseOffset, '_SetMouseOffset', [Int, Int], None)
_wrap(rlapi.SetMouseScale, '_SetMouseScale', [Float, Float], None)
_wrap(rlapi.GetMouseWheelMove, '_GetMouseWheelMove', [], Float)
_wrap(rlapi.GetMouseWheelMoveV, '_GetMouseWheelMoveV', [], Vector2)
_wrap(rlapi.SetMouseCursor, '_SetMouseCursor', [Int], None)
_wrap(rlapi.GetTouchX, '_GetTouchX', [], Int)
_wrap(rlapi.GetTouchY, '_GetTouchY', [], Int)
_wrap(rlapi.GetTouchPosition, '_GetTouchPosition', [Int], Vector2)
_wrap(rlapi.GetTouchPointId, '_GetTouchPointId', [Int], Int)
_wrap(rlapi.GetTouchPointCount, '_GetTouchPointCount', [], Int)
_wrap(rlapi.SetGesturesEnabled, '_SetGesturesEnabled', [UInt], None)
_wrap(rlapi.IsGestureDetected, '_IsGestureDetected', [Int], Bool)
_wrap(rlapi.GetGestureDetected, '_GetGestureDetected', [], Int)
_wrap(rlapi.GetGestureHoldDuration, '_GetGestureHoldDuration', [], Float)
_wrap(rlapi.GetGestureDragVector, '_GetGestureDragVector', [], Vector2)
_wrap(rlapi.GetGestureDragAngle, '_GetGestureDragAngle', [], Float)
_wrap(rlapi.GetGesturePinchVector, '_GetGesturePinchVector', [], Vector2)
_wrap(rlapi.GetGesturePinchAngle, '_GetGesturePinchAngle', [], Float)
_wrap(rlapi.SetCameraMode, '_SetCameraMode', [Camera, Int], None)
_wrap(rlapi.UpdateCamera, '_UpdateCamera', [CameraPtr], None)
_wrap(rlapi.SetCameraPanControl, '_SetCameraPanControl', [Int], None)
_wrap(rlapi.SetCameraAltControl, '_SetCameraAltControl', [Int], None)
_wrap(rlapi.SetCameraSmoothZoomControl, '_SetCameraSmoothZoomControl', [Int], None)
_wrap(rlapi.SetCameraMoveControls, '_SetCameraMoveControls', [Int, Int, Int, Int, Int, Int], None)
_wrap(rlapi.SetShapesTexture, '_SetShapesTexture', [Texture2D, Rectangle], None)
_wrap(rlapi.DrawPixel, '_DrawPixel', [Int, Int, Color], None)
_wrap(rlapi.DrawPixelV, '_DrawPixelV', [Vector2, Color], None)
_wrap(rlapi.DrawLine, '_DrawLine', [Int, Int, Int, Int, Color], None)
_wrap(rlapi.DrawLineV, '_DrawLineV', [Vector2, Vector2, Color], None)
_wrap(rlapi.DrawLineEx, '_DrawLineEx', [Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineBezier, '_DrawLineBezier', [Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineBezierQuad, '_DrawLineBezierQuad', [Vector2, Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineBezierCubic, '_DrawLineBezierCubic', [Vector2, Vector2, Vector2, Vector2, Float, Color], None)
_wrap(rlapi.DrawLineStrip, '_DrawLineStrip', [Vector2Ptr, Int, Color], None)
_wrap(rlapi.DrawCircle, '_DrawCircle', [Int, Int, Float, Color], None)
_wrap(rlapi.DrawCircleSector, '_DrawCircleSector', [Vector2, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCircleSectorLines, '_DrawCircleSectorLines', [Vector2, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCircleGradient, '_DrawCircleGradient', [Int, Int, Float, Color, Color], None)
_wrap(rlapi.DrawCircleV, '_DrawCircleV', [Vector2, Float, Color], None)
_wrap(rlapi.DrawCircleLines, '_DrawCircleLines', [Int, Int, Float, Color], None)
_wrap(rlapi.DrawEllipse, '_DrawEllipse', [Int, Int, Float, Float, Color], None)
_wrap(rlapi.DrawEllipseLines, '_DrawEllipseLines', [Int, Int, Float, Float, Color], None)
_wrap(rlapi.DrawRing, '_DrawRing', [Vector2, Float, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawRingLines, '_DrawRingLines', [Vector2, Float, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawRectangle, '_DrawRectangle', [Int, Int, Int, Int, Color], None)
_wrap(rlapi.DrawRectangleV, '_DrawRectangleV', [Vector2, Vector2, Color], None)
_wrap(rlapi.DrawRectangleRec, '_DrawRectangleRec', [Rectangle, Color], None)
_wrap(rlapi.DrawRectanglePro, '_DrawRectanglePro', [Rectangle, Vector2, Float, Color], None)
_wrap(rlapi.DrawRectangleGradientV, '_DrawRectangleGradientV', [Int, Int, Int, Int, Color, Color], None)
_wrap(rlapi.DrawRectangleGradientH, '_DrawRectangleGradientH', [Int, Int, Int, Int, Color, Color], None)
_wrap(rlapi.DrawRectangleGradientEx, '_DrawRectangleGradientEx', [Rectangle, Color, Color, Color, Color], None)
_wrap(rlapi.DrawRectangleLines, '_DrawRectangleLines', [Int, Int, Int, Int, Color], None)
_wrap(rlapi.DrawRectangleLinesEx, '_DrawRectangleLinesEx', [Rectangle, Float, Color], None)
_wrap(rlapi.DrawRectangleRounded, '_DrawRectangleRounded', [Rectangle, Float, Int, Color], None)
_wrap(rlapi.DrawRectangleRoundedLines, '_DrawRectangleRoundedLines', [Rectangle, Float, Int, Float, Color], None)
_wrap(rlapi.DrawTriangle, '_DrawTriangle', [Vector2, Vector2, Vector2, Color], None)
_wrap(rlapi.DrawTriangleLines, '_DrawTriangleLines', [Vector2, Vector2, Vector2, Color], None)
_wrap(rlapi.DrawTriangleFan, '_DrawTriangleFan', [Vector2Ptr, Int, Color], None)
_wrap(rlapi.DrawTriangleStrip, '_DrawTriangleStrip', [Vector2Ptr, Int, Color], None)
_wrap(rlapi.DrawPoly, '_DrawPoly', [Vector2, Int, Float, Float, Color], None)
_wrap(rlapi.DrawPolyLines, '_DrawPolyLines', [Vector2, Int, Float, Float, Color], None)
_wrap(rlapi.DrawPolyLinesEx, '_DrawPolyLinesEx', [Vector2, Int, Float, Float, Float, Color], None)
_wrap(rlapi.CheckCollisionRecs, '_CheckCollisionRecs', [Rectangle, Rectangle], Bool)
_wrap(rlapi.CheckCollisionCircles, '_CheckCollisionCircles', [Vector2, Float, Vector2, Float], Bool)
_wrap(rlapi.CheckCollisionCircleRec, '_CheckCollisionCircleRec', [Vector2, Float, Rectangle], Bool)
_wrap(rlapi.CheckCollisionPointRec, '_CheckCollisionPointRec', [Vector2, Rectangle], Bool)
_wrap(rlapi.CheckCollisionPointCircle, '_CheckCollisionPointCircle', [Vector2, Vector2, Float], Bool)
_wrap(rlapi.CheckCollisionPointTriangle, '_CheckCollisionPointTriangle', [Vector2, Vector2, Vector2, Vector2], Bool)
_wrap(rlapi.CheckCollisionLines, '_CheckCollisionLines', [Vector2, Vector2, Vector2, Vector2, Vector2Ptr], Bool)
_wrap(rlapi.CheckCollisionPointLine, '_CheckCollisionPointLine', [Vector2, Vector2, Vector2, Int], Bool)
_wrap(rlapi.GetCollisionRec, '_GetCollisionRec', [Rectangle, Rectangle], Rectangle)
_wrap(rlapi.LoadImage, '_LoadImage', [CharPtr], Image)
_wrap(rlapi.LoadImageRaw, '_LoadImageRaw', [CharPtr, Int, Int, Int, Int], Image)
_wrap(rlapi.LoadImageAnim, '_LoadImageAnim', [CharPtr, IntPtr], Image)
_wrap(rlapi.LoadImageFromMemory, '_LoadImageFromMemory', [CharPtr, UBytePtr, Int], Image)
_wrap(rlapi.LoadImageFromTexture, '_LoadImageFromTexture', [Texture2D], Image)
_wrap(rlapi.LoadImageFromScreen, '_LoadImageFromScreen', [], Image)
_wrap(rlapi.UnloadImage, '_UnloadImage', [Image], None)
_wrap(rlapi.ExportImage, '_ExportImage', [Image, CharPtr], Bool)
_wrap(rlapi.ExportImageAsCode, '_ExportImageAsCode', [Image, CharPtr], Bool)
_wrap(rlapi.GenImageColor, '_GenImageColor', [Int, Int, Color], Image)
_wrap(rlapi.GenImageGradientV, '_GenImageGradientV', [Int, Int, Color, Color], Image)
_wrap(rlapi.GenImageGradientH, '_GenImageGradientH', [Int, Int, Color, Color], Image)
_wrap(rlapi.GenImageGradientRadial, '_GenImageGradientRadial', [Int, Int, Float, Color, Color], Image)
_wrap(rlapi.GenImageChecked, '_GenImageChecked', [Int, Int, Int, Int, Color, Color], Image)
_wrap(rlapi.GenImageWhiteNoise, '_GenImageWhiteNoise', [Int, Int, Float], Image)
_wrap(rlapi.GenImageCellular, '_GenImageCellular', [Int, Int, Int], Image)
_wrap(rlapi.ImageCopy, '_ImageCopy', [Image], Image)
_wrap(rlapi.ImageFromImage, '_ImageFromImage', [Image, Rectangle], Image)
_wrap(rlapi.ImageText, '_ImageText', [CharPtr, Int, Color], Image)
_wrap(rlapi.ImageTextEx, '_ImageTextEx', [Font, CharPtr, Float, Float, Color], Image)
_wrap(rlapi.ImageFormat, '_ImageFormat', [ImagePtr, Int], None)
_wrap(rlapi.ImageToPOT, '_ImageToPOT', [ImagePtr, Color], None)
_wrap(rlapi.ImageCrop, '_ImageCrop', [ImagePtr, Rectangle], None)
_wrap(rlapi.ImageAlphaCrop, '_ImageAlphaCrop', [ImagePtr, Float], None)
_wrap(rlapi.ImageAlphaClear, '_ImageAlphaClear', [ImagePtr, Color, Float], None)
_wrap(rlapi.ImageAlphaMask, '_ImageAlphaMask', [ImagePtr, Image], None)
_wrap(rlapi.ImageAlphaPremultiply, '_ImageAlphaPremultiply', [ImagePtr], None)
_wrap(rlapi.ImageResize, '_ImageResize', [ImagePtr, Int, Int], None)
_wrap(rlapi.ImageResizeNN, '_ImageResizeNN', [ImagePtr, Int, Int], None)
_wrap(rlapi.ImageResizeCanvas, '_ImageResizeCanvas', [ImagePtr, Int, Int, Int, Int, Color], None)
_wrap(rlapi.ImageMipmaps, '_ImageMipmaps', [ImagePtr], None)
_wrap(rlapi.ImageDither, '_ImageDither', [ImagePtr, Int, Int, Int, Int], None)
_wrap(rlapi.ImageFlipVertical, '_ImageFlipVertical', [ImagePtr], None)
_wrap(rlapi.ImageFlipHorizontal, '_ImageFlipHorizontal', [ImagePtr], None)
_wrap(rlapi.ImageRotateCW, '_ImageRotateCW', [ImagePtr], None)
_wrap(rlapi.ImageRotateCCW, '_ImageRotateCCW', [ImagePtr], None)
_wrap(rlapi.ImageColorTint, '_ImageColorTint', [ImagePtr, Color], None)
_wrap(rlapi.ImageColorInvert, '_ImageColorInvert', [ImagePtr], None)
_wrap(rlapi.ImageColorGrayscale, '_ImageColorGrayscale', [ImagePtr], None)
_wrap(rlapi.ImageColorContrast, '_ImageColorContrast', [ImagePtr, Float], None)
_wrap(rlapi.ImageColorBrightness, '_ImageColorBrightness', [ImagePtr, Int], None)
_wrap(rlapi.ImageColorReplace, '_ImageColorReplace', [ImagePtr, Color, Color], None)
_wrap(rlapi.LoadImageColors, '_LoadImageColors', [Image], ColorPtr)
_wrap(rlapi.LoadImagePalette, '_LoadImagePalette', [Image, Int, IntPtr], ColorPtr)
_wrap(rlapi.UnloadImageColors, '_UnloadImageColors', [ColorPtr], None)
_wrap(rlapi.UnloadImagePalette, '_UnloadImagePalette', [ColorPtr], None)
_wrap(rlapi.GetImageAlphaBorder, '_GetImageAlphaBorder', [Image, Float], Rectangle)
_wrap(rlapi.GetImageColor, '_GetImageColor', [Image, Int, Int], Color)
_wrap(rlapi.ImageClearBackground, '_ImageClearBackground', [ImagePtr, Color], None)
_wrap(rlapi.ImageDrawPixel, '_ImageDrawPixel', [ImagePtr, Int, Int, Color], None)
_wrap(rlapi.ImageDrawPixelV, '_ImageDrawPixelV', [ImagePtr, Vector2, Color], None)
_wrap(rlapi.ImageDrawLine, '_ImageDrawLine', [ImagePtr, Int, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawLineV, '_ImageDrawLineV', [ImagePtr, Vector2, Vector2, Color], None)
_wrap(rlapi.ImageDrawCircle, '_ImageDrawCircle', [ImagePtr, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawCircleV, '_ImageDrawCircleV', [ImagePtr, Vector2, Int, Color], None)
_wrap(rlapi.ImageDrawRectangle, '_ImageDrawRectangle', [ImagePtr, Int, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawRectangleV, '_ImageDrawRectangleV', [ImagePtr, Vector2, Vector2, Color], None)
_wrap(rlapi.ImageDrawRectangleRec, '_ImageDrawRectangleRec', [ImagePtr, Rectangle, Color], None)
_wrap(rlapi.ImageDrawRectangleLines, '_ImageDrawRectangleLines', [ImagePtr, Rectangle, Int, Color], None)
_wrap(rlapi.ImageDraw, '_ImageDraw', [ImagePtr, Image, Rectangle, Rectangle, Color], None)
_wrap(rlapi.ImageDrawText, '_ImageDrawText', [ImagePtr, CharPtr, Int, Int, Int, Color], None)
_wrap(rlapi.ImageDrawTextEx, '_ImageDrawTextEx', [ImagePtr, Font, CharPtr, Vector2, Float, Float, Color], None)
_wrap(rlapi.LoadTexture, '_LoadTexture', [CharPtr], Texture2D)
_wrap(rlapi.LoadTextureFromImage, '_LoadTextureFromImage', [Image], Texture2D)
_wrap(rlapi.LoadTextureCubemap, '_LoadTextureCubemap', [Image, Int], TextureCubemap)
_wrap(rlapi.LoadRenderTexture, '_LoadRenderTexture', [Int, Int], RenderTexture2D)
_wrap(rlapi.UnloadTexture, '_UnloadTexture', [Texture2D], None)
_wrap(rlapi.UnloadRenderTexture, '_UnloadRenderTexture', [RenderTexture2D], None)
_wrap(rlapi.UpdateTexture, '_UpdateTexture', [Texture2D, VoidPtr], None)
_wrap(rlapi.UpdateTextureRec, '_UpdateTextureRec', [Texture2D, Rectangle, VoidPtr], None)
_wrap(rlapi.GenTextureMipmaps, '_GenTextureMipmaps', [Texture2DPtr], None)
_wrap(rlapi.SetTextureFilter, '_SetTextureFilter', [Texture2D, Int], None)
_wrap(rlapi.SetTextureWrap, '_SetTextureWrap', [Texture2D, Int], None)
_wrap(rlapi.DrawTexture, '_DrawTexture', [Texture2D, Int, Int, Color], None)
_wrap(rlapi.DrawTextureV, '_DrawTextureV', [Texture2D, Vector2, Color], None)
_wrap(rlapi.DrawTextureEx, '_DrawTextureEx', [Texture2D, Vector2, Float, Float, Color], None)
_wrap(rlapi.DrawTextureRec, '_DrawTextureRec', [Texture2D, Rectangle, Vector2, Color], None)
_wrap(rlapi.DrawTextureQuad, '_DrawTextureQuad', [Texture2D, Vector2, Vector2, Rectangle, Color], None)
_wrap(rlapi.DrawTextureTiled, '_DrawTextureTiled', [Texture2D, Rectangle, Rectangle, Vector2, Float, Float, Color], None)
_wrap(rlapi.DrawTexturePro, '_DrawTexturePro', [Texture2D, Rectangle, Rectangle, Vector2, Float, Color], None)
_wrap(rlapi.DrawTextureNPatch, '_DrawTextureNPatch', [Texture2D, NPatchInfo, Rectangle, Vector2, Float, Color], None)
_wrap(rlapi.DrawTexturePoly, '_DrawTexturePoly', [Texture2D, Vector2, Vector2Ptr, Vector2Ptr, Int, Color], None)
_wrap(rlapi.Fade, '_Fade', [Color, Float], Color)
_wrap(rlapi.ColorToInt, '_ColorToInt', [Color], Int)
_wrap(rlapi.ColorNormalize, '_ColorNormalize', [Color], Vector4)
_wrap(rlapi.ColorFromNormalized, '_ColorFromNormalized', [Vector4], Color)
_wrap(rlapi.ColorToHSV, '_ColorToHSV', [Color], Vector3)
_wrap(rlapi.ColorFromHSV, '_ColorFromHSV', [Float, Float, Float], Color)
_wrap(rlapi.ColorAlpha, '_ColorAlpha', [Color, Float], Color)
_wrap(rlapi.ColorAlphaBlend, '_ColorAlphaBlend', [Color, Color, Color], Color)
_wrap(rlapi.GetColor, '_GetColor', [UInt], Color)
_wrap(rlapi.GetPixelColor, '_GetPixelColor', [VoidPtr, Int], Color)
_wrap(rlapi.SetPixelColor, '_SetPixelColor', [VoidPtr, Color, Int], None)
_wrap(rlapi.GetPixelDataSize, '_GetPixelDataSize', [Int, Int, Int], Int)
_wrap(rlapi.GetFontDefault, '_GetFontDefault', [], Font)
_wrap(rlapi.LoadFont, '_LoadFont', [CharPtr], Font)
_wrap(rlapi.LoadFontEx, '_LoadFontEx', [CharPtr, Int, IntPtr, Int], Font)
_wrap(rlapi.LoadFontFromImage, '_LoadFontFromImage', [Image, Color, Int], Font)
_wrap(rlapi.LoadFontFromMemory, '_LoadFontFromMemory', [CharPtr, UBytePtr, Int, Int, IntPtr, Int], Font)
_wrap(rlapi.LoadFontData, '_LoadFontData', [UBytePtr, Int, Int, IntPtr, Int, Int], GlyphInfoPtr)
_wrap(rlapi.GenImageFontAtlas, '_GenImageFontAtlas', [GlyphInfoPtr, POINTER(RectanglePtr), Int, Int, Int, Int], Image)
_wrap(rlapi.UnloadFontData, '_UnloadFontData', [GlyphInfoPtr, Int], None)
_wrap(rlapi.UnloadFont, '_UnloadFont', [Font], None)
_wrap(rlapi.ExportFontAsCode, '_ExportFontAsCode', [Font, CharPtr], Bool)
_wrap(rlapi.DrawFPS, '_DrawFPS', [Int, Int], None)
_wrap(rlapi.DrawText, '_DrawText', [CharPtr, Int, Int, Int, Color], None)
_wrap(rlapi.DrawTextEx, '_DrawTextEx', [Font, CharPtr, Vector2, Float, Float, Color], None)
_wrap(rlapi.DrawTextPro, '_DrawTextPro', [Font, CharPtr, Vector2, Vector2, Float, Float, Float, Color], None)
_wrap(rlapi.DrawTextCodepoint, '_DrawTextCodepoint', [Font, Int, Vector2, Float, Color], None)
_wrap(rlapi.DrawTextCodepoints, '_DrawTextCodepoints', [Font, IntPtr, Int, Vector2, Float, Float, Color], None)
_wrap(rlapi.MeasureText, '_MeasureText', [CharPtr, Int], Int)
_wrap(rlapi.MeasureTextEx, '_MeasureTextEx', [Font, CharPtr, Float, Float], Vector2)
_wrap(rlapi.GetGlyphIndex, '_GetGlyphIndex', [Font, Int], Int)
_wrap(rlapi.GetGlyphInfo, '_GetGlyphInfo', [Font, Int], GlyphInfo)
_wrap(rlapi.GetGlyphAtlasRec, '_GetGlyphAtlasRec', [Font, Int], Rectangle)
_wrap(rlapi.LoadCodepoints, '_LoadCodepoints', [CharPtr, IntPtr], IntPtr)
_wrap(rlapi.UnloadCodepoints, '_UnloadCodepoints', [IntPtr], None)
_wrap(rlapi.GetCodepointCount, '_GetCodepointCount', [CharPtr], Int)
_wrap(rlapi.GetCodepoint, '_GetCodepoint', [CharPtr, IntPtr], Int)
_wrap(rlapi.CodepointToUTF8, '_CodepointToUTF8', [Int, IntPtr], CharPtr)
_wrap(rlapi.TextCodepointsToUTF8, '_TextCodepointsToUTF8', [IntPtr, Int], CharPtr)
_wrap(rlapi.TextCopy, '_TextCopy', [CharPtr, CharPtr], Int)
_wrap(rlapi.TextIsEqual, '_TextIsEqual', [CharPtr, CharPtr], Bool)
_wrap(rlapi.TextLength, '_TextLength', [CharPtr], UInt)
_wrap(rlapi.TextFormat, '_TextFormat', [CharPtr, VoidPtr], CharPtr)
_wrap(rlapi.TextSubtext, '_TextSubtext', [CharPtr, Int, Int], CharPtr)
_wrap(rlapi.TextReplace, '_TextReplace', [CharPtr, CharPtr, CharPtr], CharPtr)
_wrap(rlapi.TextInsert, '_TextInsert', [CharPtr, CharPtr, Int], CharPtr)
_wrap(rlapi.TextJoin, '_TextJoin', [POINTER(CharPtr), Int, CharPtr], CharPtr)
_wrap(rlapi.TextSplit, '_TextSplit', [CharPtr, Char, IntPtr], POINTER(CharPtr))
_wrap(rlapi.TextAppend, '_TextAppend', [CharPtr, CharPtr, IntPtr], None)
_wrap(rlapi.TextFindIndex, '_TextFindIndex', [CharPtr, CharPtr], Int)
_wrap(rlapi.TextToUpper, '_TextToUpper', [CharPtr], CharPtr)
_wrap(rlapi.TextToLower, '_TextToLower', [CharPtr], CharPtr)
_wrap(rlapi.TextToPascal, '_TextToPascal', [CharPtr], CharPtr)
_wrap(rlapi.TextToInteger, '_TextToInteger', [CharPtr], Int)
_wrap(rlapi.DrawLine3D, '_DrawLine3D', [Vector3, Vector3, Color], None)
_wrap(rlapi.DrawPoint3D, '_DrawPoint3D', [Vector3, Color], None)
_wrap(rlapi.DrawCircle3D, '_DrawCircle3D', [Vector3, Float, Vector3, Float, Color], None)
_wrap(rlapi.DrawTriangle3D, '_DrawTriangle3D', [Vector3, Vector3, Vector3, Color], None)
_wrap(rlapi.DrawTriangleStrip3D, '_DrawTriangleStrip3D', [Vector3Ptr, Int, Color], None)
_wrap(rlapi.DrawCube, '_DrawCube', [Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawCubeV, '_DrawCubeV', [Vector3, Vector3, Color], None)
_wrap(rlapi.DrawCubeWires, '_DrawCubeWires', [Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawCubeWiresV, '_DrawCubeWiresV', [Vector3, Vector3, Color], None)
_wrap(rlapi.DrawCubeTexture, '_DrawCubeTexture', [Texture2D, Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawCubeTextureRec, '_DrawCubeTextureRec', [Texture2D, Rectangle, Vector3, Float, Float, Float, Color], None)
_wrap(rlapi.DrawSphere, '_DrawSphere', [Vector3, Float, Color], None)
_wrap(rlapi.DrawSphereEx, '_DrawSphereEx', [Vector3, Float, Int, Int, Color], None)
_wrap(rlapi.DrawSphereWires, '_DrawSphereWires', [Vector3, Float, Int, Int, Color], None)
_wrap(rlapi.DrawCylinder, '_DrawCylinder', [Vector3, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCylinderEx, '_DrawCylinderEx', [Vector3, Vector3, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCylinderWires, '_DrawCylinderWires', [Vector3, Float, Float, Float, Int, Color], None)
_wrap(rlapi.DrawCylinderWiresEx, '_DrawCylinderWiresEx', [Vector3, Vector3, Float, Float, Int, Color], None)
_wrap(rlapi.DrawPlane, '_DrawPlane', [Vector3, Vector2, Color], None)
_wrap(rlapi.DrawRay, '_DrawRay', [Ray, Color], None)
_wrap(rlapi.DrawGrid, '_DrawGrid', [Int, Float], None)
_wrap(rlapi.LoadModel, '_LoadModel', [CharPtr], Model)
_wrap(rlapi.LoadModelFromMesh, '_LoadModelFromMesh', [Mesh], Model)
_wrap(rlapi.UnloadModel, '_UnloadModel', [Model], None)
_wrap(rlapi.UnloadModelKeepMeshes, '_UnloadModelKeepMeshes', [Model], None)
_wrap(rlapi.GetModelBoundingBox, '_GetModelBoundingBox', [Model], BoundingBox)
_wrap(rlapi.DrawModel, '_DrawModel', [Model, Vector3, Float, Color], None)
_wrap(rlapi.DrawModelEx, '_DrawModelEx', [Model, Vector3, Vector3, Float, Vector3, Color], None)
_wrap(rlapi.DrawModelWires, '_DrawModelWires', [Model, Vector3, Float, Color], None)
_wrap(rlapi.DrawModelWiresEx, '_DrawModelWiresEx', [Model, Vector3, Vector3, Float, Vector3, Color], None)
_wrap(rlapi.DrawBoundingBox, '_DrawBoundingBox', [BoundingBox, Color], None)
_wrap(rlapi.DrawBillboard, '_DrawBillboard', [Camera, Texture2D, Vector3, Float, Color], None)
_wrap(rlapi.DrawBillboardRec, '_DrawBillboardRec', [Camera, Texture2D, Rectangle, Vector3, Vector2, Color], None)
_wrap(rlapi.DrawBillboardPro, '_DrawBillboardPro', [Camera, Texture2D, Rectangle, Vector3, Vector3, Vector2, Vector2, Float, Color], None)
_wrap(rlapi.UploadMesh, '_UploadMesh', [MeshPtr, Bool], None)
_wrap(rlapi.UpdateMeshBuffer, '_UpdateMeshBuffer', [Mesh, Int, VoidPtr, Int, Int], None)
_wrap(rlapi.UnloadMesh, '_UnloadMesh', [Mesh], None)
_wrap(rlapi.DrawMesh, '_DrawMesh', [Mesh, Material, Matrix], None)
_wrap(rlapi.DrawMeshInstanced, '_DrawMeshInstanced', [Mesh, Material, MatrixPtr, Int], None)
_wrap(rlapi.ExportMesh, '_ExportMesh', [Mesh, CharPtr], Bool)
_wrap(rlapi.GetMeshBoundingBox, '_GetMeshBoundingBox', [Mesh], BoundingBox)
_wrap(rlapi.GenMeshTangents, '_GenMeshTangents', [MeshPtr], None)
_wrap(rlapi.GenMeshPoly, '_GenMeshPoly', [Int, Float], Mesh)
_wrap(rlapi.GenMeshPlane, '_GenMeshPlane', [Float, Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshCube, '_GenMeshCube', [Float, Float, Float], Mesh)
_wrap(rlapi.GenMeshSphere, '_GenMeshSphere', [Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshHemiSphere, '_GenMeshHemiSphere', [Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshCylinder, '_GenMeshCylinder', [Float, Float, Int], Mesh)
_wrap(rlapi.GenMeshCone, '_GenMeshCone', [Float, Float, Int], Mesh)
_wrap(rlapi.GenMeshTorus, '_GenMeshTorus', [Float, Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshKnot, '_GenMeshKnot', [Float, Float, Int, Int], Mesh)
_wrap(rlapi.GenMeshHeightmap, '_GenMeshHeightmap', [Image, Vector3], Mesh)
_wrap(rlapi.GenMeshCubicmap, '_GenMeshCubicmap', [Image, Vector3], Mesh)
_wrap(rlapi.LoadMaterials, '_LoadMaterials', [CharPtr, IntPtr], MaterialPtr)
_wrap(rlapi.LoadMaterialDefault, '_LoadMaterialDefault', [], Material)
_wrap(rlapi.UnloadMaterial, '_UnloadMaterial', [Material], None)
_wrap(rlapi.SetMaterialTexture, '_SetMaterialTexture', [MaterialPtr, Int, Texture2D], None)
_wrap(rlapi.SetModelMeshMaterial, '_SetModelMeshMaterial', [ModelPtr, Int, Int], None)
_wrap(rlapi.LoadModelAnimations, '_LoadModelAnimations', [CharPtr, UIntPtr], ModelAnimationPtr)
_wrap(rlapi.UpdateModelAnimation, '_UpdateModelAnimation', [Model, ModelAnimation, Int], None)
_wrap(rlapi.UnloadModelAnimation, '_UnloadModelAnimation', [ModelAnimation], None)
_wrap(rlapi.UnloadModelAnimations, '_UnloadModelAnimations', [ModelAnimationPtr, UInt], None)
_wrap(rlapi.IsModelAnimationValid, '_IsModelAnimationValid', [Model, ModelAnimation], Bool)
_wrap(rlapi.CheckCollisionSpheres, '_CheckCollisionSpheres', [Vector3, Float, Vector3, Float], Bool)
_wrap(rlapi.CheckCollisionBoxes, '_CheckCollisionBoxes', [BoundingBox, BoundingBox], Bool)
_wrap(rlapi.CheckCollisionBoxSphere, '_CheckCollisionBoxSphere', [BoundingBox, Vector3, Float], Bool)
_wrap(rlapi.GetRayCollisionSphere, '_GetRayCollisionSphere', [Ray, Vector3, Float], RayCollision)
_wrap(rlapi.GetRayCollisionBox, '_GetRayCollisionBox', [Ray, BoundingBox], RayCollision)
_wrap(rlapi.GetRayCollisionMesh, '_GetRayCollisionMesh', [Ray, Mesh, Matrix], RayCollision)
_wrap(rlapi.GetRayCollisionTriangle, '_GetRayCollisionTriangle', [Ray, Vector3, Vector3, Vector3], RayCollision)
_wrap(rlapi.GetRayCollisionQuad, '_GetRayCollisionQuad', [Ray, Vector3, Vector3, Vector3, Vector3], RayCollision)
_wrap(rlapi.InitAudioDevice, '_InitAudioDevice', [], None)
_wrap(rlapi.CloseAudioDevice, '_CloseAudioDevice', [], None)
_wrap(rlapi.IsAudioDeviceReady, '_IsAudioDeviceReady', [], Bool)
_wrap(rlapi.SetMasterVolume, '_SetMasterVolume', [Float], None)
_wrap(rlapi.LoadWave, '_LoadWave', [CharPtr], Wave)
_wrap(rlapi.LoadWaveFromMemory, '_LoadWaveFromMemory', [CharPtr, UBytePtr, Int], Wave)
_wrap(rlapi.LoadSound, '_LoadSound', [CharPtr], Sound)
_wrap(rlapi.LoadSoundFromWave, '_LoadSoundFromWave', [Wave], Sound)
_wrap(rlapi.UpdateSound, '_UpdateSound', [Sound, VoidPtr, Int], None)
_wrap(rlapi.UnloadWave, '_UnloadWave', [Wave], None)
_wrap(rlapi.UnloadSound, '_UnloadSound', [Sound], None)
_wrap(rlapi.ExportWave, '_ExportWave', [Wave, CharPtr], Bool)
_wrap(rlapi.ExportWaveAsCode, '_ExportWaveAsCode', [Wave, CharPtr], Bool)
_wrap(rlapi.PlaySound, '_PlaySound', [Sound], None)
_wrap(rlapi.StopSound, '_StopSound', [Sound], None)
_wrap(rlapi.PauseSound, '_PauseSound', [Sound], None)
_wrap(rlapi.ResumeSound, '_ResumeSound', [Sound], None)
_wrap(rlapi.PlaySoundMulti, '_PlaySoundMulti', [Sound], None)
_wrap(rlapi.StopSoundMulti, '_StopSoundMulti', [], None)
_wrap(rlapi.GetSoundsPlaying, '_GetSoundsPlaying', [], Int)
_wrap(rlapi.IsSoundPlaying, '_IsSoundPlaying', [Sound], Bool)
_wrap(rlapi.SetSoundVolume, '_SetSoundVolume', [Sound, Float], None)
_wrap(rlapi.SetSoundPitch, '_SetSoundPitch', [Sound, Float], None)
_wrap(rlapi.SetSoundPan, '_SetSoundPan', [Sound, Float], None)
_wrap(rlapi.WaveCopy, '_WaveCopy', [Wave], Wave)
_wrap(rlapi.WaveCrop, '_WaveCrop', [WavePtr, Int, Int], None)
_wrap(rlapi.WaveFormat, '_WaveFormat', [WavePtr, Int, Int, Int], None)
_wrap(rlapi.LoadWaveSamples, '_LoadWaveSamples', [Wave], FloatPtr)
_wrap(rlapi.UnloadWaveSamples, '_UnloadWaveSamples', [FloatPtr], None)
_wrap(rlapi.LoadMusicStream, '_LoadMusicStream', [CharPtr], Music)
_wrap(rlapi.LoadMusicStreamFromMemory, '_LoadMusicStreamFromMemory', [CharPtr, UBytePtr, Int], Music)
_wrap(rlapi.UnloadMusicStream, '_UnloadMusicStream', [Music], None)
_wrap(rlapi.PlayMusicStream, '_PlayMusicStream', [Music], None)
_wrap(rlapi.IsMusicStreamPlaying, '_IsMusicStreamPlaying', [Music], Bool)
_wrap(rlapi.UpdateMusicStream, '_UpdateMusicStream', [Music], None)
_wrap(rlapi.StopMusicStream, '_StopMusicStream', [Music], None)
_wrap(rlapi.PauseMusicStream, '_PauseMusicStream', [Music], None)
_wrap(rlapi.ResumeMusicStream, '_ResumeMusicStream', [Music], None)
_wrap(rlapi.SeekMusicStream, '_SeekMusicStream', [Music, Float], None)
_wrap(rlapi.SetMusicVolume, '_SetMusicVolume', [Music, Float], None)
_wrap(rlapi.SetMusicPitch, '_SetMusicPitch', [Music, Float], None)
_wrap(rlapi.SetMusicPan, '_SetMusicPan', [Music, Float], None)
_wrap(rlapi.GetMusicTimeLength, '_GetMusicTimeLength', [Music], Float)
_wrap(rlapi.GetMusicTimePlayed, '_GetMusicTimePlayed', [Music], Float)
_wrap(rlapi.LoadAudioStream, '_LoadAudioStream', [UInt, UInt, UInt], AudioStream)
_wrap(rlapi.UnloadAudioStream, '_UnloadAudioStream', [AudioStream], None)
_wrap(rlapi.UpdateAudioStream, '_UpdateAudioStream', [AudioStream, VoidPtr, Int], None)
_wrap(rlapi.IsAudioStreamProcessed, '_IsAudioStreamProcessed', [AudioStream], Bool)
_wrap(rlapi.PlayAudioStream, '_PlayAudioStream', [AudioStream], None)
_wrap(rlapi.PauseAudioStream, '_PauseAudioStream', [AudioStream], None)
_wrap(rlapi.ResumeAudioStream, '_ResumeAudioStream', [AudioStream], None)
_wrap(rlapi.IsAudioStreamPlaying, '_IsAudioStreamPlaying', [AudioStream], Bool)
_wrap(rlapi.StopAudioStream, '_StopAudioStream', [AudioStream], None)
_wrap(rlapi.SetAudioStreamVolume, '_SetAudioStreamVolume', [AudioStream, Float], None)
_wrap(rlapi.SetAudioStreamPitch, '_SetAudioStreamPitch', [AudioStream, Float], None)
_wrap(rlapi.SetAudioStreamPan, '_SetAudioStreamPan', [AudioStream, Float], None)
_wrap(rlapi.SetAudioStreamBufferSizeDefault, '_SetAudioStreamBufferSizeDefault', [Int], None)
_wrap(rlapi.SetAudioStreamCallback, '_SetAudioStreamCallback', [AudioStream, AudioCallback], None)
_wrap(rlapi.AttachAudioStreamProcessor, '_AttachAudioStreamProcessor', [AudioStream, AudioCallback], None)
_wrap(rlapi.DetachAudioStreamProcessor, '_DetachAudioStreamProcessor', [AudioStream, AudioCallback], None)
_wrap(rlapi.Clamp, '_Clamp', [Float, Float, Float], Float)
_wrap(rlapi.Lerp, '_Lerp', [Float, Float, Float], Float)
_wrap(rlapi.Normalize, '_Normalize', [Float, Float, Float], Float)
_wrap(rlapi.Remap, '_Remap', [Float, Float, Float, Float, Float], Float)
_wrap(rlapi.Wrap, '_Wrap', [Float, Float, Float], Float)
_wrap(rlapi.FloatEquals, '_FloatEquals', [Float, Float], Int)
_wrap(rlapi.Vector2Zero, '_Vector2Zero', [], Vector2)
_wrap(rlapi.Vector2One, '_Vector2One', [], Vector2)
_wrap(rlapi.Vector2Add, '_Vector2Add', [Vector2, Vector2], Vector2)
_wrap(rlapi.Vector2AddValue, '_Vector2AddValue', [Vector2, Float], Vector2)
_wrap(rlapi.Vector2Subtract, '_Vector2Subtract', [Vector2, Vector2], Vector2)
_wrap(rlapi.Vector2SubtractValue, '_Vector2SubtractValue', [Vector2, Float], Vector2)
_wrap(rlapi.Vector2Length, '_Vector2Length', [Vector2], Float)
_wrap(rlapi.Vector2LengthSqr, '_Vector2LengthSqr', [Vector2], Float)
_wrap(rlapi.Vector2DotProduct, '_Vector2DotProduct', [Vector2, Vector2], Float)
_wrap(rlapi.Vector2Distance, '_Vector2Distance', [Vector2, Vector2], Float)
_wrap(rlapi.Vector2DistanceSqr, '_Vector2DistanceSqr', [Vector2, Vector2], Float)
_wrap(rlapi.Vector2Angle, '_Vector2Angle', [Vector2, Vector2], Float)
_wrap(rlapi.Vector2Scale, '_Vector2Scale', [Vector2, Float], Vector2)
_wrap(rlapi.Vector2Multiply, '_Vector2Multiply', [Vector2, Vector2], Vector2)
_wrap(rlapi.Vector2Negate, '_Vector2Negate', [Vector2], Vector2)
_wrap(rlapi.Vector2Divide, '_Vector2Divide', [Vector2, Vector2], Vector2)
_wrap(rlapi.Vector2Normalize, '_Vector2Normalize', [Vector2], Vector2)
_wrap(rlapi.Vector2Transform, '_Vector2Transform', [Vector2, Matrix], Vector2)
_wrap(rlapi.Vector2Lerp, '_Vector2Lerp', [Vector2, Vector2, Float], Vector2)
_wrap(rlapi.Vector2Reflect, '_Vector2Reflect', [Vector2, Vector2], Vector2)
_wrap(rlapi.Vector2Rotate, '_Vector2Rotate', [Vector2, Float], Vector2)
_wrap(rlapi.Vector2MoveTowards, '_Vector2MoveTowards', [Vector2, Vector2, Float], Vector2)
_wrap(rlapi.Vector2Invert, '_Vector2Invert', [Vector2], Vector2)
_wrap(rlapi.Vector2Clamp, '_Vector2Clamp', [Vector2, Vector2, Vector2], Vector2)
_wrap(rlapi.Vector2ClampValue, '_Vector2ClampValue', [Vector2, Float, Float], Vector2)
_wrap(rlapi.Vector2Equals, '_Vector2Equals', [Vector2, Vector2], Int)
_wrap(rlapi.Vector3Zero, '_Vector3Zero', [], Vector3)
_wrap(rlapi.Vector3One, '_Vector3One', [], Vector3)
_wrap(rlapi.Vector3Add, '_Vector3Add', [Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3AddValue, '_Vector3AddValue', [Vector3, Float], Vector3)
_wrap(rlapi.Vector3Subtract, '_Vector3Subtract', [Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3SubtractValue, '_Vector3SubtractValue', [Vector3, Float], Vector3)
_wrap(rlapi.Vector3Scale, '_Vector3Scale', [Vector3, Float], Vector3)
_wrap(rlapi.Vector3Multiply, '_Vector3Multiply', [Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3CrossProduct, '_Vector3CrossProduct', [Vector3, Vector3], Float)
_wrap(rlapi.Vector3Perpendicular, '_Vector3Perpendicular', [Vector3], Vector3)
_wrap(rlapi.Vector3Length, '_Vector3Length', [Vector3], Vector3)
_wrap(rlapi.Vector3LengthSqr, '_Vector3LengthSqr', [Vector3], Vector3)
_wrap(rlapi.Vector3DotProduct, '_Vector3DotProduct', [Vector3, Vector3], Float)
_wrap(rlapi.Vector3Distance, '_Vector3Distance', [Vector3, Vector3], Float)
_wrap(rlapi.Vector3DistanceSqr, '_Vector3DistanceSqr', [Vector3, Vector3], Float)
_wrap(rlapi.Vector3Angle, '_Vector3Angle', [Vector3, Vector3], Float)
_wrap(rlapi.Vector3Negate, '_Vector3Negate', [Vector3], Vector3)
_wrap(rlapi.Vector3Divide, '_Vector3Divide', [Vector3, Vector3], Float)
_wrap(rlapi.Vector3Normalize, '_Vector3Normalize', [Vector3], Vector3)
_wrap(rlapi.Vector3OrthoNormalize, '_Vector3OrthoNormalize', [Vector3Ptr, Vector3Ptr], Vector3)
_wrap(rlapi.Vector3Transform, '_Vector3Transform', [Vector3, Matrix], Vector3)
_wrap(rlapi.Vector3RotateByQuaternion, '_Vector3RotateByQuaternion', [Vector3, Quaternion], Vector3)
_wrap(rlapi.Vector3RotateByAxisAngle, '_Vector3RotateByAxisAngle', [Vector3, Vector3, Float], Vector3)
_wrap(rlapi.Vector3Lerp, '_Vector3Lerp', [Vector3, Vector3, Float], Vector3)
_wrap(rlapi.Vector3Reflect, '_Vector3Reflect', [Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3Min, '_Vector3Min', [Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3Max, '_Vector3Max', [Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3Barycenter, '_Vector3Barycenter', [Vector3, Vector3, Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3Unproject, '_Vector3Unproject', [Vector3, Matrix, Matrix], Vector3)
_wrap(rlapi.Vector3ToFloatV, '_Vector3ToFloatV', [Vector3], Float * 3)
_wrap(rlapi.Vector3Invert, '_Vector3Invert', [Vector3], Vector3)
_wrap(rlapi.Vector3Clamp, '_Vector3Clamp', [Vector3, Vector3, Vector3], Vector3)
_wrap(rlapi.Vector3ClampValue, '_Vector3ClampValue', [Vector3, Float, Float], Vector3)
_wrap(rlapi.Vector3Equals, '_Vector3Equals', [Vector3, Float, Float], Int)
_wrap(rlapi.Vector3Refract, '_Vector3Refract', [Vector3, Vector3, Float], Int)
_wrap(rlapi.MatrixDeterminant, '_MatrixDeterminant', [Matrix], Float)
_wrap(rlapi.MatrixTrace, '_MatrixTrace', [Matrix], Float)
_wrap(rlapi.MatrixTranspose, '_MatrixTranspose', [Matrix], Matrix)
_wrap(rlapi.MatrixInvert, '_MatrixInvert', [Matrix], Matrix)
_wrap(rlapi.MatrixIdentity, '_MatrixIdentity', [], Matrix)
_wrap(rlapi.MatrixAdd, '_MatrixAdd', [Matrix, Matrix], Matrix)
_wrap(rlapi.MatrixSubtract, '_MatrixSubtract', [Matrix, Matrix], Matrix)
_wrap(rlapi.MatrixMultiply, '_MatrixMultiply', [Matrix, Matrix], Matrix)
_wrap(rlapi.MatrixTranslate, '_MatrixTranslate', [Float, Float, Float], Matrix)
_wrap(rlapi.MatrixRotate, '_MatrixRotate', [Vector3, Float], Matrix)
_wrap(rlapi.MatrixRotateX, '_MatrixRotateX', [Float], Matrix)
_wrap(rlapi.MatrixRotateY, '_MatrixRotateY', [Float], Matrix)
_wrap(rlapi.MatrixRotateZ, '_MatrixRotateZ', [Float], Matrix)
_wrap(rlapi.MatrixRotateXYZ, '_MatrixRotateXYZ', [Vector3], Matrix)
_wrap(rlapi.MatrixRotateZYX, '_MatrixRotateZYX', [Vector3], Matrix)
_wrap(rlapi.MatrixScale, '_MatrixScale', [Float, Float, Float], Matrix)
_wrap(rlapi.MatrixFrustum, '_MatrixFrustum', [Float, Float, Float, Float, Float, Float], Matrix)
_wrap(rlapi.MatrixPerspective, '_MatrixPerspective', [Float, Float, Float, Float], Matrix)
_wrap(rlapi.MatrixOrtho, '_MatrixOrtho', [Float, Float, Float, Float, Float, Float], Matrix)
_wrap(rlapi.MatrixLookAt, '_MatrixLookAt', [Vector3, Vector3, Vector3], Matrix)
_wrap(rlapi.MatrixToFloatV, '_MatrixToFloatV', [Matrix], Float * 16)
_wrap(rlapi.QuaternionAdd, '_QuaternionAdd', [Quaternion, Quaternion], Quaternion)
_wrap(rlapi.QuaternionAddValue, '_QuaternionAddValue', [Quaternion, Float], Quaternion)
_wrap(rlapi.QuaternionSubtract, '_QuaternionSubtract', [Quaternion, Quaternion], Quaternion)
_wrap(rlapi.QuaternionSubtractValue, '_QuaternionSubtractValue', [Quaternion, Float], Quaternion)
_wrap(rlapi.QuaternionIdentity, '_QuaternionIdentity', [], Quaternion)
_wrap(rlapi.QuaternionLength, '_QuaternionLength', [Quaternion], Quaternion)
_wrap(rlapi.QuaternionNormalize, '_QuaternionNormalize', [Quaternion], Quaternion)
_wrap(rlapi.QuaternionInvert, '_QuaternionInvert', [Quaternion], Quaternion)
_wrap(rlapi.QuaternionMultiply, '_QuaternionMultiply', [Quaternion, Quaternion], Quaternion)
_wrap(rlapi.QuaternionScale, '_QuaternionScale', [Quaternion, Float], Quaternion)
_wrap(rlapi.QuaternionDivide, '_QuaternionDivide', [Quaternion, Quaternion], Quaternion)
_wrap(rlapi.QuaternionNlerp, '_QuaternionNlerp', [Quaternion, Quaternion, Float], Quaternion)
_wrap(rlapi.QuaternionSlerp, '_QuaternionSlerp', [Quaternion, Quaternion, Float], Quaternion)
_wrap(rlapi.QuaternionFromVector3ToVector3, '_QuaternionFromVector3ToVector3', [Vector3, Vector3], Quaternion)
_wrap(rlapi.QuaternionToMatrix, '_QuaternionToMatrix', [Quaternion], Matrix)
_wrap(rlapi.QuaternionFromMatrix, '_QuaternionFromMatrix', [Matrix], Quaternion)
_wrap(rlapi.QuaternionFromAxisAngle, '_QuaternionFromAxisAngle', [Vector3, Float], Quaternion)
_wrap(rlapi.QuaternionToAxisAngle, '_QuaternionToAxisAngle', [Quaternion, Vector3Ptr, FloatPtr], None)
_wrap(rlapi.QuaternionFromEuler, '_QuaternionFromEuler', [Float, Float, Float], Quaternion)
_wrap(rlapi.QuaternionToEuler, '_QuaternionToEuler', [Quaternion], Vector3)
_wrap(rlapi.QuaternionTransform, '_QuaternionTransform', [Quaternion, Matrix], Quaternion)
_wrap(rlapi.QuaternionEquals, '_QuaternionEquals', [Quaternion, Quaternion], Int)

# endregion (prototypes)
# region API


def init_window(width: int, height: int, title: bytes) -> None:
    # type: (int, int, bytes) -> None
    '''Initialize window and OpenGL context

    Raylib's C API: InitWindow

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param bytes title: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _InitWindow(int(width), int(height), _str_in(title))


def window_should_close() -> bool:
    # type: () -> bool
    '''Check if KEY_ESCAPE pressed or Close icon pressed

    Raylib's C API: WindowShouldClose

    :return: bool (`bool` in C raylib)
    '''
    result = _WindowShouldClose()
    return result


def close_window() -> None:
    # type: () -> None
    '''Close window and unload OpenGL context

    Raylib's C API: CloseWindow

    :return: None (`void` in C raylib)
    '''
    _CloseWindow()


def is_window_ready() -> bool:
    # type: () -> bool
    '''Check if window has been initialized successfully

    Raylib's C API: IsWindowReady

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowReady()
    return result


def is_window_fullscreen() -> bool:
    # type: () -> bool
    '''Check if window is currently fullscreen

    Raylib's C API: IsWindowFullscreen

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowFullscreen()
    return result


def is_window_hidden() -> bool:
    # type: () -> bool
    '''Check if window is currently hidden (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowHidden

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowHidden()
    return result


def is_window_minimized() -> bool:
    # type: () -> bool
    '''Check if window is currently minimized (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowMinimized

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowMinimized()
    return result


def is_window_maximized() -> bool:
    # type: () -> bool
    '''Check if window is currently maximized (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowMaximized

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowMaximized()
    return result


def is_window_focused() -> bool:
    # type: () -> bool
    '''Check if window is currently focused (only PLATFORM_DESKTOP)

    Raylib's C API: IsWindowFocused

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowFocused()
    return result


def is_window_resized() -> bool:
    # type: () -> bool
    '''Check if window has been resized last frame

    Raylib's C API: IsWindowResized

    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowResized()
    return result


def is_window_state(flag: int) -> bool:
    # type: (int) -> bool
    '''Check if one specific window flag is enabled

    Raylib's C API: IsWindowState

    :param int flag: `unsigned int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsWindowState(int(flag))
    return result


def set_window_state(flags: int) -> None:
    # type: (int) -> None
    '''Set window configuration state using flags (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowState

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowState(int(flags))


def clear_window_state(flags: int) -> None:
    # type: (int) -> None
    '''Clear window configuration state flags

    Raylib's C API: ClearWindowState

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ClearWindowState(int(flags))


def toggle_fullscreen() -> None:
    # type: () -> None
    '''Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)

    Raylib's C API: ToggleFullscreen

    :return: None (`void` in C raylib)
    '''
    _ToggleFullscreen()


def maximize_window() -> None:
    # type: () -> None
    '''Set window state: maximized, if resizable (only PLATFORM_DESKTOP)

    Raylib's C API: MaximizeWindow

    :return: None (`void` in C raylib)
    '''
    _MaximizeWindow()


def minimize_window() -> None:
    # type: () -> None
    '''Set window state: minimized, if resizable (only PLATFORM_DESKTOP)

    Raylib's C API: MinimizeWindow

    :return: None (`void` in C raylib)
    '''
    _MinimizeWindow()


def restore_window() -> None:
    # type: () -> None
    '''Set window state: not minimized/maximized (only PLATFORM_DESKTOP)

    Raylib's C API: RestoreWindow

    :return: None (`void` in C raylib)
    '''
    _RestoreWindow()


def set_window_icon(image: Image) -> None:
    # type: (Image) -> None
    '''Set icon for window (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowIcon

    :param Image image: `Image` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowIcon(image)


def set_window_title(title: bytes) -> None:
    # type: (bytes) -> None
    '''Set title for window (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowTitle

    :param bytes title: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowTitle(_str_in(title))


def set_window_position(x: int, y: int) -> None:
    # type: (int, int) -> None
    '''Set window position on screen (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowPosition

    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowPosition(int(x), int(y))


def set_window_monitor(monitor: int) -> None:
    # type: (int) -> None
    '''Set monitor for the current window (fullscreen mode)

    Raylib's C API: SetWindowMonitor

    :param int monitor: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowMonitor(int(monitor))


def set_window_min_size(width: int, height: int) -> None:
    # type: (int, int) -> None
    '''Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)

    Raylib's C API: SetWindowMinSize

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowMinSize(int(width), int(height))


def set_window_size(width: int, height: int) -> None:
    # type: (int, int) -> None
    '''Set window dimensions

    Raylib's C API: SetWindowSize

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowSize(int(width), int(height))


def set_window_opacity(opacity: float) -> None:
    # type: (float) -> None
    '''Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)

    Raylib's C API: SetWindowOpacity

    :param float opacity: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetWindowOpacity(float(opacity))


def get_window_handle() -> bytes:
    # type: () -> bytes
    '''Get native window handle

    Raylib's C API: GetWindowHandle

    :return: bytes (`void *` in C raylib)
    '''
    result = _GetWindowHandle()
    return result


def get_screen_width() -> int:
    # type: () -> int
    '''Get current screen width

    Raylib's C API: GetScreenWidth

    :return: int (`int` in C raylib)
    '''
    result = _GetScreenWidth()
    return result


def get_screen_height() -> int:
    # type: () -> int
    '''Get current screen height

    Raylib's C API: GetScreenHeight

    :return: int (`int` in C raylib)
    '''
    result = _GetScreenHeight()
    return result


def get_render_width() -> int:
    # type: () -> int
    '''Get current render width (it considers HiDPI)

    Raylib's C API: GetRenderWidth

    :return: int (`int` in C raylib)
    '''
    result = _GetRenderWidth()
    return result


def get_render_height() -> int:
    # type: () -> int
    '''Get current render height (it considers HiDPI)

    Raylib's C API: GetRenderHeight

    :return: int (`int` in C raylib)
    '''
    result = _GetRenderHeight()
    return result


def get_monitor_count() -> int:
    # type: () -> int
    '''Get number of connected monitors

    Raylib's C API: GetMonitorCount

    :return: int (`int` in C raylib)
    '''
    result = _GetMonitorCount()
    return result


def get_current_monitor() -> int:
    # type: () -> int
    '''Get current connected monitor

    Raylib's C API: GetCurrentMonitor

    :return: int (`int` in C raylib)
    '''
    result = _GetCurrentMonitor()
    return result


def get_monitor_position(monitor: int) -> Vector2:
    # type: (int) -> Vector2
    '''Get specified monitor position

    Raylib's C API: GetMonitorPosition

    :param int monitor: `int` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetMonitorPosition(int(monitor))
    return result


def get_monitor_width(monitor: int) -> int:
    # type: (int) -> int
    '''Get specified monitor width (current video mode used by monitor)

    Raylib's C API: GetMonitorWidth

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetMonitorWidth(int(monitor))
    return result


def get_monitor_height(monitor: int) -> int:
    # type: (int) -> int
    '''Get specified monitor height (current video mode used by monitor)

    Raylib's C API: GetMonitorHeight

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetMonitorHeight(int(monitor))
    return result


def get_monitor_physical_width(monitor: int) -> int:
    # type: (int) -> int
    '''Get specified monitor physical width in millimetres

    Raylib's C API: GetMonitorPhysicalWidth

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetMonitorPhysicalWidth(int(monitor))
    return result


def get_monitor_physical_height(monitor: int) -> int:
    # type: (int) -> int
    '''Get specified monitor physical height in millimetres

    Raylib's C API: GetMonitorPhysicalHeight

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetMonitorPhysicalHeight(int(monitor))
    return result


def get_monitor_refresh_rate(monitor: int) -> int:
    # type: (int) -> int
    '''Get specified monitor refresh rate

    Raylib's C API: GetMonitorRefreshRate

    :param int monitor: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetMonitorRefreshRate(int(monitor))
    return result


def get_window_position() -> Vector2:
    # type: () -> Vector2
    '''Get window position XY on monitor

    Raylib's C API: GetWindowPosition

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetWindowPosition()
    return result


def get_window_scale_dpi() -> Vector2:
    # type: () -> Vector2
    '''Get window scale DPI factor

    Raylib's C API: GetWindowScaleDPI

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetWindowScaleDPI()
    return result


def get_monitor_name(monitor: int) -> bytes:
    # type: (int) -> bytes
    '''Get the human-readable, UTF-8 encoded name of the primary monitor

    Raylib's C API: GetMonitorName

    :param int monitor: `int` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetMonitorName(int(monitor))
    return result


def set_clipboard_text(text: bytes) -> None:
    # type: (bytes) -> None
    '''Set clipboard text content

    Raylib's C API: SetClipboardText

    :param bytes text: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetClipboardText(_str_in(text))


def get_clipboard_text() -> bytes:
    # type: () -> bytes
    '''Get clipboard text content

    Raylib's C API: GetClipboardText

    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetClipboardText()
    return result


def enable_event_waiting() -> None:
    # type: () -> None
    '''Enable waiting for events on EndDrawing(), no automatic event polling

    Raylib's C API: EnableEventWaiting

    :return: None (`void` in C raylib)
    '''
    _EnableEventWaiting()


def disable_event_waiting() -> None:
    # type: () -> None
    '''Disable waiting for events on EndDrawing(), automatic events polling

    Raylib's C API: DisableEventWaiting

    :return: None (`void` in C raylib)
    '''
    _DisableEventWaiting()


def swap_screen_buffer() -> None:
    # type: () -> None
    '''Swap back buffer with front buffer (screen drawing)

    Raylib's C API: SwapScreenBuffer

    :return: None (`void` in C raylib)
    '''
    _SwapScreenBuffer()


def poll_input_events() -> None:
    # type: () -> None
    '''Register all input events

    Raylib's C API: PollInputEvents

    :return: None (`void` in C raylib)
    '''
    _PollInputEvents()


def wait_time(seconds: float) -> None:
    # type: (float) -> None
    '''Wait for some time (halt program execution)

    Raylib's C API: WaitTime

    :param float seconds: `double` in C raylib
    :return: None (`void` in C raylib)
    '''
    _WaitTime(float(seconds))


def show_cursor() -> None:
    # type: () -> None
    '''Shows cursor

    Raylib's C API: ShowCursor

    :return: None (`void` in C raylib)
    '''
    _ShowCursor()


def hide_cursor() -> None:
    # type: () -> None
    '''Hides cursor

    Raylib's C API: HideCursor

    :return: None (`void` in C raylib)
    '''
    _HideCursor()


def is_cursor_hidden() -> bool:
    # type: () -> bool
    '''Check if cursor is not visible

    Raylib's C API: IsCursorHidden

    :return: bool (`bool` in C raylib)
    '''
    result = _IsCursorHidden()
    return result


def enable_cursor() -> None:
    # type: () -> None
    '''Enables cursor (unlock cursor)

    Raylib's C API: EnableCursor

    :return: None (`void` in C raylib)
    '''
    _EnableCursor()


def disable_cursor() -> None:
    # type: () -> None
    '''Disables cursor (lock cursor)

    Raylib's C API: DisableCursor

    :return: None (`void` in C raylib)
    '''
    _DisableCursor()


def is_cursor_on_screen() -> bool:
    # type: () -> bool
    '''Check if cursor is on the screen

    Raylib's C API: IsCursorOnScreen

    :return: bool (`bool` in C raylib)
    '''
    result = _IsCursorOnScreen()
    return result


def clear_background(color: Color) -> None:
    # type: (Color) -> None
    '''Set background color (framebuffer clear color)

    Raylib's C API: ClearBackground

    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ClearBackground(color)


def begin_drawing() -> None:
    # type: () -> None
    '''Setup canvas (framebuffer) to start drawing

    Raylib's C API: BeginDrawing

    :return: None (`void` in C raylib)
    '''
    _BeginDrawing()


def end_drawing() -> None:
    # type: () -> None
    '''End canvas drawing and swap buffers (double buffering)

    Raylib's C API: EndDrawing

    :return: None (`void` in C raylib)
    '''
    _EndDrawing()


def begin_mode2d(camera: Camera2D) -> None:
    # type: (Camera2D) -> None
    '''Begin 2D mode with custom camera (2D)

    Raylib's C API: BeginMode2D

    :param Camera2D camera: `Camera2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginMode2D(camera)


def end_mode2d() -> None:
    # type: () -> None
    '''Ends 2D mode with custom camera

    Raylib's C API: EndMode2D

    :return: None (`void` in C raylib)
    '''
    _EndMode2D()


def begin_mode3d(camera: Camera3D) -> None:
    # type: (Camera3D) -> None
    '''Begin 3D mode with custom camera (3D)

    Raylib's C API: BeginMode3D

    :param Camera3D camera: `Camera3D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginMode3D(camera)


def end_mode3d() -> None:
    # type: () -> None
    '''Ends 3D mode and returns to default 2D orthographic mode

    Raylib's C API: EndMode3D

    :return: None (`void` in C raylib)
    '''
    _EndMode3D()


def begin_texture_mode(target: RenderTexture2D) -> None:
    # type: (RenderTexture2D) -> None
    '''Begin drawing to render texture

    Raylib's C API: BeginTextureMode

    :param RenderTexture2D target: `RenderTexture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginTextureMode(target)


def end_texture_mode() -> None:
    # type: () -> None
    '''Ends drawing to render texture

    Raylib's C API: EndTextureMode

    :return: None (`void` in C raylib)
    '''
    _EndTextureMode()


def begin_shader_mode(shader: Shader) -> None:
    # type: (Shader) -> None
    '''Begin custom shader drawing

    Raylib's C API: BeginShaderMode

    :param Shader shader: `Shader` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginShaderMode(shader)


def end_shader_mode() -> None:
    # type: () -> None
    '''End custom shader drawing (use default shader)

    Raylib's C API: EndShaderMode

    :return: None (`void` in C raylib)
    '''
    _EndShaderMode()


def begin_blend_mode(mode: int) -> None:
    # type: (int) -> None
    '''Begin blending mode (alpha, additive, multiplied, subtract, custom)

    Raylib's C API: BeginBlendMode

    :param int mode: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginBlendMode(int(mode))


def end_blend_mode() -> None:
    # type: () -> None
    '''End blending mode (reset to default: alpha blending)

    Raylib's C API: EndBlendMode

    :return: None (`void` in C raylib)
    '''
    _EndBlendMode()


def begin_scissor_mode(x: int, y: int, width: int, height: int) -> None:
    # type: (int, int, int, int) -> None
    '''Begin scissor mode (define screen area for following drawing)

    Raylib's C API: BeginScissorMode

    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginScissorMode(int(x), int(y), int(width), int(height))


def end_scissor_mode() -> None:
    # type: () -> None
    '''End scissor mode

    Raylib's C API: EndScissorMode

    :return: None (`void` in C raylib)
    '''
    _EndScissorMode()


def begin_vr_stereo_mode(config: VrStereoConfig) -> None:
    # type: (VrStereoConfig) -> None
    '''Begin stereo rendering (requires VR simulator)

    Raylib's C API: BeginVrStereoMode

    :param VrStereoConfig config: `VrStereoConfig` in C raylib
    :return: None (`void` in C raylib)
    '''
    _BeginVrStereoMode(config)


def end_vr_stereo_mode() -> None:
    # type: () -> None
    '''End stereo rendering (requires VR simulator)

    Raylib's C API: EndVrStereoMode

    :return: None (`void` in C raylib)
    '''
    _EndVrStereoMode()


def load_vr_stereo_config(device: VrDeviceInfo) -> VrStereoConfig:
    # type: (VrDeviceInfo) -> VrStereoConfig
    '''Load VR stereo config for VR simulator device parameters

    Raylib's C API: LoadVrStereoConfig

    :param VrDeviceInfo device: `VrDeviceInfo` in C raylib
    :return: VrStereoConfig (`VrStereoConfig` in C raylib)
    '''
    result = _LoadVrStereoConfig(device)
    return result


def unload_vr_stereo_config(config: VrStereoConfig) -> None:
    # type: (VrStereoConfig) -> None
    '''Unload VR stereo config

    Raylib's C API: UnloadVrStereoConfig

    :param VrStereoConfig config: `VrStereoConfig` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadVrStereoConfig(config)


def load_shader(vs_file_name: bytes, fs_file_name: bytes) -> Shader:
    # type: (bytes, bytes) -> Shader
    '''Load shader from files and bind default locations

    Raylib's C API: LoadShader

    :param bytes vs_file_name: `const char *` in C raylib
    :param bytes fs_file_name: `const char *` in C raylib
    :return: Shader (`Shader` in C raylib)
    '''
    result = _LoadShader(_str_in(vs_file_name), _str_in(fs_file_name))
    return result


def load_shader_from_memory(vs_code: bytes, fs_code: bytes) -> Shader:
    # type: (bytes, bytes) -> Shader
    '''Load shader from code strings and bind default locations

    Raylib's C API: LoadShaderFromMemory

    :param bytes vs_code: `const char *` in C raylib
    :param bytes fs_code: `const char *` in C raylib
    :return: Shader (`Shader` in C raylib)
    '''
    result = _LoadShaderFromMemory(_str_in(vs_code), _str_in(fs_code))
    return result


def get_shader_location(shader: Shader, uniform_name: bytes) -> int:
    # type: (Shader, bytes) -> int
    '''Get shader uniform location

    Raylib's C API: GetShaderLocation

    :param Shader shader: `Shader` in C raylib
    :param bytes uniform_name: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetShaderLocation(shader, _str_in(uniform_name))
    return result


def get_shader_location_attrib(shader: Shader, attrib_name: bytes) -> int:
    # type: (Shader, bytes) -> int
    '''Get shader attribute location

    Raylib's C API: GetShaderLocationAttrib

    :param Shader shader: `Shader` in C raylib
    :param bytes attrib_name: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetShaderLocationAttrib(shader, _str_in(attrib_name))
    return result


def set_shader_value(shader: Shader, loc_index: int, value: bytes, uniform_type: int) -> None:
    # type: (Shader, int, bytes, int) -> None
    '''Set shader uniform value

    Raylib's C API: SetShaderValue

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param bytes value: `const void *` in C raylib
    :param int uniform_type: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    value_ref = cast(value, VoidPtr)
    _SetShaderValue(shader, int(loc_index), value_ref, int(uniform_type))


def set_shader_value_v(shader: Shader, loc_index: int, value: bytes, uniform_type: int, count: int) -> None:
    # type: (Shader, int, bytes, int, int) -> None
    '''Set shader uniform value vector

    Raylib's C API: SetShaderValueV

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param bytes value: `const void *` in C raylib
    :param int uniform_type: `int` in C raylib
    :param int count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    value_ref = cast(value, VoidPtr)
    _SetShaderValueV(shader, int(loc_index), value_ref, int(uniform_type), int(count))


def set_shader_value_matrix(shader: Shader, loc_index: int, mat: Matrix) -> None:
    # type: (Shader, int, Matrix) -> None
    '''Set shader uniform value (matrix 4x4)

    Raylib's C API: SetShaderValueMatrix

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param Matrix mat: `Matrix` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetShaderValueMatrix(shader, int(loc_index), mat)


def set_shader_value_texture(shader: Shader, loc_index: int, texture: Texture2D) -> None:
    # type: (Shader, int, Texture2D) -> None
    '''Set shader uniform value for texture (sampler2d)

    Raylib's C API: SetShaderValueTexture

    :param Shader shader: `Shader` in C raylib
    :param int loc_index: `int` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetShaderValueTexture(shader, int(loc_index), texture)


def unload_shader(shader: Shader) -> None:
    # type: (Shader) -> None
    '''Unload shader from GPU memory (VRAM)

    Raylib's C API: UnloadShader

    :param Shader shader: `Shader` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadShader(shader)


def get_mouse_ray(mouse_position: Vector2, camera: Camera) -> Ray:
    # type: (Vector2, Camera) -> Ray
    '''Get a ray trace from mouse position

    Raylib's C API: GetMouseRay

    :param Vector2 mouse_position: `Vector2` in C raylib
    :param Camera camera: `Camera` in C raylib
    :return: Ray (`Ray` in C raylib)
    '''
    result = _GetMouseRay(mouse_position, camera)
    return result


def get_camera_matrix(camera: Camera) -> Matrix:
    # type: (Camera) -> Matrix
    '''Get camera transform matrix (view matrix)

    Raylib's C API: GetCameraMatrix

    :param Camera camera: `Camera` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _GetCameraMatrix(camera)
    return result


def get_camera_matrix2d(camera: Camera2D) -> Matrix:
    # type: (Camera2D) -> Matrix
    '''Get camera 2d transform matrix

    Raylib's C API: GetCameraMatrix2D

    :param Camera2D camera: `Camera2D` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _GetCameraMatrix2D(camera)
    return result


def get_world_to_screen(position: Vector3, camera: Camera) -> Vector2:
    # type: (Vector3, Camera) -> Vector2
    '''Get the screen space position for a 3d world space position

    Raylib's C API: GetWorldToScreen

    :param Vector3 position: `Vector3` in C raylib
    :param Camera camera: `Camera` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetWorldToScreen(position, camera)
    return result


def get_screen_to_world2d(position: Vector2, camera: Camera2D) -> Vector2:
    # type: (Vector2, Camera2D) -> Vector2
    '''Get the world space position for a 2d camera screen space position

    Raylib's C API: GetScreenToWorld2D

    :param Vector2 position: `Vector2` in C raylib
    :param Camera2D camera: `Camera2D` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetScreenToWorld2D(position, camera)
    return result


def get_world_to_screen_ex(position: Vector3, camera: Camera, width: int, height: int) -> Vector2:
    # type: (Vector3, Camera, int, int) -> Vector2
    '''Get size position for a 3d world space position

    Raylib's C API: GetWorldToScreenEx

    :param Vector3 position: `Vector3` in C raylib
    :param Camera camera: `Camera` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetWorldToScreenEx(position, camera, int(width), int(height))
    return result


def get_world_to_screen2d(position: Vector2, camera: Camera2D) -> Vector2:
    # type: (Vector2, Camera2D) -> Vector2
    '''Get the screen space position for a 2d camera world space position

    Raylib's C API: GetWorldToScreen2D

    :param Vector2 position: `Vector2` in C raylib
    :param Camera2D camera: `Camera2D` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetWorldToScreen2D(position, camera)
    return result


def set_target_fps(fps: int) -> None:
    # type: (int) -> None
    '''Set target FPS (maximum)

    Raylib's C API: SetTargetFPS

    :param int fps: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetTargetFPS(int(fps))


def get_fps() -> int:
    # type: () -> int
    '''Get current FPS

    Raylib's C API: GetFPS

    :return: int (`int` in C raylib)
    '''
    result = _GetFPS()
    return result


def get_frame_time() -> float:
    # type: () -> float
    '''Get time in seconds for last frame drawn (delta time)

    Raylib's C API: GetFrameTime

    :return: float (`float` in C raylib)
    '''
    result = _GetFrameTime()
    return result


def get_time() -> float:
    # type: () -> float
    '''Get elapsed time in seconds since InitWindow()

    Raylib's C API: GetTime

    :return: float (`double` in C raylib)
    '''
    result = _GetTime()
    return result


def get_random_value(min: int, max: int) -> int:
    # type: (int, int) -> int
    '''Get a random value between min and max (both included)

    Raylib's C API: GetRandomValue

    :param int min: `int` in C raylib
    :param int max: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetRandomValue(int(min), int(max))
    return result


def set_random_seed(seed: int) -> None:
    # type: (int) -> None
    '''Set the seed for the random number generator

    Raylib's C API: SetRandomSeed

    :param int seed: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetRandomSeed(int(seed))


def take_screenshot(file_name: bytes) -> None:
    # type: (bytes) -> None
    '''Takes a screenshot of current screen (filename extension defines format)

    Raylib's C API: TakeScreenshot

    :param bytes file_name: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _TakeScreenshot(_str_in(file_name))


def set_config_flags(flags: int) -> None:
    # type: (int) -> None
    '''Setup init configuration flags (view FLAGS)

    Raylib's C API: SetConfigFlags

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetConfigFlags(int(flags))


def trace_log(log_level: int, text: bytes, *args: bytes) -> None:
    # type: (int, bytes, bytes) -> None
    '''Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)

    Raylib's C API: TraceLog

    :param int log_level: `int` in C raylib
    :param bytes text: `const char *` in C raylib
    :param bytes args: `...` in C raylib
    :return: None (`void` in C raylib)
    '''
    _TraceLog(int(log_level), _str_in(text), *args)


def set_trace_log_level(log_level: int) -> None:
    # type: (int) -> None
    '''Set the current threshold (minimum) log level

    Raylib's C API: SetTraceLogLevel

    :param int log_level: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetTraceLogLevel(int(log_level))


def mem_alloc(size: int) -> bytes:
    # type: (int) -> bytes
    '''Internal memory allocator

    Raylib's C API: MemAlloc

    :param int size: `int` in C raylib
    :return: bytes (`void *` in C raylib)
    '''
    result = _MemAlloc(int(size))
    return result


def mem_realloc(ptr: bytes, size: int) -> bytes:
    # type: (bytes, int) -> bytes
    '''Internal memory reallocator

    Raylib's C API: MemRealloc

    :param bytes ptr: `void *` in C raylib
    :param int size: `int` in C raylib
    :return: bytes (`void *` in C raylib)
    '''
    ptr_ref = cast(ptr, VoidPtr)
    result = _MemRealloc(ptr_ref, int(size))
    return result


def mem_free(ptr: bytes) -> None:
    # type: (bytes) -> None
    '''Internal memory free

    Raylib's C API: MemFree

    :param bytes ptr: `void *` in C raylib
    :return: None (`void` in C raylib)
    '''
    ptr_ref = cast(ptr, VoidPtr)
    _MemFree(ptr_ref)


def open_url(url: bytes) -> None:
    # type: (bytes) -> None
    '''Open URL with default system browser (if available)

    Raylib's C API: OpenURL

    :param bytes url: `const char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _OpenURL(_str_in(url))


def set_trace_log_callback(callback: TraceLogCallback) -> None:
    # type: (TraceLogCallback) -> None
    '''Set custom trace log

    Raylib's C API: SetTraceLogCallback

    :param TraceLogCallback callback: `TraceLogCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetTraceLogCallback(callback)


def set_load_file_data_callback(callback: LoadFileDataCallback) -> None:
    # type: (LoadFileDataCallback) -> None
    '''Set custom file binary data loader

    Raylib's C API: SetLoadFileDataCallback

    :param LoadFileDataCallback callback: `LoadFileDataCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetLoadFileDataCallback(callback)


def set_save_file_data_callback(callback: SaveFileDataCallback) -> None:
    # type: (SaveFileDataCallback) -> None
    '''Set custom file binary data saver

    Raylib's C API: SetSaveFileDataCallback

    :param SaveFileDataCallback callback: `SaveFileDataCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetSaveFileDataCallback(callback)


def set_load_file_text_callback(callback: LoadFileTextCallback) -> None:
    # type: (LoadFileTextCallback) -> None
    '''Set custom file text data loader

    Raylib's C API: SetLoadFileTextCallback

    :param LoadFileTextCallback callback: `LoadFileTextCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetLoadFileTextCallback(callback)


def set_save_file_text_callback(callback: SaveFileTextCallback) -> None:
    # type: (SaveFileTextCallback) -> None
    '''Set custom file text data saver

    Raylib's C API: SetSaveFileTextCallback

    :param SaveFileTextCallback callback: `SaveFileTextCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetSaveFileTextCallback(callback)


def load_file_data(file_name: bytes, bytes_read: Sequence[int]) -> bytes:
    # type: (bytes, Sequence[int]) -> bytes
    '''Load file data as byte array (read)

    Raylib's C API: LoadFileData

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] bytes_read: `unsigned int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    bytes_read_ref = cast(bytes_read, UIntPtr)
    result = _LoadFileData(_str_in(file_name), bytes_read_ref)
    return result


def unload_file_data(data: bytes) -> None:
    # type: (bytes) -> None
    '''Unload file data allocated by LoadFileData()

    Raylib's C API: UnloadFileData

    :param bytes data: `unsigned char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadFileData(_str_in(data))


def save_file_data(file_name: bytes, data: bytes, bytes_to_write: int) -> bool:
    # type: (bytes, bytes, int) -> bool
    '''Save data to file from byte array (write), returns true on success

    Raylib's C API: SaveFileData

    :param bytes file_name: `const char *` in C raylib
    :param bytes data: `void *` in C raylib
    :param int bytes_to_write: `unsigned int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    data_ref = cast(data, VoidPtr)
    result = _SaveFileData(_str_in(file_name), data_ref, int(bytes_to_write))
    return result


def export_data_as_code(data: bytes, size: int, file_name: bytes) -> bool:
    # type: (bytes, int, bytes) -> bool
    '''Export data to code (.h), returns true on success

    Raylib's C API: ExportDataAsCode

    :param bytes data: `const char *` in C raylib
    :param int size: `unsigned int` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportDataAsCode(_str_in(data), int(size), _str_in(file_name))
    return result


def load_file_text(file_name: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Load text data from file (read), returns a '\0' terminated string

    Raylib's C API: LoadFileText

    :param bytes file_name: `const char *` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    result = _LoadFileText(_str_in(file_name))
    return result


def unload_file_text(text: bytes) -> None:
    # type: (bytes) -> None
    '''Unload file text data allocated by LoadFileText()

    Raylib's C API: UnloadFileText

    :param bytes text: `char *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadFileText(_str_in(text))


def save_file_text(file_name: bytes, text: bytes) -> bool:
    # type: (bytes, bytes) -> bool
    '''Save text data to file (write), string must be '\0' terminated, returns true on success

    Raylib's C API: SaveFileText

    :param bytes file_name: `const char *` in C raylib
    :param bytes text: `char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _SaveFileText(_str_in(file_name), _str_in(text))
    return result


def file_exists(file_name: bytes) -> bool:
    # type: (bytes) -> bool
    '''Check if file exists

    Raylib's C API: FileExists

    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _FileExists(_str_in(file_name))
    return result


def directory_exists(dir_path: bytes) -> bool:
    # type: (bytes) -> bool
    '''Check if a directory path exists

    Raylib's C API: DirectoryExists

    :param bytes dir_path: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _DirectoryExists(_str_in(dir_path))
    return result


def is_file_extension(file_name: bytes, ext: bytes) -> bool:
    # type: (bytes, bytes) -> bool
    '''Check file extension (including point: .png, .wav)

    Raylib's C API: IsFileExtension

    :param bytes file_name: `const char *` in C raylib
    :param bytes ext: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsFileExtension(_str_in(file_name), _str_in(ext))
    return result


def get_file_length(file_name: bytes) -> int:
    # type: (bytes) -> int
    '''Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)

    Raylib's C API: GetFileLength

    :param bytes file_name: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetFileLength(_str_in(file_name))
    return result


def get_file_extension(file_name: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get pointer to extension for a filename string (includes dot: '.png')

    Raylib's C API: GetFileExtension

    :param bytes file_name: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetFileExtension(_str_in(file_name))
    return result


def get_file_name(file_path: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get pointer to filename for a path string

    Raylib's C API: GetFileName

    :param bytes file_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetFileName(_str_in(file_path))
    return result


def get_file_name_without_ext(file_path: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get filename string without extension (uses static string)

    Raylib's C API: GetFileNameWithoutExt

    :param bytes file_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetFileNameWithoutExt(_str_in(file_path))
    return result


def get_directory_path(file_path: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get full path for a given fileName with path (uses static string)

    Raylib's C API: GetDirectoryPath

    :param bytes file_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetDirectoryPath(_str_in(file_path))
    return result


def get_prev_directory_path(dir_path: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get previous directory path for a given path (uses static string)

    Raylib's C API: GetPrevDirectoryPath

    :param bytes dir_path: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetPrevDirectoryPath(_str_in(dir_path))
    return result


def get_working_directory() -> bytes:
    # type: () -> bytes
    '''Get current working directory (uses static string)

    Raylib's C API: GetWorkingDirectory

    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetWorkingDirectory()
    return result


def get_application_directory() -> bytes:
    # type: () -> bytes
    '''Get the directory if the running application (uses static string)

    Raylib's C API: GetApplicationDirectory

    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetApplicationDirectory()
    return result


def change_directory(dir: bytes) -> bool:
    # type: (bytes) -> bool
    '''Change working directory, return true on success

    Raylib's C API: ChangeDirectory

    :param bytes dir: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ChangeDirectory(_str_in(dir))
    return result


def is_path_file(path: bytes) -> bool:
    # type: (bytes) -> bool
    '''Check if a given path is a file or a directory

    Raylib's C API: IsPathFile

    :param bytes path: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsPathFile(_str_in(path))
    return result


def load_directory_files(dir_path: bytes) -> FilePathList:
    # type: (bytes) -> FilePathList
    '''Load directory filepaths

    Raylib's C API: LoadDirectoryFiles

    :param bytes dir_path: `const char *` in C raylib
    :return: FilePathList (`FilePathList` in C raylib)
    '''
    result = _LoadDirectoryFiles(_str_in(dir_path))
    return result


def load_directory_files_ex(base_path: bytes, filter: bytes, scan_subdirs: bool) -> FilePathList:
    # type: (bytes, bytes, bool) -> FilePathList
    '''Load directory filepaths with extension filtering and recursive directory scan

    Raylib's C API: LoadDirectoryFilesEx

    :param bytes base_path: `const char *` in C raylib
    :param bytes filter: `const char *` in C raylib
    :param bool scan_subdirs: `bool` in C raylib
    :return: FilePathList (`FilePathList` in C raylib)
    '''
    result = _LoadDirectoryFilesEx(_str_in(base_path), _str_in(filter), bool(scan_subdirs))
    return result


def unload_directory_files(files: FilePathList) -> None:
    # type: (FilePathList) -> None
    '''Unload filepaths

    Raylib's C API: UnloadDirectoryFiles

    :param FilePathList files: `FilePathList` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadDirectoryFiles(files)


def is_file_dropped() -> bool:
    # type: () -> bool
    '''Check if a file has been dropped into window

    Raylib's C API: IsFileDropped

    :return: bool (`bool` in C raylib)
    '''
    result = _IsFileDropped()
    return result


def load_dropped_files() -> FilePathList:
    # type: () -> FilePathList
    '''Load dropped filepaths

    Raylib's C API: LoadDroppedFiles

    :return: FilePathList (`FilePathList` in C raylib)
    '''
    result = _LoadDroppedFiles()
    return result


def unload_dropped_files(files: FilePathList) -> None:
    # type: (FilePathList) -> None
    '''Unload dropped filepaths

    Raylib's C API: UnloadDroppedFiles

    :param FilePathList files: `FilePathList` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadDroppedFiles(files)


def get_file_mod_time(file_name: bytes) -> int:
    # type: (bytes) -> int
    '''Get file modification time (last write time)

    Raylib's C API: GetFileModTime

    :param bytes file_name: `const char *` in C raylib
    :return: int (`long` in C raylib)
    '''
    result = _GetFileModTime(_str_in(file_name))
    return result


def compress_data(data: bytes, data_size: int, comp_data_size: Sequence[int]) -> bytes:
    # type: (bytes, int, Sequence[int]) -> bytes
    '''Compress data (DEFLATE algorithm), memory must be MemFree()

    Raylib's C API: CompressData

    :param bytes data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param Sequence[int] comp_data_size: `int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    comp_data_size_ref = cast(comp_data_size, IntPtr)
    result = _CompressData(_str_in(data), int(data_size), comp_data_size_ref)
    return result


def decompress_data(comp_data: bytes, comp_data_size: int, data_size: Sequence[int]) -> bytes:
    # type: (bytes, int, Sequence[int]) -> bytes
    '''Decompress data (DEFLATE algorithm), memory must be MemFree()

    Raylib's C API: DecompressData

    :param bytes comp_data: `const unsigned char *` in C raylib
    :param int comp_data_size: `int` in C raylib
    :param Sequence[int] data_size: `int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    data_size_ref = cast(data_size, IntPtr)
    result = _DecompressData(_str_in(comp_data), int(comp_data_size), data_size_ref)
    return result


def encode_data_base64(data: bytes, data_size: int, output_size: Sequence[int]) -> bytes:
    # type: (bytes, int, Sequence[int]) -> bytes
    '''Encode data to Base64 string, memory must be MemFree()

    Raylib's C API: EncodeDataBase64

    :param bytes data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param Sequence[int] output_size: `int *` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    output_size_ref = cast(output_size, IntPtr)
    result = _EncodeDataBase64(_str_in(data), int(data_size), output_size_ref)
    return result


def decode_data_base64(data: bytes, output_size: Sequence[int]) -> bytes:
    # type: (bytes, Sequence[int]) -> bytes
    '''Decode Base64 string data, memory must be MemFree()

    Raylib's C API: DecodeDataBase64

    :param bytes data: `const unsigned char *` in C raylib
    :param Sequence[int] output_size: `int *` in C raylib
    :return: bytes (`unsigned char *` in C raylib)
    '''
    output_size_ref = cast(output_size, IntPtr)
    result = _DecodeDataBase64(_str_in(data), output_size_ref)
    return result


def is_key_pressed(key: int) -> bool:
    # type: (int) -> bool
    '''Check if a key has been pressed once

    Raylib's C API: IsKeyPressed

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsKeyPressed(int(key))
    return result


def is_key_down(key: int) -> bool:
    # type: (int) -> bool
    '''Check if a key is being pressed

    Raylib's C API: IsKeyDown

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsKeyDown(int(key))
    return result


def is_key_released(key: int) -> bool:
    # type: (int) -> bool
    '''Check if a key has been released once

    Raylib's C API: IsKeyReleased

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsKeyReleased(int(key))
    return result


def is_key_up(key: int) -> bool:
    # type: (int) -> bool
    '''Check if a key is NOT being pressed

    Raylib's C API: IsKeyUp

    :param int key: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsKeyUp(int(key))
    return result


def set_exit_key(key: int) -> None:
    # type: (int) -> None
    '''Set a custom key to exit program (default is ESC)

    Raylib's C API: SetExitKey

    :param int key: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetExitKey(int(key))


def get_key_pressed() -> int:
    # type: () -> int
    '''Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty

    Raylib's C API: GetKeyPressed

    :return: int (`int` in C raylib)
    '''
    result = _GetKeyPressed()
    return result


def get_char_pressed() -> int:
    # type: () -> int
    '''Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty

    Raylib's C API: GetCharPressed

    :return: int (`int` in C raylib)
    '''
    result = _GetCharPressed()
    return result


def is_gamepad_available(gamepad: int) -> bool:
    # type: (int) -> bool
    '''Check if a gamepad is available

    Raylib's C API: IsGamepadAvailable

    :param int gamepad: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsGamepadAvailable(int(gamepad))
    return result


def get_gamepad_name(gamepad: int) -> bytes:
    # type: (int) -> bytes
    '''Get gamepad internal name id

    Raylib's C API: GetGamepadName

    :param int gamepad: `int` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _GetGamepadName(int(gamepad))
    return result


def is_gamepad_button_pressed(gamepad: int, button: int) -> bool:
    # type: (int, int) -> bool
    '''Check if a gamepad button has been pressed once

    Raylib's C API: IsGamepadButtonPressed

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsGamepadButtonPressed(int(gamepad), int(button))
    return result


def is_gamepad_button_down(gamepad: int, button: int) -> bool:
    # type: (int, int) -> bool
    '''Check if a gamepad button is being pressed

    Raylib's C API: IsGamepadButtonDown

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsGamepadButtonDown(int(gamepad), int(button))
    return result


def is_gamepad_button_released(gamepad: int, button: int) -> bool:
    # type: (int, int) -> bool
    '''Check if a gamepad button has been released once

    Raylib's C API: IsGamepadButtonReleased

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsGamepadButtonReleased(int(gamepad), int(button))
    return result


def is_gamepad_button_up(gamepad: int, button: int) -> bool:
    # type: (int, int) -> bool
    '''Check if a gamepad button is NOT being pressed

    Raylib's C API: IsGamepadButtonUp

    :param int gamepad: `int` in C raylib
    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsGamepadButtonUp(int(gamepad), int(button))
    return result


def get_gamepad_button_pressed() -> int:
    # type: () -> int
    '''Get the last gamepad button pressed

    Raylib's C API: GetGamepadButtonPressed

    :return: int (`int` in C raylib)
    '''
    result = _GetGamepadButtonPressed()
    return result


def get_gamepad_axis_count(gamepad: int) -> int:
    # type: (int) -> int
    '''Get gamepad axis count for a gamepad

    Raylib's C API: GetGamepadAxisCount

    :param int gamepad: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetGamepadAxisCount(int(gamepad))
    return result


def get_gamepad_axis_movement(gamepad: int, axis: int) -> float:
    # type: (int, int) -> float
    '''Get axis movement value for a gamepad axis

    Raylib's C API: GetGamepadAxisMovement

    :param int gamepad: `int` in C raylib
    :param int axis: `int` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _GetGamepadAxisMovement(int(gamepad), int(axis))
    return result


def set_gamepad_mappings(mappings: bytes) -> int:
    # type: (bytes) -> int
    '''Set internal gamepad mappings (SDL_GameControllerDB)

    Raylib's C API: SetGamepadMappings

    :param bytes mappings: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _SetGamepadMappings(_str_in(mappings))
    return result


def is_mouse_button_pressed(button: int) -> bool:
    # type: (int) -> bool
    '''Check if a mouse button has been pressed once

    Raylib's C API: IsMouseButtonPressed

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsMouseButtonPressed(int(button))
    return result


def is_mouse_button_down(button: int) -> bool:
    # type: (int) -> bool
    '''Check if a mouse button is being pressed

    Raylib's C API: IsMouseButtonDown

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsMouseButtonDown(int(button))
    return result


def is_mouse_button_released(button: int) -> bool:
    # type: (int) -> bool
    '''Check if a mouse button has been released once

    Raylib's C API: IsMouseButtonReleased

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsMouseButtonReleased(int(button))
    return result


def is_mouse_button_up(button: int) -> bool:
    # type: (int) -> bool
    '''Check if a mouse button is NOT being pressed

    Raylib's C API: IsMouseButtonUp

    :param int button: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsMouseButtonUp(int(button))
    return result


def get_mouse_x() -> int:
    # type: () -> int
    '''Get mouse position X

    Raylib's C API: GetMouseX

    :return: int (`int` in C raylib)
    '''
    result = _GetMouseX()
    return result


def get_mouse_y() -> int:
    # type: () -> int
    '''Get mouse position Y

    Raylib's C API: GetMouseY

    :return: int (`int` in C raylib)
    '''
    result = _GetMouseY()
    return result


def get_mouse_position() -> Vector2:
    # type: () -> Vector2
    '''Get mouse position XY

    Raylib's C API: GetMousePosition

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetMousePosition()
    return result


def get_mouse_delta() -> Vector2:
    # type: () -> Vector2
    '''Get mouse delta between frames

    Raylib's C API: GetMouseDelta

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetMouseDelta()
    return result


def set_mouse_position(x: int, y: int) -> None:
    # type: (int, int) -> None
    '''Set mouse position XY

    Raylib's C API: SetMousePosition

    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMousePosition(int(x), int(y))


def set_mouse_offset(offset_x: int, offset_y: int) -> None:
    # type: (int, int) -> None
    '''Set mouse offset

    Raylib's C API: SetMouseOffset

    :param int offset_x: `int` in C raylib
    :param int offset_y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMouseOffset(int(offset_x), int(offset_y))


def set_mouse_scale(scale_x: float, scale_y: float) -> None:
    # type: (float, float) -> None
    '''Set mouse scaling

    Raylib's C API: SetMouseScale

    :param float scale_x: `float` in C raylib
    :param float scale_y: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMouseScale(float(scale_x), float(scale_y))


def get_mouse_wheel_move() -> float:
    # type: () -> float
    '''Get mouse wheel movement for X or Y, whichever is larger

    Raylib's C API: GetMouseWheelMove

    :return: float (`float` in C raylib)
    '''
    result = _GetMouseWheelMove()
    return result


def get_mouse_wheel_move_v() -> Vector2:
    # type: () -> Vector2
    '''Get mouse wheel movement for both X and Y

    Raylib's C API: GetMouseWheelMoveV

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetMouseWheelMoveV()
    return result


def set_mouse_cursor(cursor: int) -> None:
    # type: (int) -> None
    '''Set mouse cursor

    Raylib's C API: SetMouseCursor

    :param int cursor: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMouseCursor(int(cursor))


def get_touch_x() -> int:
    # type: () -> int
    '''Get touch position X for touch point 0 (relative to screen size)

    Raylib's C API: GetTouchX

    :return: int (`int` in C raylib)
    '''
    result = _GetTouchX()
    return result


def get_touch_y() -> int:
    # type: () -> int
    '''Get touch position Y for touch point 0 (relative to screen size)

    Raylib's C API: GetTouchY

    :return: int (`int` in C raylib)
    '''
    result = _GetTouchY()
    return result


def get_touch_position(index: int) -> Vector2:
    # type: (int) -> Vector2
    '''Get touch position XY for a touch point index (relative to screen size)

    Raylib's C API: GetTouchPosition

    :param int index: `int` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetTouchPosition(int(index))
    return result


def get_touch_point_id(index: int) -> int:
    # type: (int) -> int
    '''Get touch point identifier for given index

    Raylib's C API: GetTouchPointId

    :param int index: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetTouchPointId(int(index))
    return result


def get_touch_point_count() -> int:
    # type: () -> int
    '''Get number of touch points

    Raylib's C API: GetTouchPointCount

    :return: int (`int` in C raylib)
    '''
    result = _GetTouchPointCount()
    return result


def set_gestures_enabled(flags: int) -> None:
    # type: (int) -> None
    '''Enable a set of gestures using flags

    Raylib's C API: SetGesturesEnabled

    :param int flags: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetGesturesEnabled(int(flags))


def is_gesture_detected(gesture: int) -> bool:
    # type: (int) -> bool
    '''Check if a gesture have been detected

    Raylib's C API: IsGestureDetected

    :param int gesture: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsGestureDetected(int(gesture))
    return result


def get_gesture_detected() -> int:
    # type: () -> int
    '''Get latest detected gesture

    Raylib's C API: GetGestureDetected

    :return: int (`int` in C raylib)
    '''
    result = _GetGestureDetected()
    return result


def get_gesture_hold_duration() -> float:
    # type: () -> float
    '''Get gesture hold time in milliseconds

    Raylib's C API: GetGestureHoldDuration

    :return: float (`float` in C raylib)
    '''
    result = _GetGestureHoldDuration()
    return result


def get_gesture_drag_vector() -> Vector2:
    # type: () -> Vector2
    '''Get gesture drag vector

    Raylib's C API: GetGestureDragVector

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetGestureDragVector()
    return result


def get_gesture_drag_angle() -> float:
    # type: () -> float
    '''Get gesture drag angle

    Raylib's C API: GetGestureDragAngle

    :return: float (`float` in C raylib)
    '''
    result = _GetGestureDragAngle()
    return result


def get_gesture_pinch_vector() -> Vector2:
    # type: () -> Vector2
    '''Get gesture pinch delta

    Raylib's C API: GetGesturePinchVector

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _GetGesturePinchVector()
    return result


def get_gesture_pinch_angle() -> float:
    # type: () -> float
    '''Get gesture pinch angle

    Raylib's C API: GetGesturePinchAngle

    :return: float (`float` in C raylib)
    '''
    result = _GetGesturePinchAngle()
    return result


def set_camera_mode(camera: Camera, mode: int) -> None:
    # type: (Camera, int) -> None
    '''Set camera mode (multiple camera modes available)

    Raylib's C API: SetCameraMode

    :param Camera camera: `Camera` in C raylib
    :param int mode: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetCameraMode(camera, int(mode))


def update_camera(camera: CameraPtr) -> None:
    # type: (CameraPtr) -> None
    '''Update camera position for selected mode

    Raylib's C API: UpdateCamera

    :param CameraPtr camera: `Camera *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UpdateCamera(camera)


def set_camera_pan_control(key_pan: int) -> None:
    # type: (int) -> None
    '''Set camera pan key to combine with mouse movement (free camera)

    Raylib's C API: SetCameraPanControl

    :param int key_pan: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetCameraPanControl(int(key_pan))


def set_camera_alt_control(key_alt: int) -> None:
    # type: (int) -> None
    '''Set camera alt key to combine with mouse movement (free camera)

    Raylib's C API: SetCameraAltControl

    :param int key_alt: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetCameraAltControl(int(key_alt))


def set_camera_smooth_zoom_control(key_smooth_zoom: int) -> None:
    # type: (int) -> None
    '''Set camera smooth zoom key to combine with mouse (free camera)

    Raylib's C API: SetCameraSmoothZoomControl

    :param int key_smooth_zoom: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetCameraSmoothZoomControl(int(key_smooth_zoom))


def set_camera_move_controls(key_front: int, key_back: int, key_right: int, key_left: int, key_up: int, key_down: int) -> None:
    # type: (int, int, int, int, int, int) -> None
    '''Set camera move controls (1st person and 3rd person cameras)

    Raylib's C API: SetCameraMoveControls

    :param int key_front: `int` in C raylib
    :param int key_back: `int` in C raylib
    :param int key_right: `int` in C raylib
    :param int key_left: `int` in C raylib
    :param int key_up: `int` in C raylib
    :param int key_down: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetCameraMoveControls(int(key_front), int(key_back), int(key_right), int(key_left), int(key_up), int(key_down))


def set_shapes_texture(texture: Texture2D, source: Rectangle) -> None:
    # type: (Texture2D, Rectangle) -> None
    '''Set texture and rectangle to be used on shapes drawing

    Raylib's C API: SetShapesTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetShapesTexture(texture, source)


def draw_pixel(pos_x: int, pos_y: int, color: Color) -> None:
    # type: (int, int, Color) -> None
    '''Draw a pixel

    Raylib's C API: DrawPixel

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPixel(int(pos_x), int(pos_y), color)


def draw_pixel_v(position: Vector2, color: Color) -> None:
    # type: (Vector2, Color) -> None
    '''Draw a pixel (Vector version)

    Raylib's C API: DrawPixelV

    :param Vector2 position: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPixelV(position, color)


def draw_line(start_pos_x: int, start_pos_y: int, end_pos_x: int, end_pos_y: int, color: Color) -> None:
    # type: (int, int, int, int, Color) -> None
    '''Draw a line

    Raylib's C API: DrawLine

    :param int start_pos_x: `int` in C raylib
    :param int start_pos_y: `int` in C raylib
    :param int end_pos_x: `int` in C raylib
    :param int end_pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLine(int(start_pos_x), int(start_pos_y), int(end_pos_x), int(end_pos_y), color)


def draw_line_v(start_pos: Vector2, end_pos: Vector2, color: Color) -> None:
    # type: (Vector2, Vector2, Color) -> None
    '''Draw a line (Vector version)

    Raylib's C API: DrawLineV

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLineV(start_pos, end_pos, color)


def draw_line_ex(start_pos: Vector2, end_pos: Vector2, thick: float, color: Color) -> None:
    # type: (Vector2, Vector2, float, Color) -> None
    '''Draw a line defining thickness

    Raylib's C API: DrawLineEx

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLineEx(start_pos, end_pos, float(thick), color)


def draw_line_bezier(start_pos: Vector2, end_pos: Vector2, thick: float, color: Color) -> None:
    # type: (Vector2, Vector2, float, Color) -> None
    '''Draw a line using cubic-bezier curves in-out

    Raylib's C API: DrawLineBezier

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLineBezier(start_pos, end_pos, float(thick), color)


def draw_line_bezier_quad(start_pos: Vector2, end_pos: Vector2, control_pos: Vector2, thick: float, color: Color) -> None:
    # type: (Vector2, Vector2, Vector2, float, Color) -> None
    '''Draw line using quadratic bezier curves with a control point

    Raylib's C API: DrawLineBezierQuad

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param Vector2 control_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLineBezierQuad(start_pos, end_pos, control_pos, float(thick), color)


def draw_line_bezier_cubic(start_pos: Vector2, end_pos: Vector2, start_control_pos: Vector2, end_control_pos: Vector2, thick: float, color: Color) -> None:
    # type: (Vector2, Vector2, Vector2, Vector2, float, Color) -> None
    '''Draw line using cubic bezier curves with 2 control points

    Raylib's C API: DrawLineBezierCubic

    :param Vector2 start_pos: `Vector2` in C raylib
    :param Vector2 end_pos: `Vector2` in C raylib
    :param Vector2 start_control_pos: `Vector2` in C raylib
    :param Vector2 end_control_pos: `Vector2` in C raylib
    :param float thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLineBezierCubic(start_pos, end_pos, start_control_pos, end_control_pos, float(thick), color)


def draw_line_strip(points: Vector2Ptr, point_count: int, color: Color) -> None:
    # type: (Vector2Ptr, int, Color) -> None
    '''Draw lines sequence

    Raylib's C API: DrawLineStrip

    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLineStrip(points, int(point_count), color)


def draw_circle(center_x: int, center_y: int, radius: float, color: Color) -> None:
    # type: (int, int, float, Color) -> None
    '''Draw a color-filled circle

    Raylib's C API: DrawCircle

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircle(int(center_x), int(center_y), float(radius), color)


def draw_circle_sector(center: Vector2, radius: float, start_angle: float, end_angle: float, segments: int, color: Color) -> None:
    # type: (Vector2, float, float, float, int, Color) -> None
    '''Draw a piece of a circle

    Raylib's C API: DrawCircleSector

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircleSector(center, float(radius), float(start_angle), float(end_angle), int(segments), color)


def draw_circle_sector_lines(center: Vector2, radius: float, start_angle: float, end_angle: float, segments: int, color: Color) -> None:
    # type: (Vector2, float, float, float, int, Color) -> None
    '''Draw circle sector outline

    Raylib's C API: DrawCircleSectorLines

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircleSectorLines(center, float(radius), float(start_angle), float(end_angle), int(segments), color)


def draw_circle_gradient(center_x: int, center_y: int, radius: float, color1: Color, color2: Color) -> None:
    # type: (int, int, float, Color, Color) -> None
    '''Draw a gradient-filled circle

    Raylib's C API: DrawCircleGradient

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius: `float` in C raylib
    :param Color color1: `Color` in C raylib
    :param Color color2: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircleGradient(int(center_x), int(center_y), float(radius), color1, color2)


def draw_circle_v(center: Vector2, radius: float, color: Color) -> None:
    # type: (Vector2, float, Color) -> None
    '''Draw a color-filled circle (Vector version)

    Raylib's C API: DrawCircleV

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircleV(center, float(radius), color)


def draw_circle_lines(center_x: int, center_y: int, radius: float, color: Color) -> None:
    # type: (int, int, float, Color) -> None
    '''Draw circle outline

    Raylib's C API: DrawCircleLines

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircleLines(int(center_x), int(center_y), float(radius), color)


def draw_ellipse(center_x: int, center_y: int, radius_h: float, radius_v: float, color: Color) -> None:
    # type: (int, int, float, float, Color) -> None
    '''Draw ellipse

    Raylib's C API: DrawEllipse

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius_h: `float` in C raylib
    :param float radius_v: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawEllipse(int(center_x), int(center_y), float(radius_h), float(radius_v), color)


def draw_ellipse_lines(center_x: int, center_y: int, radius_h: float, radius_v: float, color: Color) -> None:
    # type: (int, int, float, float, Color) -> None
    '''Draw ellipse outline

    Raylib's C API: DrawEllipseLines

    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param float radius_h: `float` in C raylib
    :param float radius_v: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawEllipseLines(int(center_x), int(center_y), float(radius_h), float(radius_v), color)


def draw_ring(center: Vector2, inner_radius: float, outer_radius: float, start_angle: float, end_angle: float, segments: int, color: Color) -> None:
    # type: (Vector2, float, float, float, float, int, Color) -> None
    '''Draw ring

    Raylib's C API: DrawRing

    :param Vector2 center: `Vector2` in C raylib
    :param float inner_radius: `float` in C raylib
    :param float outer_radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRing(center, float(inner_radius), float(outer_radius), float(start_angle), float(end_angle), int(segments), color)


def draw_ring_lines(center: Vector2, inner_radius: float, outer_radius: float, start_angle: float, end_angle: float, segments: int, color: Color) -> None:
    # type: (Vector2, float, float, float, float, int, Color) -> None
    '''Draw ring outline

    Raylib's C API: DrawRingLines

    :param Vector2 center: `Vector2` in C raylib
    :param float inner_radius: `float` in C raylib
    :param float outer_radius: `float` in C raylib
    :param float start_angle: `float` in C raylib
    :param float end_angle: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRingLines(center, float(inner_radius), float(outer_radius), float(start_angle), float(end_angle), int(segments), color)


def draw_rectangle(pos_x: int, pos_y: int, width: int, height: int, color: Color) -> None:
    # type: (int, int, int, int, Color) -> None
    '''Draw a color-filled rectangle

    Raylib's C API: DrawRectangle

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangle(int(pos_x), int(pos_y), int(width), int(height), color)


def draw_rectangle_v(position: Vector2, size: Vector2, color: Color) -> None:
    # type: (Vector2, Vector2, Color) -> None
    '''Draw a color-filled rectangle (Vector version)

    Raylib's C API: DrawRectangleV

    :param Vector2 position: `Vector2` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleV(position, size, color)


def draw_rectangle_rec(rec: Rectangle, color: Color) -> None:
    # type: (Rectangle, Color) -> None
    '''Draw a color-filled rectangle

    Raylib's C API: DrawRectangleRec

    :param Rectangle rec: `Rectangle` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleRec(rec, color)


def draw_rectangle_pro(rec: Rectangle, origin: Vector2, rotation: float, color: Color) -> None:
    # type: (Rectangle, Vector2, float, Color) -> None
    '''Draw a color-filled rectangle with pro parameters

    Raylib's C API: DrawRectanglePro

    :param Rectangle rec: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectanglePro(rec, origin, float(rotation), color)


def draw_rectangle_gradient_v(pos_x: int, pos_y: int, width: int, height: int, color1: Color, color2: Color) -> None:
    # type: (int, int, int, int, Color, Color) -> None
    '''Draw a vertical-gradient-filled rectangle

    Raylib's C API: DrawRectangleGradientV

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color1: `Color` in C raylib
    :param Color color2: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleGradientV(int(pos_x), int(pos_y), int(width), int(height), color1, color2)


def draw_rectangle_gradient_h(pos_x: int, pos_y: int, width: int, height: int, color1: Color, color2: Color) -> None:
    # type: (int, int, int, int, Color, Color) -> None
    '''Draw a horizontal-gradient-filled rectangle

    Raylib's C API: DrawRectangleGradientH

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color1: `Color` in C raylib
    :param Color color2: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleGradientH(int(pos_x), int(pos_y), int(width), int(height), color1, color2)


def draw_rectangle_gradient_ex(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color) -> None:
    # type: (Rectangle, Color, Color, Color, Color) -> None
    '''Draw a gradient-filled rectangle with custom vertex colors

    Raylib's C API: DrawRectangleGradientEx

    :param Rectangle rec: `Rectangle` in C raylib
    :param Color col1: `Color` in C raylib
    :param Color col2: `Color` in C raylib
    :param Color col3: `Color` in C raylib
    :param Color col4: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleGradientEx(rec, col1, col2, col3, col4)


def draw_rectangle_lines(pos_x: int, pos_y: int, width: int, height: int, color: Color) -> None:
    # type: (int, int, int, int, Color) -> None
    '''Draw rectangle outline

    Raylib's C API: DrawRectangleLines

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleLines(int(pos_x), int(pos_y), int(width), int(height), color)


def draw_rectangle_lines_ex(rec: Rectangle, line_thick: float, color: Color) -> None:
    # type: (Rectangle, float, Color) -> None
    '''Draw rectangle outline with extended parameters

    Raylib's C API: DrawRectangleLinesEx

    :param Rectangle rec: `Rectangle` in C raylib
    :param float line_thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleLinesEx(rec, float(line_thick), color)


def draw_rectangle_rounded(rec: Rectangle, roundness: float, segments: int, color: Color) -> None:
    # type: (Rectangle, float, int, Color) -> None
    '''Draw rectangle with rounded edges

    Raylib's C API: DrawRectangleRounded

    :param Rectangle rec: `Rectangle` in C raylib
    :param float roundness: `float` in C raylib
    :param int segments: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleRounded(rec, float(roundness), int(segments), color)


def draw_rectangle_rounded_lines(rec: Rectangle, roundness: float, segments: int, line_thick: float, color: Color) -> None:
    # type: (Rectangle, float, int, float, Color) -> None
    '''Draw rectangle with rounded edges outline

    Raylib's C API: DrawRectangleRoundedLines

    :param Rectangle rec: `Rectangle` in C raylib
    :param float roundness: `float` in C raylib
    :param int segments: `int` in C raylib
    :param float line_thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRectangleRoundedLines(rec, float(roundness), int(segments), float(line_thick), color)


def draw_triangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> None:
    # type: (Vector2, Vector2, Vector2, Color) -> None
    '''Draw a color-filled triangle (vertex in counter-clockwise order!)

    Raylib's C API: DrawTriangle

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :param Vector2 v3: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTriangle(v1, v2, v3, color)


def draw_triangle_lines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> None:
    # type: (Vector2, Vector2, Vector2, Color) -> None
    '''Draw triangle outline (vertex in counter-clockwise order!)

    Raylib's C API: DrawTriangleLines

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :param Vector2 v3: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTriangleLines(v1, v2, v3, color)


def draw_triangle_fan(points: Vector2Ptr, point_count: int, color: Color) -> None:
    # type: (Vector2Ptr, int, Color) -> None
    '''Draw a triangle fan defined by points (first vertex is the center)

    Raylib's C API: DrawTriangleFan

    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTriangleFan(points, int(point_count), color)


def draw_triangle_strip(points: Vector2Ptr, point_count: int, color: Color) -> None:
    # type: (Vector2Ptr, int, Color) -> None
    '''Draw a triangle strip defined by points

    Raylib's C API: DrawTriangleStrip

    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTriangleStrip(points, int(point_count), color)


def draw_poly(center: Vector2, sides: int, radius: float, rotation: float, color: Color) -> None:
    # type: (Vector2, int, float, float, Color) -> None
    '''Draw a regular polygon (Vector version)

    Raylib's C API: DrawPoly

    :param Vector2 center: `Vector2` in C raylib
    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :param float rotation: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPoly(center, int(sides), float(radius), float(rotation), color)


def draw_poly_lines(center: Vector2, sides: int, radius: float, rotation: float, color: Color) -> None:
    # type: (Vector2, int, float, float, Color) -> None
    '''Draw a polygon outline of n sides

    Raylib's C API: DrawPolyLines

    :param Vector2 center: `Vector2` in C raylib
    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :param float rotation: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPolyLines(center, int(sides), float(radius), float(rotation), color)


def draw_poly_lines_ex(center: Vector2, sides: int, radius: float, rotation: float, line_thick: float, color: Color) -> None:
    # type: (Vector2, int, float, float, float, Color) -> None
    '''Draw a polygon outline of n sides with extended parameters

    Raylib's C API: DrawPolyLinesEx

    :param Vector2 center: `Vector2` in C raylib
    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :param float rotation: `float` in C raylib
    :param float line_thick: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPolyLinesEx(center, int(sides), float(radius), float(rotation), float(line_thick), color)


def check_collision_recs(rec1: Rectangle, rec2: Rectangle) -> bool:
    # type: (Rectangle, Rectangle) -> bool
    '''Check collision between two rectangles

    Raylib's C API: CheckCollisionRecs

    :param Rectangle rec1: `Rectangle` in C raylib
    :param Rectangle rec2: `Rectangle` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionRecs(rec1, rec2)
    return result


def check_collision_circles(center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool:
    # type: (Vector2, float, Vector2, float) -> bool
    '''Check collision between two circles

    Raylib's C API: CheckCollisionCircles

    :param Vector2 center1: `Vector2` in C raylib
    :param float radius1: `float` in C raylib
    :param Vector2 center2: `Vector2` in C raylib
    :param float radius2: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionCircles(center1, float(radius1), center2, float(radius2))
    return result


def check_collision_circle_rec(center: Vector2, radius: float, rec: Rectangle) -> bool:
    # type: (Vector2, float, Rectangle) -> bool
    '''Check collision between circle and rectangle

    Raylib's C API: CheckCollisionCircleRec

    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionCircleRec(center, float(radius), rec)
    return result


def check_collision_point_rec(point: Vector2, rec: Rectangle) -> bool:
    # type: (Vector2, Rectangle) -> bool
    '''Check if point is inside rectangle

    Raylib's C API: CheckCollisionPointRec

    :param Vector2 point: `Vector2` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionPointRec(point, rec)
    return result


def check_collision_point_circle(point: Vector2, center: Vector2, radius: float) -> bool:
    # type: (Vector2, Vector2, float) -> bool
    '''Check if point is inside circle

    Raylib's C API: CheckCollisionPointCircle

    :param Vector2 point: `Vector2` in C raylib
    :param Vector2 center: `Vector2` in C raylib
    :param float radius: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionPointCircle(point, center, float(radius))
    return result


def check_collision_point_triangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool:
    # type: (Vector2, Vector2, Vector2, Vector2) -> bool
    '''Check if point is inside a triangle

    Raylib's C API: CheckCollisionPointTriangle

    :param Vector2 point: `Vector2` in C raylib
    :param Vector2 p1: `Vector2` in C raylib
    :param Vector2 p2: `Vector2` in C raylib
    :param Vector2 p3: `Vector2` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionPointTriangle(point, p1, p2, p3)
    return result


def check_collision_lines(start_pos1: Vector2, end_pos1: Vector2, start_pos2: Vector2, end_pos2: Vector2, collision_point: Vector2Ptr) -> bool:
    # type: (Vector2, Vector2, Vector2, Vector2, Vector2Ptr) -> bool
    '''Check the collision between two lines defined by two points each, returns collision point by reference

    Raylib's C API: CheckCollisionLines

    :param Vector2 start_pos1: `Vector2` in C raylib
    :param Vector2 end_pos1: `Vector2` in C raylib
    :param Vector2 start_pos2: `Vector2` in C raylib
    :param Vector2 end_pos2: `Vector2` in C raylib
    :param Vector2Ptr collision_point: `Vector2 *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionLines(start_pos1, end_pos1, start_pos2, end_pos2, collision_point)
    return result


def check_collision_point_line(point: Vector2, p1: Vector2, p2: Vector2, threshold: int) -> bool:
    # type: (Vector2, Vector2, Vector2, int) -> bool
    '''Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]

    Raylib's C API: CheckCollisionPointLine

    :param Vector2 point: `Vector2` in C raylib
    :param Vector2 p1: `Vector2` in C raylib
    :param Vector2 p2: `Vector2` in C raylib
    :param int threshold: `int` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionPointLine(point, p1, p2, int(threshold))
    return result


def get_collision_rec(rec1: Rectangle, rec2: Rectangle) -> Rectangle:
    # type: (Rectangle, Rectangle) -> Rectangle
    '''Get collision rectangle for two rectangles collision

    Raylib's C API: GetCollisionRec

    :param Rectangle rec1: `Rectangle` in C raylib
    :param Rectangle rec2: `Rectangle` in C raylib
    :return: Rectangle (`Rectangle` in C raylib)
    '''
    result = _GetCollisionRec(rec1, rec2)
    return result


def load_image(file_name: bytes) -> Image:
    # type: (bytes) -> Image
    '''Load image from file into CPU memory (RAM)

    Raylib's C API: LoadImage

    :param bytes file_name: `const char *` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _LoadImage(_str_in(file_name))
    return result


def load_image_raw(file_name: bytes, width: int, height: int, format: int, header_size: int) -> Image:
    # type: (bytes, int, int, int, int) -> Image
    '''Load image from RAW file data

    Raylib's C API: LoadImageRaw

    :param bytes file_name: `const char *` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int format: `int` in C raylib
    :param int header_size: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _LoadImageRaw(_str_in(file_name), int(width), int(height), int(format), int(header_size))
    return result


def load_image_anim(file_name: bytes, frames: Sequence[int]) -> Image:
    # type: (bytes, Sequence[int]) -> Image
    '''Load image sequence from file (frames appended to image.data)

    Raylib's C API: LoadImageAnim

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] frames: `int *` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    frames_ref = cast(frames, IntPtr)
    result = _LoadImageAnim(_str_in(file_name), frames_ref)
    return result


def load_image_from_memory(file_type: bytes, file_data: bytes, data_size: int) -> Image:
    # type: (bytes, bytes, int) -> Image
    '''Load image from memory buffer, fileType refers to extension: i.e. '.png'

    Raylib's C API: LoadImageFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _LoadImageFromMemory(_str_in(file_type), _str_in(file_data), int(data_size))
    return result


def load_image_from_texture(texture: Texture2D) -> Image:
    # type: (Texture2D) -> Image
    '''Load image from GPU texture data

    Raylib's C API: LoadImageFromTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _LoadImageFromTexture(texture)
    return result


def load_image_from_screen() -> Image:
    # type: () -> Image
    '''Load image from screen buffer and (screenshot)

    Raylib's C API: LoadImageFromScreen

    :return: Image (`Image` in C raylib)
    '''
    result = _LoadImageFromScreen()
    return result


def unload_image(image: Image) -> None:
    # type: (Image) -> None
    '''Unload image from CPU memory (RAM)

    Raylib's C API: UnloadImage

    :param Image image: `Image` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadImage(image)


def export_image(image: Image, file_name: bytes) -> bool:
    # type: (Image, bytes) -> bool
    '''Export image data to file, returns true on success

    Raylib's C API: ExportImage

    :param Image image: `Image` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportImage(image, _str_in(file_name))
    return result


def export_image_as_code(image: Image, file_name: bytes) -> bool:
    # type: (Image, bytes) -> bool
    '''Export image as code file defining an array of bytes, returns true on success

    Raylib's C API: ExportImageAsCode

    :param Image image: `Image` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportImageAsCode(image, _str_in(file_name))
    return result


def gen_image_color(width: int, height: int, color: Color) -> Image:
    # type: (int, int, Color) -> Image
    '''Generate image: plain color

    Raylib's C API: GenImageColor

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageColor(int(width), int(height), color)
    return result


def gen_image_gradient_v(width: int, height: int, top: Color, bottom: Color) -> Image:
    # type: (int, int, Color, Color) -> Image
    '''Generate image: vertical gradient

    Raylib's C API: GenImageGradientV

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color top: `Color` in C raylib
    :param Color bottom: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageGradientV(int(width), int(height), top, bottom)
    return result


def gen_image_gradient_h(width: int, height: int, left: Color, right: Color) -> Image:
    # type: (int, int, Color, Color) -> Image
    '''Generate image: horizontal gradient

    Raylib's C API: GenImageGradientH

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color left: `Color` in C raylib
    :param Color right: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageGradientH(int(width), int(height), left, right)
    return result


def gen_image_gradient_radial(width: int, height: int, density: float, inner: Color, outer: Color) -> Image:
    # type: (int, int, float, Color, Color) -> Image
    '''Generate image: radial gradient

    Raylib's C API: GenImageGradientRadial

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param float density: `float` in C raylib
    :param Color inner: `Color` in C raylib
    :param Color outer: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageGradientRadial(int(width), int(height), float(density), inner, outer)
    return result


def gen_image_checked(width: int, height: int, checks_x: int, checks_y: int, col1: Color, col2: Color) -> Image:
    # type: (int, int, int, int, Color, Color) -> Image
    '''Generate image: checked

    Raylib's C API: GenImageChecked

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int checks_x: `int` in C raylib
    :param int checks_y: `int` in C raylib
    :param Color col1: `Color` in C raylib
    :param Color col2: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageChecked(int(width), int(height), int(checks_x), int(checks_y), col1, col2)
    return result


def gen_image_white_noise(width: int, height: int, factor: float) -> Image:
    # type: (int, int, float) -> Image
    '''Generate image: white noise

    Raylib's C API: GenImageWhiteNoise

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param float factor: `float` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageWhiteNoise(int(width), int(height), float(factor))
    return result


def gen_image_cellular(width: int, height: int, tile_size: int) -> Image:
    # type: (int, int, int) -> Image
    '''Generate image: cellular algorithm, bigger tileSize means bigger cells

    Raylib's C API: GenImageCellular

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int tile_size: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageCellular(int(width), int(height), int(tile_size))
    return result


def image_copy(image: Image) -> Image:
    # type: (Image) -> Image
    '''Create an image duplicate (useful for transformations)

    Raylib's C API: ImageCopy

    :param Image image: `Image` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _ImageCopy(image)
    return result


def image_from_image(image: Image, rec: Rectangle) -> Image:
    # type: (Image, Rectangle) -> Image
    '''Create an image from another image piece

    Raylib's C API: ImageFromImage

    :param Image image: `Image` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _ImageFromImage(image, rec)
    return result


def image_text(text: bytes, font_size: int, color: Color) -> Image:
    # type: (bytes, int, Color) -> Image
    '''Create an image from text (default font)

    Raylib's C API: ImageText

    :param bytes text: `const char *` in C raylib
    :param int font_size: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _ImageText(_str_in(text), int(font_size), color)
    return result


def image_text_ex(font: Font, text: bytes, font_size: float, spacing: float, tint: Color) -> Image:
    # type: (Font, bytes, float, float, Color) -> Image
    '''Create an image from text (custom sprite font)

    Raylib's C API: ImageTextEx

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _ImageTextEx(font, _str_in(text), float(font_size), float(spacing), tint)
    return result


def image_format(image: ImagePtr, new_format: int) -> None:
    # type: (ImagePtr, int) -> None
    '''Convert image data to desired format

    Raylib's C API: ImageFormat

    :param ImagePtr image: `Image *` in C raylib
    :param int new_format: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageFormat(image, int(new_format))


def image_to_pot(image: ImagePtr, fill: Color) -> None:
    # type: (ImagePtr, Color) -> None
    '''Convert image to POT (power-of-two)

    Raylib's C API: ImageToPOT

    :param ImagePtr image: `Image *` in C raylib
    :param Color fill: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageToPOT(image, fill)


def image_crop(image: ImagePtr, crop: Rectangle) -> None:
    # type: (ImagePtr, Rectangle) -> None
    '''Crop an image to a defined rectangle

    Raylib's C API: ImageCrop

    :param ImagePtr image: `Image *` in C raylib
    :param Rectangle crop: `Rectangle` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageCrop(image, crop)


def image_alpha_crop(image: ImagePtr, threshold: float) -> None:
    # type: (ImagePtr, float) -> None
    '''Crop image depending on alpha value

    Raylib's C API: ImageAlphaCrop

    :param ImagePtr image: `Image *` in C raylib
    :param float threshold: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageAlphaCrop(image, float(threshold))


def image_alpha_clear(image: ImagePtr, color: Color, threshold: float) -> None:
    # type: (ImagePtr, Color, float) -> None
    '''Clear alpha channel to desired color

    Raylib's C API: ImageAlphaClear

    :param ImagePtr image: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :param float threshold: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageAlphaClear(image, color, float(threshold))


def image_alpha_mask(image: ImagePtr, alpha_mask: Image) -> None:
    # type: (ImagePtr, Image) -> None
    '''Apply alpha mask to image

    Raylib's C API: ImageAlphaMask

    :param ImagePtr image: `Image *` in C raylib
    :param Image alpha_mask: `Image` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageAlphaMask(image, alpha_mask)


def image_alpha_premultiply(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Premultiply alpha channel

    Raylib's C API: ImageAlphaPremultiply

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageAlphaPremultiply(image)


def image_resize(image: ImagePtr, new_width: int, new_height: int) -> None:
    # type: (ImagePtr, int, int) -> None
    '''Resize image (Bicubic scaling algorithm)

    Raylib's C API: ImageResize

    :param ImagePtr image: `Image *` in C raylib
    :param int new_width: `int` in C raylib
    :param int new_height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageResize(image, int(new_width), int(new_height))


def image_resize_nn(image: ImagePtr, new_width: int, new_height: int) -> None:
    # type: (ImagePtr, int, int) -> None
    '''Resize image (Nearest-Neighbor scaling algorithm)

    Raylib's C API: ImageResizeNN

    :param ImagePtr image: `Image *` in C raylib
    :param int new_width: `int` in C raylib
    :param int new_height: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageResizeNN(image, int(new_width), int(new_height))


def image_resize_canvas(image: ImagePtr, new_width: int, new_height: int, offset_x: int, offset_y: int, fill: Color) -> None:
    # type: (ImagePtr, int, int, int, int, Color) -> None
    '''Resize canvas and fill with color

    Raylib's C API: ImageResizeCanvas

    :param ImagePtr image: `Image *` in C raylib
    :param int new_width: `int` in C raylib
    :param int new_height: `int` in C raylib
    :param int offset_x: `int` in C raylib
    :param int offset_y: `int` in C raylib
    :param Color fill: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageResizeCanvas(image, int(new_width), int(new_height), int(offset_x), int(offset_y), fill)


def image_mipmaps(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Compute all mipmap levels for a provided image

    Raylib's C API: ImageMipmaps

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageMipmaps(image)


def image_dither(image: ImagePtr, r_bpp: int, g_bpp: int, b_bpp: int, a_bpp: int) -> None:
    # type: (ImagePtr, int, int, int, int) -> None
    '''Dither image data to 16bpp or lower (Floyd-Steinberg dithering)

    Raylib's C API: ImageDither

    :param ImagePtr image: `Image *` in C raylib
    :param int r_bpp: `int` in C raylib
    :param int g_bpp: `int` in C raylib
    :param int b_bpp: `int` in C raylib
    :param int a_bpp: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDither(image, int(r_bpp), int(g_bpp), int(b_bpp), int(a_bpp))


def image_flip_vertical(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Flip image vertically

    Raylib's C API: ImageFlipVertical

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageFlipVertical(image)


def image_flip_horizontal(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Flip image horizontally

    Raylib's C API: ImageFlipHorizontal

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageFlipHorizontal(image)


def image_rotate_cw(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Rotate image clockwise 90deg

    Raylib's C API: ImageRotateCW

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageRotateCW(image)


def image_rotate_ccw(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Rotate image counter-clockwise 90deg

    Raylib's C API: ImageRotateCCW

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageRotateCCW(image)


def image_color_tint(image: ImagePtr, color: Color) -> None:
    # type: (ImagePtr, Color) -> None
    '''Modify image color: tint

    Raylib's C API: ImageColorTint

    :param ImagePtr image: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageColorTint(image, color)


def image_color_invert(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Modify image color: invert

    Raylib's C API: ImageColorInvert

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageColorInvert(image)


def image_color_grayscale(image: ImagePtr) -> None:
    # type: (ImagePtr) -> None
    '''Modify image color: grayscale

    Raylib's C API: ImageColorGrayscale

    :param ImagePtr image: `Image *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageColorGrayscale(image)


def image_color_contrast(image: ImagePtr, contrast: float) -> None:
    # type: (ImagePtr, float) -> None
    '''Modify image color: contrast (-100 to 100)

    Raylib's C API: ImageColorContrast

    :param ImagePtr image: `Image *` in C raylib
    :param float contrast: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageColorContrast(image, float(contrast))


def image_color_brightness(image: ImagePtr, brightness: int) -> None:
    # type: (ImagePtr, int) -> None
    '''Modify image color: brightness (-255 to 255)

    Raylib's C API: ImageColorBrightness

    :param ImagePtr image: `Image *` in C raylib
    :param int brightness: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageColorBrightness(image, int(brightness))


def image_color_replace(image: ImagePtr, color: Color, replace: Color) -> None:
    # type: (ImagePtr, Color, Color) -> None
    '''Modify image color: replace color

    Raylib's C API: ImageColorReplace

    :param ImagePtr image: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :param Color replace: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageColorReplace(image, color, replace)


def load_image_colors(image: Image) -> ColorPtr:
    # type: (Image) -> ColorPtr
    '''Load color data from image as a Color array (RGBA - 32bit)

    Raylib's C API: LoadImageColors

    :param Image image: `Image` in C raylib
    :return: ColorPtr (`Color *` in C raylib)
    '''
    result = _LoadImageColors(image)
    return result


def load_image_palette(image: Image, max_palette_size: int, color_count: Sequence[int]) -> ColorPtr:
    # type: (Image, int, Sequence[int]) -> ColorPtr
    '''Load colors palette from image as a Color array (RGBA - 32bit)

    Raylib's C API: LoadImagePalette

    :param Image image: `Image` in C raylib
    :param int max_palette_size: `int` in C raylib
    :param Sequence[int] color_count: `int *` in C raylib
    :return: ColorPtr (`Color *` in C raylib)
    '''
    color_count_ref = cast(color_count, IntPtr)
    result = _LoadImagePalette(image, int(max_palette_size), color_count_ref)
    return result


def unload_image_colors(colors: ColorPtr) -> None:
    # type: (ColorPtr) -> None
    '''Unload color data loaded with LoadImageColors()

    Raylib's C API: UnloadImageColors

    :param ColorPtr colors: `Color *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadImageColors(colors)


def unload_image_palette(colors: ColorPtr) -> None:
    # type: (ColorPtr) -> None
    '''Unload colors palette loaded with LoadImagePalette()

    Raylib's C API: UnloadImagePalette

    :param ColorPtr colors: `Color *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadImagePalette(colors)


def get_image_alpha_border(image: Image, threshold: float) -> Rectangle:
    # type: (Image, float) -> Rectangle
    '''Get image alpha border rectangle

    Raylib's C API: GetImageAlphaBorder

    :param Image image: `Image` in C raylib
    :param float threshold: `float` in C raylib
    :return: Rectangle (`Rectangle` in C raylib)
    '''
    result = _GetImageAlphaBorder(image, float(threshold))
    return result


def get_image_color(image: Image, x: int, y: int) -> Color:
    # type: (Image, int, int) -> Color
    '''Get image pixel color at (x, y) position

    Raylib's C API: GetImageColor

    :param Image image: `Image` in C raylib
    :param int x: `int` in C raylib
    :param int y: `int` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _GetImageColor(image, int(x), int(y))
    return result


def image_clear_background(dst: ImagePtr, color: Color) -> None:
    # type: (ImagePtr, Color) -> None
    '''Clear image background with given color

    Raylib's C API: ImageClearBackground

    :param ImagePtr dst: `Image *` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageClearBackground(dst, color)


def image_draw_pixel(dst: ImagePtr, pos_x: int, pos_y: int, color: Color) -> None:
    # type: (ImagePtr, int, int, Color) -> None
    '''Draw pixel within an image

    Raylib's C API: ImageDrawPixel

    :param ImagePtr dst: `Image *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawPixel(dst, int(pos_x), int(pos_y), color)


def image_draw_pixel_v(dst: ImagePtr, position: Vector2, color: Color) -> None:
    # type: (ImagePtr, Vector2, Color) -> None
    '''Draw pixel within an image (Vector version)

    Raylib's C API: ImageDrawPixelV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawPixelV(dst, position, color)


def image_draw_line(dst: ImagePtr, start_pos_x: int, start_pos_y: int, end_pos_x: int, end_pos_y: int, color: Color) -> None:
    # type: (ImagePtr, int, int, int, int, Color) -> None
    '''Draw line within an image

    Raylib's C API: ImageDrawLine

    :param ImagePtr dst: `Image *` in C raylib
    :param int start_pos_x: `int` in C raylib
    :param int start_pos_y: `int` in C raylib
    :param int end_pos_x: `int` in C raylib
    :param int end_pos_y: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawLine(dst, int(start_pos_x), int(start_pos_y), int(end_pos_x), int(end_pos_y), color)


def image_draw_line_v(dst: ImagePtr, start: Vector2, end: Vector2, color: Color) -> None:
    # type: (ImagePtr, Vector2, Vector2, Color) -> None
    '''Draw line within an image (Vector version)

    Raylib's C API: ImageDrawLineV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 start: `Vector2` in C raylib
    :param Vector2 end: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawLineV(dst, start, end, color)


def image_draw_circle(dst: ImagePtr, center_x: int, center_y: int, radius: int, color: Color) -> None:
    # type: (ImagePtr, int, int, int, Color) -> None
    '''Draw circle within an image

    Raylib's C API: ImageDrawCircle

    :param ImagePtr dst: `Image *` in C raylib
    :param int center_x: `int` in C raylib
    :param int center_y: `int` in C raylib
    :param int radius: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawCircle(dst, int(center_x), int(center_y), int(radius), color)


def image_draw_circle_v(dst: ImagePtr, center: Vector2, radius: int, color: Color) -> None:
    # type: (ImagePtr, Vector2, int, Color) -> None
    '''Draw circle within an image (Vector version)

    Raylib's C API: ImageDrawCircleV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 center: `Vector2` in C raylib
    :param int radius: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawCircleV(dst, center, int(radius), color)


def image_draw_rectangle(dst: ImagePtr, pos_x: int, pos_y: int, width: int, height: int, color: Color) -> None:
    # type: (ImagePtr, int, int, int, int, Color) -> None
    '''Draw rectangle within an image

    Raylib's C API: ImageDrawRectangle

    :param ImagePtr dst: `Image *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawRectangle(dst, int(pos_x), int(pos_y), int(width), int(height), color)


def image_draw_rectangle_v(dst: ImagePtr, position: Vector2, size: Vector2, color: Color) -> None:
    # type: (ImagePtr, Vector2, Vector2, Color) -> None
    '''Draw rectangle within an image (Vector version)

    Raylib's C API: ImageDrawRectangleV

    :param ImagePtr dst: `Image *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawRectangleV(dst, position, size, color)


def image_draw_rectangle_rec(dst: ImagePtr, rec: Rectangle, color: Color) -> None:
    # type: (ImagePtr, Rectangle, Color) -> None
    '''Draw rectangle within an image

    Raylib's C API: ImageDrawRectangleRec

    :param ImagePtr dst: `Image *` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawRectangleRec(dst, rec, color)


def image_draw_rectangle_lines(dst: ImagePtr, rec: Rectangle, thick: int, color: Color) -> None:
    # type: (ImagePtr, Rectangle, int, Color) -> None
    '''Draw rectangle lines within an image

    Raylib's C API: ImageDrawRectangleLines

    :param ImagePtr dst: `Image *` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :param int thick: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawRectangleLines(dst, rec, int(thick), color)


def image_draw(dst: ImagePtr, src: Image, src_rec: Rectangle, dst_rec: Rectangle, tint: Color) -> None:
    # type: (ImagePtr, Image, Rectangle, Rectangle, Color) -> None
    '''Draw a source image within a destination image (tint applied to source)

    Raylib's C API: ImageDraw

    :param ImagePtr dst: `Image *` in C raylib
    :param Image src: `Image` in C raylib
    :param Rectangle src_rec: `Rectangle` in C raylib
    :param Rectangle dst_rec: `Rectangle` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDraw(dst, src, src_rec, dst_rec, tint)


def image_draw_text(dst: ImagePtr, text: bytes, pos_x: int, pos_y: int, font_size: int, color: Color) -> None:
    # type: (ImagePtr, bytes, int, int, int, Color) -> None
    '''Draw text (using default font) within an image (destination)

    Raylib's C API: ImageDrawText

    :param ImagePtr dst: `Image *` in C raylib
    :param bytes text: `const char *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawText(dst, _str_in(text), int(pos_x), int(pos_y), int(font_size), color)


def image_draw_text_ex(dst: ImagePtr, font: Font, text: bytes, position: Vector2, font_size: float, spacing: float, tint: Color) -> None:
    # type: (ImagePtr, Font, bytes, Vector2, float, float, Color) -> None
    '''Draw text (custom sprite font) within an image (destination)

    Raylib's C API: ImageDrawTextEx

    :param ImagePtr dst: `Image *` in C raylib
    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ImageDrawTextEx(dst, font, _str_in(text), position, float(font_size), float(spacing), tint)


def load_texture(file_name: bytes) -> Texture2D:
    # type: (bytes) -> Texture2D
    '''Load texture from file into GPU memory (VRAM)

    Raylib's C API: LoadTexture

    :param bytes file_name: `const char *` in C raylib
    :return: Texture2D (`Texture2D` in C raylib)
    '''
    result = _LoadTexture(_str_in(file_name))
    return result


def load_texture_from_image(image: Image) -> Texture2D:
    # type: (Image) -> Texture2D
    '''Load texture from image data

    Raylib's C API: LoadTextureFromImage

    :param Image image: `Image` in C raylib
    :return: Texture2D (`Texture2D` in C raylib)
    '''
    result = _LoadTextureFromImage(image)
    return result


def load_texture_cubemap(image: Image, layout: int) -> TextureCubemap:
    # type: (Image, int) -> TextureCubemap
    '''Load cubemap from image, multiple image cubemap layouts supported

    Raylib's C API: LoadTextureCubemap

    :param Image image: `Image` in C raylib
    :param int layout: `int` in C raylib
    :return: TextureCubemap (`TextureCubemap` in C raylib)
    '''
    result = _LoadTextureCubemap(image, int(layout))
    return result


def load_render_texture(width: int, height: int) -> RenderTexture2D:
    # type: (int, int) -> RenderTexture2D
    '''Load texture for rendering (framebuffer)

    Raylib's C API: LoadRenderTexture

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :return: RenderTexture2D (`RenderTexture2D` in C raylib)
    '''
    result = _LoadRenderTexture(int(width), int(height))
    return result


def unload_texture(texture: Texture2D) -> None:
    # type: (Texture2D) -> None
    '''Unload texture from GPU memory (VRAM)

    Raylib's C API: UnloadTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadTexture(texture)


def unload_render_texture(target: RenderTexture2D) -> None:
    # type: (RenderTexture2D) -> None
    '''Unload render texture from GPU memory (VRAM)

    Raylib's C API: UnloadRenderTexture

    :param RenderTexture2D target: `RenderTexture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadRenderTexture(target)


def update_texture(texture: Texture2D, pixels: bytes) -> None:
    # type: (Texture2D, bytes) -> None
    '''Update GPU texture with new data

    Raylib's C API: UpdateTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param bytes pixels: `const void *` in C raylib
    :return: None (`void` in C raylib)
    '''
    pixels_ref = cast(pixels, VoidPtr)
    _UpdateTexture(texture, pixels_ref)


def update_texture_rec(texture: Texture2D, rec: Rectangle, pixels: bytes) -> None:
    # type: (Texture2D, Rectangle, bytes) -> None
    '''Update GPU texture rectangle with new data

    Raylib's C API: UpdateTextureRec

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle rec: `Rectangle` in C raylib
    :param bytes pixels: `const void *` in C raylib
    :return: None (`void` in C raylib)
    '''
    pixels_ref = cast(pixels, VoidPtr)
    _UpdateTextureRec(texture, rec, pixels_ref)


def gen_texture_mipmaps(texture: Texture2DPtr) -> None:
    # type: (Texture2DPtr) -> None
    '''Generate GPU mipmaps for a texture

    Raylib's C API: GenTextureMipmaps

    :param Texture2DPtr texture: `Texture2D *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _GenTextureMipmaps(texture)


def set_texture_filter(texture: Texture2D, filter: int) -> None:
    # type: (Texture2D, int) -> None
    '''Set texture scaling filter mode

    Raylib's C API: SetTextureFilter

    :param Texture2D texture: `Texture2D` in C raylib
    :param int filter: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetTextureFilter(texture, int(filter))


def set_texture_wrap(texture: Texture2D, wrap: int) -> None:
    # type: (Texture2D, int) -> None
    '''Set texture wrapping mode

    Raylib's C API: SetTextureWrap

    :param Texture2D texture: `Texture2D` in C raylib
    :param int wrap: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetTextureWrap(texture, int(wrap))


def draw_texture(texture: Texture2D, pos_x: int, pos_y: int, tint: Color) -> None:
    # type: (Texture2D, int, int, Color) -> None
    '''Draw a Texture2D

    Raylib's C API: DrawTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTexture(texture, int(pos_x), int(pos_y), tint)


def draw_texture_v(texture: Texture2D, position: Vector2, tint: Color) -> None:
    # type: (Texture2D, Vector2, Color) -> None
    '''Draw a Texture2D with position defined as Vector2

    Raylib's C API: DrawTextureV

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextureV(texture, position, tint)


def draw_texture_ex(texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color) -> None:
    # type: (Texture2D, Vector2, float, float, Color) -> None
    '''Draw a Texture2D with extended parameters

    Raylib's C API: DrawTextureEx

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextureEx(texture, position, float(rotation), float(scale), tint)


def draw_texture_rec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) -> None:
    # type: (Texture2D, Rectangle, Vector2, Color) -> None
    '''Draw a part of a texture defined by a rectangle

    Raylib's C API: DrawTextureRec

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextureRec(texture, source, position, tint)


def draw_texture_quad(texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color) -> None:
    # type: (Texture2D, Vector2, Vector2, Rectangle, Color) -> None
    '''Draw texture quad with tiling and offset parameters

    Raylib's C API: DrawTextureQuad

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 tiling: `Vector2` in C raylib
    :param Vector2 offset: `Vector2` in C raylib
    :param Rectangle quad: `Rectangle` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextureQuad(texture, tiling, offset, quad, tint)


def draw_texture_tiled(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float, scale: float, tint: Color) -> None:
    # type: (Texture2D, Rectangle, Rectangle, Vector2, float, float, Color) -> None
    '''Draw part of a texture (defined by a rectangle) with rotation and scale tiled into dest.

    Raylib's C API: DrawTextureTiled

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Rectangle dest: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextureTiled(texture, source, dest, origin, float(rotation), float(scale), tint)


def draw_texture_pro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float, tint: Color) -> None:
    # type: (Texture2D, Rectangle, Rectangle, Vector2, float, Color) -> None
    '''Draw a part of a texture defined by a rectangle with 'pro' parameters

    Raylib's C API: DrawTexturePro

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Rectangle dest: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTexturePro(texture, source, dest, origin, float(rotation), tint)


def draw_texture_npatch(texture: Texture2D, n_patch_info: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: float, tint: Color) -> None:
    # type: (Texture2D, NPatchInfo, Rectangle, Vector2, float, Color) -> None
    '''Draws a texture (or part of it) that stretches or shrinks nicely

    Raylib's C API: DrawTextureNPatch

    :param Texture2D texture: `Texture2D` in C raylib
    :param NPatchInfo n_patch_info: `NPatchInfo` in C raylib
    :param Rectangle dest: `Rectangle` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextureNPatch(texture, n_patch_info, dest, origin, float(rotation), tint)


def draw_texture_poly(texture: Texture2D, center: Vector2, points: Vector2Ptr, texcoords: Vector2Ptr, point_count: int, tint: Color) -> None:
    # type: (Texture2D, Vector2, Vector2Ptr, Vector2Ptr, int, Color) -> None
    '''Draw a textured polygon

    Raylib's C API: DrawTexturePoly

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector2 center: `Vector2` in C raylib
    :param Vector2Ptr points: `Vector2 *` in C raylib
    :param Vector2Ptr texcoords: `Vector2 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTexturePoly(texture, center, points, texcoords, int(point_count), tint)


def fade(color: Color, alpha: float) -> Color:
    # type: (Color, float) -> Color
    '''Get color with alpha applied, alpha goes from 0.0f to 1.0f

    Raylib's C API: Fade

    :param Color color: `Color` in C raylib
    :param float alpha: `float` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _Fade(color, float(alpha))
    return result


def color_to_int(color: Color) -> int:
    # type: (Color) -> int
    '''Get hexadecimal value for a Color

    Raylib's C API: ColorToInt

    :param Color color: `Color` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _ColorToInt(color)
    return result


def color_normalize(color: Color) -> Vector4:
    # type: (Color) -> Vector4
    '''Get Color normalized as float [0..1]

    Raylib's C API: ColorNormalize

    :param Color color: `Color` in C raylib
    :return: Vector4 (`Vector4` in C raylib)
    '''
    result = _ColorNormalize(color)
    return result


def color_from_normalized(normalized: Vector4) -> Color:
    # type: (Vector4) -> Color
    '''Get Color from normalized values [0..1]

    Raylib's C API: ColorFromNormalized

    :param Vector4 normalized: `Vector4` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _ColorFromNormalized(normalized)
    return result


def color_to_hsv(color: Color) -> Vector3:
    # type: (Color) -> Vector3
    '''Get HSV values for a Color, hue [0..360], saturation/value [0..1]

    Raylib's C API: ColorToHSV

    :param Color color: `Color` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _ColorToHSV(color)
    return result


def color_from_hsv(hue: float, saturation: float, value: float) -> Color:
    # type: (float, float, float) -> Color
    '''Get a Color from HSV values, hue [0..360], saturation/value [0..1]

    Raylib's C API: ColorFromHSV

    :param float hue: `float` in C raylib
    :param float saturation: `float` in C raylib
    :param float value: `float` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _ColorFromHSV(float(hue), float(saturation), float(value))
    return result


def color_alpha(color: Color, alpha: float) -> Color:
    # type: (Color, float) -> Color
    '''Get color with alpha applied, alpha goes from 0.0f to 1.0f

    Raylib's C API: ColorAlpha

    :param Color color: `Color` in C raylib
    :param float alpha: `float` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _ColorAlpha(color, float(alpha))
    return result


def color_alpha_blend(dst: Color, src: Color, tint: Color) -> Color:
    # type: (Color, Color, Color) -> Color
    '''Get src alpha-blended into dst color with tint

    Raylib's C API: ColorAlphaBlend

    :param Color dst: `Color` in C raylib
    :param Color src: `Color` in C raylib
    :param Color tint: `Color` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _ColorAlphaBlend(dst, src, tint)
    return result


def get_color(hex_value: int) -> Color:
    # type: (int) -> Color
    '''Get Color structure from hexadecimal value

    Raylib's C API: GetColor

    :param int hex_value: `unsigned int` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    result = _GetColor(int(hex_value))
    return result


def get_pixel_color(src_ptr: bytes, format: int) -> Color:
    # type: (bytes, int) -> Color
    '''Get Color from a source pixel pointer of certain format

    Raylib's C API: GetPixelColor

    :param bytes src_ptr: `void *` in C raylib
    :param int format: `int` in C raylib
    :return: Color (`Color` in C raylib)
    '''
    src_ptr_ref = cast(src_ptr, VoidPtr)
    result = _GetPixelColor(src_ptr_ref, int(format))
    return result


def set_pixel_color(dst_ptr: bytes, color: Color, format: int) -> None:
    # type: (bytes, Color, int) -> None
    '''Set color formatted into destination pixel pointer

    Raylib's C API: SetPixelColor

    :param bytes dst_ptr: `void *` in C raylib
    :param Color color: `Color` in C raylib
    :param int format: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    dst_ptr_ref = cast(dst_ptr, VoidPtr)
    _SetPixelColor(dst_ptr_ref, color, int(format))


def get_pixel_data_size(width: int, height: int, format: int) -> int:
    # type: (int, int, int) -> int
    '''Get pixel data size in bytes for certain format

    Raylib's C API: GetPixelDataSize

    :param int width: `int` in C raylib
    :param int height: `int` in C raylib
    :param int format: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetPixelDataSize(int(width), int(height), int(format))
    return result


def get_font_default() -> Font:
    # type: () -> Font
    '''Get the default Font

    Raylib's C API: GetFontDefault

    :return: Font (`Font` in C raylib)
    '''
    result = _GetFontDefault()
    return result


def load_font(file_name: bytes) -> Font:
    # type: (bytes) -> Font
    '''Load font from file into GPU memory (VRAM)

    Raylib's C API: LoadFont

    :param bytes file_name: `const char *` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    result = _LoadFont(_str_in(file_name))
    return result


def load_font_ex(file_name: bytes, font_size: int, font_chars: Sequence[int], glyph_count: int) -> Font:
    # type: (bytes, int, Sequence[int], int) -> Font
    '''Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set

    Raylib's C API: LoadFontEx

    :param bytes file_name: `const char *` in C raylib
    :param int font_size: `int` in C raylib
    :param Sequence[int] font_chars: `int *` in C raylib
    :param int glyph_count: `int` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    font_chars_ref = cast(font_chars, IntPtr)
    result = _LoadFontEx(_str_in(file_name), int(font_size), font_chars_ref, int(glyph_count))
    return result


def load_font_from_image(image: Image, key: Color, first_char: int) -> Font:
    # type: (Image, Color, int) -> Font
    '''Load font from Image (XNA style)

    Raylib's C API: LoadFontFromImage

    :param Image image: `Image` in C raylib
    :param Color key: `Color` in C raylib
    :param int first_char: `int` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    result = _LoadFontFromImage(image, key, int(first_char))
    return result


def load_font_from_memory(file_type: bytes, file_data: bytes, data_size: int, font_size: int, font_chars: Sequence[int], glyph_count: int) -> Font:
    # type: (bytes, bytes, int, int, Sequence[int], int) -> Font
    '''Load font from memory buffer, fileType refers to extension: i.e. '.ttf'

    Raylib's C API: LoadFontFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Sequence[int] font_chars: `int *` in C raylib
    :param int glyph_count: `int` in C raylib
    :return: Font (`Font` in C raylib)
    '''
    font_chars_ref = cast(font_chars, IntPtr)
    result = _LoadFontFromMemory(_str_in(file_type), _str_in(file_data), int(data_size), int(font_size), font_chars_ref, int(glyph_count))
    return result


def load_font_data(file_data: bytes, data_size: int, font_size: int, font_chars: Sequence[int], glyph_count: int, type: int) -> GlyphInfoPtr:
    # type: (bytes, int, int, Sequence[int], int, int) -> GlyphInfoPtr
    '''Load font data for further use

    Raylib's C API: LoadFontData

    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Sequence[int] font_chars: `int *` in C raylib
    :param int glyph_count: `int` in C raylib
    :param int type: `int` in C raylib
    :return: GlyphInfoPtr (`GlyphInfo *` in C raylib)
    '''
    font_chars_ref = cast(font_chars, IntPtr)
    result = _LoadFontData(_str_in(file_data), int(data_size), int(font_size), font_chars_ref, int(glyph_count), int(type))
    return result


def gen_image_font_atlas(chars: GlyphInfoPtr, recs: Sequence[RectanglePtr], glyph_count: int, font_size: int, padding: int, pack_method: int) -> Image:
    # type: (GlyphInfoPtr, Sequence[RectanglePtr], int, int, int, int) -> Image
    '''Generate image font atlas using chars info

    Raylib's C API: GenImageFontAtlas

    :param GlyphInfoPtr chars: `const GlyphInfo *` in C raylib
    :param Sequence[RectanglePtr] recs: `Rectangle **` in C raylib
    :param int glyph_count: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param int padding: `int` in C raylib
    :param int pack_method: `int` in C raylib
    :return: Image (`Image` in C raylib)
    '''
    result = _GenImageFontAtlas(chars, recs, int(glyph_count), int(font_size), int(padding), int(pack_method))
    return result


def unload_font_data(chars: GlyphInfoPtr, glyph_count: int) -> None:
    # type: (GlyphInfoPtr, int) -> None
    '''Unload font chars info data (RAM)

    Raylib's C API: UnloadFontData

    :param GlyphInfoPtr chars: `GlyphInfo *` in C raylib
    :param int glyph_count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadFontData(chars, int(glyph_count))


def unload_font(font: Font) -> None:
    # type: (Font) -> None
    '''Unload font from GPU memory (VRAM)

    Raylib's C API: UnloadFont

    :param Font font: `Font` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadFont(font)


def export_font_as_code(font: Font, file_name: bytes) -> bool:
    # type: (Font, bytes) -> bool
    '''Export font as code file, returns true on success

    Raylib's C API: ExportFontAsCode

    :param Font font: `Font` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportFontAsCode(font, _str_in(file_name))
    return result


def draw_fps(pos_x: int, pos_y: int) -> None:
    # type: (int, int) -> None
    '''Draw current FPS

    Raylib's C API: DrawFPS

    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawFPS(int(pos_x), int(pos_y))


def draw_text(text: bytes, pos_x: int, pos_y: int, font_size: int, color: Color) -> None:
    # type: (bytes, int, int, int, Color) -> None
    '''Draw text (using default font)

    Raylib's C API: DrawText

    :param bytes text: `const char *` in C raylib
    :param int pos_x: `int` in C raylib
    :param int pos_y: `int` in C raylib
    :param int font_size: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawText(_str_in(text), int(pos_x), int(pos_y), int(font_size), color)


def draw_text_ex(font: Font, text: bytes, position: Vector2, font_size: float, spacing: float, tint: Color) -> None:
    # type: (Font, bytes, Vector2, float, float, Color) -> None
    '''Draw text using font and additional parameters

    Raylib's C API: DrawTextEx

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextEx(font, _str_in(text), position, float(font_size), float(spacing), tint)


def draw_text_pro(font: Font, text: bytes, position: Vector2, origin: Vector2, rotation: float, font_size: float, spacing: float, tint: Color) -> None:
    # type: (Font, bytes, Vector2, Vector2, float, float, float, Color) -> None
    '''Draw text using Font and pro parameters (rotation)

    Raylib's C API: DrawTextPro

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextPro(font, _str_in(text), position, origin, float(rotation), float(font_size), float(spacing), tint)


def draw_text_codepoint(font: Font, codepoint: int, position: Vector2, font_size: float, tint: Color) -> None:
    # type: (Font, int, Vector2, float, Color) -> None
    '''Draw one character (codepoint)

    Raylib's C API: DrawTextCodepoint

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTextCodepoint(font, int(codepoint), position, float(font_size), tint)


def draw_text_codepoints(font: Font, codepoints: Sequence[int], count: int, position: Vector2, font_size: float, spacing: float, tint: Color) -> None:
    # type: (Font, Sequence[int], int, Vector2, float, float, Color) -> None
    '''Draw multiple character (codepoint)

    Raylib's C API: DrawTextCodepoints

    :param Font font: `Font` in C raylib
    :param Sequence[int] codepoints: `const int *` in C raylib
    :param int count: `int` in C raylib
    :param Vector2 position: `Vector2` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    codepoints_ref = cast(codepoints, IntPtr)
    _DrawTextCodepoints(font, codepoints_ref, int(count), position, float(font_size), float(spacing), tint)


def measure_text(text: bytes, font_size: int) -> int:
    # type: (bytes, int) -> int
    '''Measure string width for default font

    Raylib's C API: MeasureText

    :param bytes text: `const char *` in C raylib
    :param int font_size: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _MeasureText(_str_in(text), int(font_size))
    return result


def measure_text_ex(font: Font, text: bytes, font_size: float, spacing: float) -> Vector2:
    # type: (Font, bytes, float, float) -> Vector2
    '''Measure string size for Font

    Raylib's C API: MeasureTextEx

    :param Font font: `Font` in C raylib
    :param bytes text: `const char *` in C raylib
    :param float font_size: `float` in C raylib
    :param float spacing: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _MeasureTextEx(font, _str_in(text), float(font_size), float(spacing))
    return result


def get_glyph_index(font: Font, codepoint: int) -> int:
    # type: (Font, int) -> int
    '''Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found

    Raylib's C API: GetGlyphIndex

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetGlyphIndex(font, int(codepoint))
    return result


def get_glyph_info(font: Font, codepoint: int) -> GlyphInfo:
    # type: (Font, int) -> GlyphInfo
    '''Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found

    Raylib's C API: GetGlyphInfo

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :return: GlyphInfo (`GlyphInfo` in C raylib)
    '''
    result = _GetGlyphInfo(font, int(codepoint))
    return result


def get_glyph_atlas_rec(font: Font, codepoint: int) -> Rectangle:
    # type: (Font, int) -> Rectangle
    '''Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found

    Raylib's C API: GetGlyphAtlasRec

    :param Font font: `Font` in C raylib
    :param int codepoint: `int` in C raylib
    :return: Rectangle (`Rectangle` in C raylib)
    '''
    result = _GetGlyphAtlasRec(font, int(codepoint))
    return result


def load_codepoints(text: bytes, count: Sequence[int]) -> Sequence[int]:
    # type: (bytes, Sequence[int]) -> Sequence[int]
    '''Load all codepoints from a UTF-8 text string, codepoints count returned by parameter

    Raylib's C API: LoadCodepoints

    :param bytes text: `const char *` in C raylib
    :param Sequence[int] count: `int *` in C raylib
    :return: Sequence[int] (`int *` in C raylib)
    '''
    count_ref = cast(count, IntPtr)
    result = _LoadCodepoints(_str_in(text), count_ref)
    return result


def unload_codepoints(codepoints: Sequence[int]) -> None:
    # type: (Sequence[int]) -> None
    '''Unload codepoints data from memory

    Raylib's C API: UnloadCodepoints

    :param Sequence[int] codepoints: `int *` in C raylib
    :return: None (`void` in C raylib)
    '''
    codepoints_ref = cast(codepoints, IntPtr)
    _UnloadCodepoints(codepoints_ref)


def get_codepoint_count(text: bytes) -> int:
    # type: (bytes) -> int
    '''Get total number of codepoints in a UTF-8 encoded string

    Raylib's C API: GetCodepointCount

    :param bytes text: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _GetCodepointCount(_str_in(text))
    return result


def get_codepoint(text: bytes, bytes_processed: Sequence[int]) -> int:
    # type: (bytes, Sequence[int]) -> int
    '''Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure

    Raylib's C API: GetCodepoint

    :param bytes text: `const char *` in C raylib
    :param Sequence[int] bytes_processed: `int *` in C raylib
    :return: int (`int` in C raylib)
    '''
    bytes_processed_ref = cast(bytes_processed, IntPtr)
    result = _GetCodepoint(_str_in(text), bytes_processed_ref)
    return result


def codepoint_to_utf8(codepoint: int, byte_size: Sequence[int]) -> bytes:
    # type: (int, Sequence[int]) -> bytes
    '''Encode one codepoint into UTF-8 byte array (array length returned as parameter)

    Raylib's C API: CodepointToUTF8

    :param int codepoint: `int` in C raylib
    :param Sequence[int] byte_size: `int *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    byte_size_ref = cast(byte_size, IntPtr)
    result = _CodepointToUTF8(int(codepoint), byte_size_ref)
    return result


def text_codepoints_to_utf8(codepoints: Sequence[int], length: int) -> bytes:
    # type: (Sequence[int], int) -> bytes
    '''Encode text as codepoints array into UTF-8 text string (WARNING: memory must be freed!)

    Raylib's C API: TextCodepointsToUTF8

    :param Sequence[int] codepoints: `const int *` in C raylib
    :param int length: `int` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    codepoints_ref = cast(codepoints, IntPtr)
    result = _TextCodepointsToUTF8(codepoints_ref, int(length))
    return result


def text_copy(dst: bytes, src: bytes) -> int:
    # type: (bytes, bytes) -> int
    '''Copy one string to another, returns bytes copied

    Raylib's C API: TextCopy

    :param bytes dst: `char *` in C raylib
    :param bytes src: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _TextCopy(_str_in(dst), _str_in(src))
    return result


def text_is_equal(text1: bytes, text2: bytes) -> bool:
    # type: (bytes, bytes) -> bool
    '''Check if two text string are equal

    Raylib's C API: TextIsEqual

    :param bytes text1: `const char *` in C raylib
    :param bytes text2: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _TextIsEqual(_str_in(text1), _str_in(text2))
    return result


def text_length(text: bytes) -> int:
    # type: (bytes) -> int
    '''Get text length, checks for '\0' ending

    Raylib's C API: TextLength

    :param bytes text: `const char *` in C raylib
    :return: int (`unsigned int` in C raylib)
    '''
    result = _TextLength(_str_in(text))
    return result


def text_format(text: bytes, *args: bytes) -> bytes:
    # type: (bytes, bytes) -> bytes
    '''Text formatting with variables (sprintf() style)

    Raylib's C API: TextFormat

    :param bytes text: `const char *` in C raylib
    :param bytes args: `...` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _TextFormat(_str_in(text), *args)
    return result


def text_subtext(text: bytes, position: int, length: int) -> bytes:
    # type: (bytes, int, int) -> bytes
    '''Get a piece of a text string

    Raylib's C API: TextSubtext

    :param bytes text: `const char *` in C raylib
    :param int position: `int` in C raylib
    :param int length: `int` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _TextSubtext(_str_in(text), int(position), int(length))
    return result


def text_replace(text: bytes, replace: bytes, by: bytes) -> bytes:
    # type: (bytes, bytes, bytes) -> bytes
    '''Replace text string (WARNING: memory must be freed!)

    Raylib's C API: TextReplace

    :param bytes text: `char *` in C raylib
    :param bytes replace: `const char *` in C raylib
    :param bytes by: `const char *` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    result = _TextReplace(_str_in(text), _str_in(replace), _str_in(by))
    return result


def text_insert(text: bytes, insert: bytes, position: int) -> bytes:
    # type: (bytes, bytes, int) -> bytes
    '''Insert text in a position (WARNING: memory must be freed!)

    Raylib's C API: TextInsert

    :param bytes text: `const char *` in C raylib
    :param bytes insert: `const char *` in C raylib
    :param int position: `int` in C raylib
    :return: bytes (`char *` in C raylib)
    '''
    result = _TextInsert(_str_in(text), _str_in(insert), int(position))
    return result


def text_join(text_list: Sequence[bytes], count: int, delimiter: bytes) -> bytes:
    # type: (Sequence[bytes], int, bytes) -> bytes
    '''Join text strings with delimiter

    Raylib's C API: TextJoin

    :param Sequence[bytes] text_list: `const char **` in C raylib
    :param int count: `int` in C raylib
    :param bytes delimiter: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _TextJoin(_str_in(text_list), int(count), _str_in(delimiter))
    return result


def text_split(text: bytes, delimiter: int, count: Sequence[int]) -> Sequence[bytes]:
    # type: (bytes, int, Sequence[int]) -> Sequence[bytes]
    '''Split text into multiple strings

    Raylib's C API: TextSplit

    :param bytes text: `const char *` in C raylib
    :param int delimiter: `char` in C raylib
    :param Sequence[int] count: `int *` in C raylib
    :return: Sequence[bytes] (`const char **` in C raylib)
    '''
    count_ref = cast(count, IntPtr)
    result = _TextSplit(_str_in(text), int(delimiter), count_ref)
    return result


def text_append(text: bytes, append: bytes, position: Sequence[int]) -> None:
    # type: (bytes, bytes, Sequence[int]) -> None
    '''Append text at specific position and move cursor!

    Raylib's C API: TextAppend

    :param bytes text: `char *` in C raylib
    :param bytes append: `const char *` in C raylib
    :param Sequence[int] position: `int *` in C raylib
    :return: None (`void` in C raylib)
    '''
    position_ref = cast(position, IntPtr)
    _TextAppend(_str_in(text), _str_in(append), position_ref)


def text_find_index(text: bytes, find: bytes) -> int:
    # type: (bytes, bytes) -> int
    '''Find first text occurrence within a string

    Raylib's C API: TextFindIndex

    :param bytes text: `const char *` in C raylib
    :param bytes find: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _TextFindIndex(_str_in(text), _str_in(find))
    return result


def text_to_upper(text: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get upper case version of provided string

    Raylib's C API: TextToUpper

    :param bytes text: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _TextToUpper(_str_in(text))
    return result


def text_to_lower(text: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get lower case version of provided string

    Raylib's C API: TextToLower

    :param bytes text: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _TextToLower(_str_in(text))
    return result


def text_to_pascal(text: bytes) -> bytes:
    # type: (bytes) -> bytes
    '''Get Pascal case notation version of provided string

    Raylib's C API: TextToPascal

    :param bytes text: `const char *` in C raylib
    :return: bytes (`const char *` in C raylib)
    '''
    result = _TextToPascal(_str_in(text))
    return result


def text_to_integer(text: bytes) -> int:
    # type: (bytes) -> int
    '''Get integer value from text (negative values not supported)

    Raylib's C API: TextToInteger

    :param bytes text: `const char *` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _TextToInteger(_str_in(text))
    return result


def draw_line3d(start_pos: Vector3, end_pos: Vector3, color: Color) -> None:
    # type: (Vector3, Vector3, Color) -> None
    '''Draw a line in 3D world space

    Raylib's C API: DrawLine3D

    :param Vector3 start_pos: `Vector3` in C raylib
    :param Vector3 end_pos: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawLine3D(start_pos, end_pos, color)


def draw_point3d(position: Vector3, color: Color) -> None:
    # type: (Vector3, Color) -> None
    '''Draw a point in 3D space, actually a small line

    Raylib's C API: DrawPoint3D

    :param Vector3 position: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPoint3D(position, color)


def draw_circle3d(center: Vector3, radius: float, rotation_axis: Vector3, rotation_angle: float, color: Color) -> None:
    # type: (Vector3, float, Vector3, float, Color) -> None
    '''Draw a circle in 3D world space

    Raylib's C API: DrawCircle3D

    :param Vector3 center: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param Vector3 rotation_axis: `Vector3` in C raylib
    :param float rotation_angle: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCircle3D(center, float(radius), rotation_axis, float(rotation_angle), color)


def draw_triangle3d(v1: Vector3, v2: Vector3, v3: Vector3, color: Color) -> None:
    # type: (Vector3, Vector3, Vector3, Color) -> None
    '''Draw a color-filled triangle (vertex in counter-clockwise order!)

    Raylib's C API: DrawTriangle3D

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :param Vector3 v3: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTriangle3D(v1, v2, v3, color)


def draw_triangle_strip3d(points: Vector3Ptr, point_count: int, color: Color) -> None:
    # type: (Vector3Ptr, int, Color) -> None
    '''Draw a triangle strip defined by points

    Raylib's C API: DrawTriangleStrip3D

    :param Vector3Ptr points: `Vector3 *` in C raylib
    :param int point_count: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawTriangleStrip3D(points, int(point_count), color)


def draw_cube(position: Vector3, width: float, height: float, length: float, color: Color) -> None:
    # type: (Vector3, float, float, float, Color) -> None
    '''Draw cube

    Raylib's C API: DrawCube

    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCube(position, float(width), float(height), float(length), color)


def draw_cube_v(position: Vector3, size: Vector3, color: Color) -> None:
    # type: (Vector3, Vector3, Color) -> None
    '''Draw cube (Vector version)

    Raylib's C API: DrawCubeV

    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 size: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCubeV(position, size, color)


def draw_cube_wires(position: Vector3, width: float, height: float, length: float, color: Color) -> None:
    # type: (Vector3, float, float, float, Color) -> None
    '''Draw cube wires

    Raylib's C API: DrawCubeWires

    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCubeWires(position, float(width), float(height), float(length), color)


def draw_cube_wires_v(position: Vector3, size: Vector3, color: Color) -> None:
    # type: (Vector3, Vector3, Color) -> None
    '''Draw cube wires (Vector version)

    Raylib's C API: DrawCubeWiresV

    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 size: `Vector3` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCubeWiresV(position, size, color)


def draw_cube_texture(texture: Texture2D, position: Vector3, width: float, height: float, length: float, color: Color) -> None:
    # type: (Texture2D, Vector3, float, float, float, Color) -> None
    '''Draw cube textured

    Raylib's C API: DrawCubeTexture

    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCubeTexture(texture, position, float(width), float(height), float(length), color)


def draw_cube_texture_rec(texture: Texture2D, source: Rectangle, position: Vector3, width: float, height: float, length: float, color: Color) -> None:
    # type: (Texture2D, Rectangle, Vector3, float, float, float, Color) -> None
    '''Draw cube with a region of a texture

    Raylib's C API: DrawCubeTextureRec

    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCubeTextureRec(texture, source, position, float(width), float(height), float(length), color)


def draw_sphere(center_pos: Vector3, radius: float, color: Color) -> None:
    # type: (Vector3, float, Color) -> None
    '''Draw sphere

    Raylib's C API: DrawSphere

    :param Vector3 center_pos: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawSphere(center_pos, float(radius), color)


def draw_sphere_ex(center_pos: Vector3, radius: float, rings: int, slices: int, color: Color) -> None:
    # type: (Vector3, float, int, int, Color) -> None
    '''Draw sphere with extended parameters

    Raylib's C API: DrawSphereEx

    :param Vector3 center_pos: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawSphereEx(center_pos, float(radius), int(rings), int(slices), color)


def draw_sphere_wires(center_pos: Vector3, radius: float, rings: int, slices: int, color: Color) -> None:
    # type: (Vector3, float, int, int, Color) -> None
    '''Draw sphere wires

    Raylib's C API: DrawSphereWires

    :param Vector3 center_pos: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawSphereWires(center_pos, float(radius), int(rings), int(slices), color)


def draw_cylinder(position: Vector3, radius_top: float, radius_bottom: float, height: float, slices: int, color: Color) -> None:
    # type: (Vector3, float, float, float, int, Color) -> None
    '''Draw a cylinder/cone

    Raylib's C API: DrawCylinder

    :param Vector3 position: `Vector3` in C raylib
    :param float radius_top: `float` in C raylib
    :param float radius_bottom: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCylinder(position, float(radius_top), float(radius_bottom), float(height), int(slices), color)


def draw_cylinder_ex(start_pos: Vector3, end_pos: Vector3, start_radius: float, end_radius: float, sides: int, color: Color) -> None:
    # type: (Vector3, Vector3, float, float, int, Color) -> None
    '''Draw a cylinder with base at startPos and top at endPos

    Raylib's C API: DrawCylinderEx

    :param Vector3 start_pos: `Vector3` in C raylib
    :param Vector3 end_pos: `Vector3` in C raylib
    :param float start_radius: `float` in C raylib
    :param float end_radius: `float` in C raylib
    :param int sides: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCylinderEx(start_pos, end_pos, float(start_radius), float(end_radius), int(sides), color)


def draw_cylinder_wires(position: Vector3, radius_top: float, radius_bottom: float, height: float, slices: int, color: Color) -> None:
    # type: (Vector3, float, float, float, int, Color) -> None
    '''Draw a cylinder/cone wires

    Raylib's C API: DrawCylinderWires

    :param Vector3 position: `Vector3` in C raylib
    :param float radius_top: `float` in C raylib
    :param float radius_bottom: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCylinderWires(position, float(radius_top), float(radius_bottom), float(height), int(slices), color)


def draw_cylinder_wires_ex(start_pos: Vector3, end_pos: Vector3, start_radius: float, end_radius: float, sides: int, color: Color) -> None:
    # type: (Vector3, Vector3, float, float, int, Color) -> None
    '''Draw a cylinder wires with base at startPos and top at endPos

    Raylib's C API: DrawCylinderWiresEx

    :param Vector3 start_pos: `Vector3` in C raylib
    :param Vector3 end_pos: `Vector3` in C raylib
    :param float start_radius: `float` in C raylib
    :param float end_radius: `float` in C raylib
    :param int sides: `int` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawCylinderWiresEx(start_pos, end_pos, float(start_radius), float(end_radius), int(sides), color)


def draw_plane(center_pos: Vector3, size: Vector2, color: Color) -> None:
    # type: (Vector3, Vector2, Color) -> None
    '''Draw a plane XZ

    Raylib's C API: DrawPlane

    :param Vector3 center_pos: `Vector3` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawPlane(center_pos, size, color)


def draw_ray(ray: Ray, color: Color) -> None:
    # type: (Ray, Color) -> None
    '''Draw a ray line

    Raylib's C API: DrawRay

    :param Ray ray: `Ray` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawRay(ray, color)


def draw_grid(slices: int, spacing: float) -> None:
    # type: (int, float) -> None
    '''Draw a grid (centered at (0, 0, 0))

    Raylib's C API: DrawGrid

    :param int slices: `int` in C raylib
    :param float spacing: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawGrid(int(slices), float(spacing))


def load_model(file_name: bytes) -> Model:
    # type: (bytes) -> Model
    '''Load model from files (meshes and materials)

    Raylib's C API: LoadModel

    :param bytes file_name: `const char *` in C raylib
    :return: Model (`Model` in C raylib)
    '''
    result = _LoadModel(_str_in(file_name))
    return result


def load_model_from_mesh(mesh: Mesh) -> Model:
    # type: (Mesh) -> Model
    '''Load model from generated mesh (default material)

    Raylib's C API: LoadModelFromMesh

    :param Mesh mesh: `Mesh` in C raylib
    :return: Model (`Model` in C raylib)
    '''
    result = _LoadModelFromMesh(mesh)
    return result


def unload_model(model: Model) -> None:
    # type: (Model) -> None
    '''Unload model (including meshes) from memory (RAM and/or VRAM)

    Raylib's C API: UnloadModel

    :param Model model: `Model` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadModel(model)


def unload_model_keep_meshes(model: Model) -> None:
    # type: (Model) -> None
    '''Unload model (but not meshes) from memory (RAM and/or VRAM)

    Raylib's C API: UnloadModelKeepMeshes

    :param Model model: `Model` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadModelKeepMeshes(model)


def get_model_bounding_box(model: Model) -> BoundingBox:
    # type: (Model) -> BoundingBox
    '''Compute model bounding box limits (considers all meshes)

    Raylib's C API: GetModelBoundingBox

    :param Model model: `Model` in C raylib
    :return: BoundingBox (`BoundingBox` in C raylib)
    '''
    result = _GetModelBoundingBox(model)
    return result


def draw_model(model: Model, position: Vector3, scale: float, tint: Color) -> None:
    # type: (Model, Vector3, float, Color) -> None
    '''Draw a model (with texture if set)

    Raylib's C API: DrawModel

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawModel(model, position, float(scale), tint)


def draw_model_ex(model: Model, position: Vector3, rotation_axis: Vector3, rotation_angle: float, scale: Vector3, tint: Color) -> None:
    # type: (Model, Vector3, Vector3, float, Vector3, Color) -> None
    '''Draw a model with extended parameters

    Raylib's C API: DrawModelEx

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 rotation_axis: `Vector3` in C raylib
    :param float rotation_angle: `float` in C raylib
    :param Vector3 scale: `Vector3` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawModelEx(model, position, rotation_axis, float(rotation_angle), scale, tint)


def draw_model_wires(model: Model, position: Vector3, scale: float, tint: Color) -> None:
    # type: (Model, Vector3, float, Color) -> None
    '''Draw a model wires (with texture if set)

    Raylib's C API: DrawModelWires

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float scale: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawModelWires(model, position, float(scale), tint)


def draw_model_wires_ex(model: Model, position: Vector3, rotation_axis: Vector3, rotation_angle: float, scale: Vector3, tint: Color) -> None:
    # type: (Model, Vector3, Vector3, float, Vector3, Color) -> None
    '''Draw a model wires (with texture if set) with extended parameters

    Raylib's C API: DrawModelWiresEx

    :param Model model: `Model` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 rotation_axis: `Vector3` in C raylib
    :param float rotation_angle: `float` in C raylib
    :param Vector3 scale: `Vector3` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawModelWiresEx(model, position, rotation_axis, float(rotation_angle), scale, tint)


def draw_bounding_box(box: BoundingBox, color: Color) -> None:
    # type: (BoundingBox, Color) -> None
    '''Draw bounding box (wires)

    Raylib's C API: DrawBoundingBox

    :param BoundingBox box: `BoundingBox` in C raylib
    :param Color color: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawBoundingBox(box, color)


def draw_billboard(camera: Camera, texture: Texture2D, position: Vector3, size: float, tint: Color) -> None:
    # type: (Camera, Texture2D, Vector3, float, Color) -> None
    '''Draw a billboard texture

    Raylib's C API: DrawBillboard

    :param Camera camera: `Camera` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param float size: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawBillboard(camera, texture, position, float(size), tint)


def draw_billboard_rec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> None:
    # type: (Camera, Texture2D, Rectangle, Vector3, Vector2, Color) -> None
    '''Draw a billboard texture defined by source

    Raylib's C API: DrawBillboardRec

    :param Camera camera: `Camera` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawBillboardRec(camera, texture, source, position, size, tint)


def draw_billboard_pro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: float, tint: Color) -> None:
    # type: (Camera, Texture2D, Rectangle, Vector3, Vector3, Vector2, Vector2, float, Color) -> None
    '''Draw a billboard texture defined by source and rotation

    Raylib's C API: DrawBillboardPro

    :param Camera camera: `Camera` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :param Rectangle source: `Rectangle` in C raylib
    :param Vector3 position: `Vector3` in C raylib
    :param Vector3 up: `Vector3` in C raylib
    :param Vector2 size: `Vector2` in C raylib
    :param Vector2 origin: `Vector2` in C raylib
    :param float rotation: `float` in C raylib
    :param Color tint: `Color` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawBillboardPro(camera, texture, source, position, up, size, origin, float(rotation), tint)


def upload_mesh(mesh: MeshPtr, dynamic: bool) -> None:
    # type: (MeshPtr, bool) -> None
    '''Upload mesh vertex data in GPU and provide VAO/VBO ids

    Raylib's C API: UploadMesh

    :param MeshPtr mesh: `Mesh *` in C raylib
    :param bool dynamic: `bool` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UploadMesh(mesh, bool(dynamic))


def update_mesh_buffer(mesh: Mesh, index: int, data: bytes, data_size: int, offset: int) -> None:
    # type: (Mesh, int, bytes, int, int) -> None
    '''Update mesh vertex data in GPU for a specific buffer index

    Raylib's C API: UpdateMeshBuffer

    :param Mesh mesh: `Mesh` in C raylib
    :param int index: `int` in C raylib
    :param bytes data: `const void *` in C raylib
    :param int data_size: `int` in C raylib
    :param int offset: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    data_ref = cast(data, VoidPtr)
    _UpdateMeshBuffer(mesh, int(index), data_ref, int(data_size), int(offset))


def unload_mesh(mesh: Mesh) -> None:
    # type: (Mesh) -> None
    '''Unload mesh data from CPU and GPU

    Raylib's C API: UnloadMesh

    :param Mesh mesh: `Mesh` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadMesh(mesh)


def draw_mesh(mesh: Mesh, material: Material, transform: Matrix) -> None:
    # type: (Mesh, Material, Matrix) -> None
    '''Draw a 3d mesh with material and transform

    Raylib's C API: DrawMesh

    :param Mesh mesh: `Mesh` in C raylib
    :param Material material: `Material` in C raylib
    :param Matrix transform: `Matrix` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawMesh(mesh, material, transform)


def draw_mesh_instanced(mesh: Mesh, material: Material, transforms: MatrixPtr, instances: int) -> None:
    # type: (Mesh, Material, MatrixPtr, int) -> None
    '''Draw multiple mesh instances with material and different transforms

    Raylib's C API: DrawMeshInstanced

    :param Mesh mesh: `Mesh` in C raylib
    :param Material material: `Material` in C raylib
    :param MatrixPtr transforms: `const Matrix *` in C raylib
    :param int instances: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DrawMeshInstanced(mesh, material, transforms, int(instances))


def export_mesh(mesh: Mesh, file_name: bytes) -> bool:
    # type: (Mesh, bytes) -> bool
    '''Export mesh data to file, returns true on success

    Raylib's C API: ExportMesh

    :param Mesh mesh: `Mesh` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportMesh(mesh, _str_in(file_name))
    return result


def get_mesh_bounding_box(mesh: Mesh) -> BoundingBox:
    # type: (Mesh) -> BoundingBox
    '''Compute mesh bounding box limits

    Raylib's C API: GetMeshBoundingBox

    :param Mesh mesh: `Mesh` in C raylib
    :return: BoundingBox (`BoundingBox` in C raylib)
    '''
    result = _GetMeshBoundingBox(mesh)
    return result


def gen_mesh_tangents(mesh: MeshPtr) -> None:
    # type: (MeshPtr) -> None
    '''Compute mesh tangents

    Raylib's C API: GenMeshTangents

    :param MeshPtr mesh: `Mesh *` in C raylib
    :return: None (`void` in C raylib)
    '''
    _GenMeshTangents(mesh)


def gen_mesh_poly(sides: int, radius: float) -> Mesh:
    # type: (int, float) -> Mesh
    '''Generate polygonal mesh

    Raylib's C API: GenMeshPoly

    :param int sides: `int` in C raylib
    :param float radius: `float` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshPoly(int(sides), float(radius))
    return result


def gen_mesh_plane(width: float, length: float, res_x: int, res_z: int) -> Mesh:
    # type: (float, float, int, int) -> Mesh
    '''Generate plane mesh (with subdivisions)

    Raylib's C API: GenMeshPlane

    :param float width: `float` in C raylib
    :param float length: `float` in C raylib
    :param int res_x: `int` in C raylib
    :param int res_z: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshPlane(float(width), float(length), int(res_x), int(res_z))
    return result


def gen_mesh_cube(width: float, height: float, length: float) -> Mesh:
    # type: (float, float, float) -> Mesh
    '''Generate cuboid mesh

    Raylib's C API: GenMeshCube

    :param float width: `float` in C raylib
    :param float height: `float` in C raylib
    :param float length: `float` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshCube(float(width), float(height), float(length))
    return result


def gen_mesh_sphere(radius: float, rings: int, slices: int) -> Mesh:
    # type: (float, int, int) -> Mesh
    '''Generate sphere mesh (standard sphere)

    Raylib's C API: GenMeshSphere

    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshSphere(float(radius), int(rings), int(slices))
    return result


def gen_mesh_hemi_sphere(radius: float, rings: int, slices: int) -> Mesh:
    # type: (float, int, int) -> Mesh
    '''Generate half-sphere mesh (no bottom cap)

    Raylib's C API: GenMeshHemiSphere

    :param float radius: `float` in C raylib
    :param int rings: `int` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshHemiSphere(float(radius), int(rings), int(slices))
    return result


def gen_mesh_cylinder(radius: float, height: float, slices: int) -> Mesh:
    # type: (float, float, int) -> Mesh
    '''Generate cylinder mesh

    Raylib's C API: GenMeshCylinder

    :param float radius: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshCylinder(float(radius), float(height), int(slices))
    return result


def gen_mesh_cone(radius: float, height: float, slices: int) -> Mesh:
    # type: (float, float, int) -> Mesh
    '''Generate cone/pyramid mesh

    Raylib's C API: GenMeshCone

    :param float radius: `float` in C raylib
    :param float height: `float` in C raylib
    :param int slices: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshCone(float(radius), float(height), int(slices))
    return result


def gen_mesh_torus(radius: float, size: float, rad_seg: int, sides: int) -> Mesh:
    # type: (float, float, int, int) -> Mesh
    '''Generate torus mesh

    Raylib's C API: GenMeshTorus

    :param float radius: `float` in C raylib
    :param float size: `float` in C raylib
    :param int rad_seg: `int` in C raylib
    :param int sides: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshTorus(float(radius), float(size), int(rad_seg), int(sides))
    return result


def gen_mesh_knot(radius: float, size: float, rad_seg: int, sides: int) -> Mesh:
    # type: (float, float, int, int) -> Mesh
    '''Generate trefoil knot mesh

    Raylib's C API: GenMeshKnot

    :param float radius: `float` in C raylib
    :param float size: `float` in C raylib
    :param int rad_seg: `int` in C raylib
    :param int sides: `int` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshKnot(float(radius), float(size), int(rad_seg), int(sides))
    return result


def gen_mesh_heightmap(heightmap: Image, size: Vector3) -> Mesh:
    # type: (Image, Vector3) -> Mesh
    '''Generate heightmap mesh from image data

    Raylib's C API: GenMeshHeightmap

    :param Image heightmap: `Image` in C raylib
    :param Vector3 size: `Vector3` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshHeightmap(heightmap, size)
    return result


def gen_mesh_cubicmap(cubicmap: Image, cube_size: Vector3) -> Mesh:
    # type: (Image, Vector3) -> Mesh
    '''Generate cubes-based map mesh from image data

    Raylib's C API: GenMeshCubicmap

    :param Image cubicmap: `Image` in C raylib
    :param Vector3 cube_size: `Vector3` in C raylib
    :return: Mesh (`Mesh` in C raylib)
    '''
    result = _GenMeshCubicmap(cubicmap, cube_size)
    return result


def load_materials(file_name: bytes, material_count: Sequence[int]) -> MaterialPtr:
    # type: (bytes, Sequence[int]) -> MaterialPtr
    '''Load materials from model file

    Raylib's C API: LoadMaterials

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] material_count: `int *` in C raylib
    :return: MaterialPtr (`Material *` in C raylib)
    '''
    material_count_ref = cast(material_count, IntPtr)
    result = _LoadMaterials(_str_in(file_name), material_count_ref)
    return result


def load_material_default() -> Material:
    # type: () -> Material
    '''Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)

    Raylib's C API: LoadMaterialDefault

    :return: Material (`Material` in C raylib)
    '''
    result = _LoadMaterialDefault()
    return result


def unload_material(material: Material) -> None:
    # type: (Material) -> None
    '''Unload material from GPU memory (VRAM)

    Raylib's C API: UnloadMaterial

    :param Material material: `Material` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadMaterial(material)


def set_material_texture(material: MaterialPtr, map_type: int, texture: Texture2D) -> None:
    # type: (MaterialPtr, int, Texture2D) -> None
    '''Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)

    Raylib's C API: SetMaterialTexture

    :param MaterialPtr material: `Material *` in C raylib
    :param int map_type: `int` in C raylib
    :param Texture2D texture: `Texture2D` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMaterialTexture(material, int(map_type), texture)


def set_model_mesh_material(model: ModelPtr, mesh_id: int, material_id: int) -> None:
    # type: (ModelPtr, int, int) -> None
    '''Set material for a mesh

    Raylib's C API: SetModelMeshMaterial

    :param ModelPtr model: `Model *` in C raylib
    :param int mesh_id: `int` in C raylib
    :param int material_id: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetModelMeshMaterial(model, int(mesh_id), int(material_id))


def load_model_animations(file_name: bytes, anim_count: Sequence[int]) -> ModelAnimationPtr:
    # type: (bytes, Sequence[int]) -> ModelAnimationPtr
    '''Load model animations from file

    Raylib's C API: LoadModelAnimations

    :param bytes file_name: `const char *` in C raylib
    :param Sequence[int] anim_count: `unsigned int *` in C raylib
    :return: ModelAnimationPtr (`ModelAnimation *` in C raylib)
    '''
    anim_count_ref = cast(anim_count, UIntPtr)
    result = _LoadModelAnimations(_str_in(file_name), anim_count_ref)
    return result


def update_model_animation(model: Model, anim: ModelAnimation, frame: int) -> None:
    # type: (Model, ModelAnimation, int) -> None
    '''Update model animation pose

    Raylib's C API: UpdateModelAnimation

    :param Model model: `Model` in C raylib
    :param ModelAnimation anim: `ModelAnimation` in C raylib
    :param int frame: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UpdateModelAnimation(model, anim, int(frame))


def unload_model_animation(anim: ModelAnimation) -> None:
    # type: (ModelAnimation) -> None
    '''Unload animation data

    Raylib's C API: UnloadModelAnimation

    :param ModelAnimation anim: `ModelAnimation` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadModelAnimation(anim)


def unload_model_animations(animations: ModelAnimationPtr, count: int) -> None:
    # type: (ModelAnimationPtr, int) -> None
    '''Unload animation array data

    Raylib's C API: UnloadModelAnimations

    :param ModelAnimationPtr animations: `ModelAnimation *` in C raylib
    :param int count: `unsigned int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadModelAnimations(animations, int(count))


def is_model_animation_valid(model: Model, anim: ModelAnimation) -> bool:
    # type: (Model, ModelAnimation) -> bool
    '''Check model animation skeleton match

    Raylib's C API: IsModelAnimationValid

    :param Model model: `Model` in C raylib
    :param ModelAnimation anim: `ModelAnimation` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsModelAnimationValid(model, anim)
    return result


def check_collision_spheres(center1: Vector3, radius1: float, center2: Vector3, radius2: float) -> bool:
    # type: (Vector3, float, Vector3, float) -> bool
    '''Check collision between two spheres

    Raylib's C API: CheckCollisionSpheres

    :param Vector3 center1: `Vector3` in C raylib
    :param float radius1: `float` in C raylib
    :param Vector3 center2: `Vector3` in C raylib
    :param float radius2: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionSpheres(center1, float(radius1), center2, float(radius2))
    return result


def check_collision_boxes(box1: BoundingBox, box2: BoundingBox) -> bool:
    # type: (BoundingBox, BoundingBox) -> bool
    '''Check collision between two bounding boxes

    Raylib's C API: CheckCollisionBoxes

    :param BoundingBox box1: `BoundingBox` in C raylib
    :param BoundingBox box2: `BoundingBox` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionBoxes(box1, box2)
    return result


def check_collision_box_sphere(box: BoundingBox, center: Vector3, radius: float) -> bool:
    # type: (BoundingBox, Vector3, float) -> bool
    '''Check collision between box and sphere

    Raylib's C API: CheckCollisionBoxSphere

    :param BoundingBox box: `BoundingBox` in C raylib
    :param Vector3 center: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _CheckCollisionBoxSphere(box, center, float(radius))
    return result


def get_ray_collision_sphere(ray: Ray, center: Vector3, radius: float) -> RayCollision:
    # type: (Ray, Vector3, float) -> RayCollision
    '''Get collision info between ray and sphere

    Raylib's C API: GetRayCollisionSphere

    :param Ray ray: `Ray` in C raylib
    :param Vector3 center: `Vector3` in C raylib
    :param float radius: `float` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = _GetRayCollisionSphere(ray, center, float(radius))
    return result


def get_ray_collision_box(ray: Ray, box: BoundingBox) -> RayCollision:
    # type: (Ray, BoundingBox) -> RayCollision
    '''Get collision info between ray and box

    Raylib's C API: GetRayCollisionBox

    :param Ray ray: `Ray` in C raylib
    :param BoundingBox box: `BoundingBox` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = _GetRayCollisionBox(ray, box)
    return result


def get_ray_collision_mesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision:
    # type: (Ray, Mesh, Matrix) -> RayCollision
    '''Get collision info between ray and mesh

    Raylib's C API: GetRayCollisionMesh

    :param Ray ray: `Ray` in C raylib
    :param Mesh mesh: `Mesh` in C raylib
    :param Matrix transform: `Matrix` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = _GetRayCollisionMesh(ray, mesh, transform)
    return result


def get_ray_collision_triangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision:
    # type: (Ray, Vector3, Vector3, Vector3) -> RayCollision
    '''Get collision info between ray and triangle

    Raylib's C API: GetRayCollisionTriangle

    :param Ray ray: `Ray` in C raylib
    :param Vector3 p1: `Vector3` in C raylib
    :param Vector3 p2: `Vector3` in C raylib
    :param Vector3 p3: `Vector3` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = _GetRayCollisionTriangle(ray, p1, p2, p3)
    return result


def get_ray_collision_quad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision:
    # type: (Ray, Vector3, Vector3, Vector3, Vector3) -> RayCollision
    '''Get collision info between ray and quad

    Raylib's C API: GetRayCollisionQuad

    :param Ray ray: `Ray` in C raylib
    :param Vector3 p1: `Vector3` in C raylib
    :param Vector3 p2: `Vector3` in C raylib
    :param Vector3 p3: `Vector3` in C raylib
    :param Vector3 p4: `Vector3` in C raylib
    :return: RayCollision (`RayCollision` in C raylib)
    '''
    result = _GetRayCollisionQuad(ray, p1, p2, p3, p4)
    return result


def init_audio_device() -> None:
    # type: () -> None
    '''Initialize audio device and context

    Raylib's C API: InitAudioDevice

    :return: None (`void` in C raylib)
    '''
    _InitAudioDevice()


def close_audio_device() -> None:
    # type: () -> None
    '''Close the audio device and context

    Raylib's C API: CloseAudioDevice

    :return: None (`void` in C raylib)
    '''
    _CloseAudioDevice()


def is_audio_device_ready() -> bool:
    # type: () -> bool
    '''Check if audio device has been initialized successfully

    Raylib's C API: IsAudioDeviceReady

    :return: bool (`bool` in C raylib)
    '''
    result = _IsAudioDeviceReady()
    return result


def set_master_volume(volume: float) -> None:
    # type: (float) -> None
    '''Set master volume (listener)

    Raylib's C API: SetMasterVolume

    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMasterVolume(float(volume))


def load_wave(file_name: bytes) -> Wave:
    # type: (bytes) -> Wave
    '''Load wave data from file

    Raylib's C API: LoadWave

    :param bytes file_name: `const char *` in C raylib
    :return: Wave (`Wave` in C raylib)
    '''
    result = _LoadWave(_str_in(file_name))
    return result


def load_wave_from_memory(file_type: bytes, file_data: bytes, data_size: int) -> Wave:
    # type: (bytes, bytes, int) -> Wave
    '''Load wave from memory buffer, fileType refers to extension: i.e. '.wav'

    Raylib's C API: LoadWaveFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes file_data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :return: Wave (`Wave` in C raylib)
    '''
    result = _LoadWaveFromMemory(_str_in(file_type), _str_in(file_data), int(data_size))
    return result


def load_sound(file_name: bytes) -> Sound:
    # type: (bytes) -> Sound
    '''Load sound from file

    Raylib's C API: LoadSound

    :param bytes file_name: `const char *` in C raylib
    :return: Sound (`Sound` in C raylib)
    '''
    result = _LoadSound(_str_in(file_name))
    return result


def load_sound_from_wave(wave: Wave) -> Sound:
    # type: (Wave) -> Sound
    '''Load sound from wave data

    Raylib's C API: LoadSoundFromWave

    :param Wave wave: `Wave` in C raylib
    :return: Sound (`Sound` in C raylib)
    '''
    result = _LoadSoundFromWave(wave)
    return result


def update_sound(sound: Sound, data: bytes, sample_count: int) -> None:
    # type: (Sound, bytes, int) -> None
    '''Update sound buffer with new data

    Raylib's C API: UpdateSound

    :param Sound sound: `Sound` in C raylib
    :param bytes data: `const void *` in C raylib
    :param int sample_count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    data_ref = cast(data, VoidPtr)
    _UpdateSound(sound, data_ref, int(sample_count))


def unload_wave(wave: Wave) -> None:
    # type: (Wave) -> None
    '''Unload wave data

    Raylib's C API: UnloadWave

    :param Wave wave: `Wave` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadWave(wave)


def unload_sound(sound: Sound) -> None:
    # type: (Sound) -> None
    '''Unload sound

    Raylib's C API: UnloadSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadSound(sound)


def export_wave(wave: Wave, file_name: bytes) -> bool:
    # type: (Wave, bytes) -> bool
    '''Export wave data to file, returns true on success

    Raylib's C API: ExportWave

    :param Wave wave: `Wave` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportWave(wave, _str_in(file_name))
    return result


def export_wave_as_code(wave: Wave, file_name: bytes) -> bool:
    # type: (Wave, bytes) -> bool
    '''Export wave sample data to code (.h), returns true on success

    Raylib's C API: ExportWaveAsCode

    :param Wave wave: `Wave` in C raylib
    :param bytes file_name: `const char *` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _ExportWaveAsCode(wave, _str_in(file_name))
    return result


def play_sound(sound: Sound) -> None:
    # type: (Sound) -> None
    '''Play a sound

    Raylib's C API: PlaySound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PlaySound(sound)


def stop_sound(sound: Sound) -> None:
    # type: (Sound) -> None
    '''Stop playing a sound

    Raylib's C API: StopSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    _StopSound(sound)


def pause_sound(sound: Sound) -> None:
    # type: (Sound) -> None
    '''Pause a sound

    Raylib's C API: PauseSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PauseSound(sound)


def resume_sound(sound: Sound) -> None:
    # type: (Sound) -> None
    '''Resume a paused sound

    Raylib's C API: ResumeSound

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ResumeSound(sound)


def play_sound_multi(sound: Sound) -> None:
    # type: (Sound) -> None
    '''Play a sound (using multichannel buffer pool)

    Raylib's C API: PlaySoundMulti

    :param Sound sound: `Sound` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PlaySoundMulti(sound)


def stop_sound_multi() -> None:
    # type: () -> None
    '''Stop any sound playing (using multichannel buffer pool)

    Raylib's C API: StopSoundMulti

    :return: None (`void` in C raylib)
    '''
    _StopSoundMulti()


def get_sounds_playing() -> int:
    # type: () -> int
    '''Get number of sounds playing in the multichannel

    Raylib's C API: GetSoundsPlaying

    :return: int (`int` in C raylib)
    '''
    result = _GetSoundsPlaying()
    return result


def is_sound_playing(sound: Sound) -> bool:
    # type: (Sound) -> bool
    '''Check if a sound is currently playing

    Raylib's C API: IsSoundPlaying

    :param Sound sound: `Sound` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsSoundPlaying(sound)
    return result


def set_sound_volume(sound: Sound, volume: float) -> None:
    # type: (Sound, float) -> None
    '''Set volume for a sound (1.0 is max level)

    Raylib's C API: SetSoundVolume

    :param Sound sound: `Sound` in C raylib
    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetSoundVolume(sound, float(volume))


def set_sound_pitch(sound: Sound, pitch: float) -> None:
    # type: (Sound, float) -> None
    '''Set pitch for a sound (1.0 is base level)

    Raylib's C API: SetSoundPitch

    :param Sound sound: `Sound` in C raylib
    :param float pitch: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetSoundPitch(sound, float(pitch))


def set_sound_pan(sound: Sound, pan: float) -> None:
    # type: (Sound, float) -> None
    '''Set pan for a sound (0.5 is center)

    Raylib's C API: SetSoundPan

    :param Sound sound: `Sound` in C raylib
    :param float pan: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetSoundPan(sound, float(pan))


def wave_copy(wave: Wave) -> Wave:
    # type: (Wave) -> Wave
    '''Copy a wave to a new wave

    Raylib's C API: WaveCopy

    :param Wave wave: `Wave` in C raylib
    :return: Wave (`Wave` in C raylib)
    '''
    result = _WaveCopy(wave)
    return result


def wave_crop(wave: WavePtr, init_sample: int, final_sample: int) -> None:
    # type: (WavePtr, int, int) -> None
    '''Crop a wave to defined samples range

    Raylib's C API: WaveCrop

    :param WavePtr wave: `Wave *` in C raylib
    :param int init_sample: `int` in C raylib
    :param int final_sample: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _WaveCrop(wave, int(init_sample), int(final_sample))


def wave_format(wave: WavePtr, sample_rate: int, sample_size: int, channels: int) -> None:
    # type: (WavePtr, int, int, int) -> None
    '''Convert wave data to desired format

    Raylib's C API: WaveFormat

    :param WavePtr wave: `Wave *` in C raylib
    :param int sample_rate: `int` in C raylib
    :param int sample_size: `int` in C raylib
    :param int channels: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _WaveFormat(wave, int(sample_rate), int(sample_size), int(channels))


def load_wave_samples(wave: Wave) -> Sequence[float]:
    # type: (Wave) -> Sequence[float]
    '''Load samples data from wave as a 32bit float data array

    Raylib's C API: LoadWaveSamples

    :param Wave wave: `Wave` in C raylib
    :return: Sequence[float] (`float *` in C raylib)
    '''
    result = _LoadWaveSamples(wave)
    return result


def unload_wave_samples(samples: Sequence[float]) -> None:
    # type: (Sequence[float]) -> None
    '''Unload samples data loaded with LoadWaveSamples()

    Raylib's C API: UnloadWaveSamples

    :param Sequence[float] samples: `float *` in C raylib
    :return: None (`void` in C raylib)
    '''
    samples_ref = cast(samples, FloatPtr)
    _UnloadWaveSamples(samples_ref)


def load_music_stream(file_name: bytes) -> Music:
    # type: (bytes) -> Music
    '''Load music stream from file

    Raylib's C API: LoadMusicStream

    :param bytes file_name: `const char *` in C raylib
    :return: Music (`Music` in C raylib)
    '''
    result = _LoadMusicStream(_str_in(file_name))
    return result


def load_music_stream_from_memory(file_type: bytes, data: bytes, data_size: int) -> Music:
    # type: (bytes, bytes, int) -> Music
    '''Load music stream from data

    Raylib's C API: LoadMusicStreamFromMemory

    :param bytes file_type: `const char *` in C raylib
    :param bytes data: `const unsigned char *` in C raylib
    :param int data_size: `int` in C raylib
    :return: Music (`Music` in C raylib)
    '''
    result = _LoadMusicStreamFromMemory(_str_in(file_type), _str_in(data), int(data_size))
    return result


def unload_music_stream(music: Music) -> None:
    # type: (Music) -> None
    '''Unload music stream

    Raylib's C API: UnloadMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadMusicStream(music)


def play_music_stream(music: Music) -> None:
    # type: (Music) -> None
    '''Start music playing

    Raylib's C API: PlayMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PlayMusicStream(music)


def is_music_stream_playing(music: Music) -> bool:
    # type: (Music) -> bool
    '''Check if music is playing

    Raylib's C API: IsMusicStreamPlaying

    :param Music music: `Music` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsMusicStreamPlaying(music)
    return result


def update_music_stream(music: Music) -> None:
    # type: (Music) -> None
    '''Updates buffers for music streaming

    Raylib's C API: UpdateMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UpdateMusicStream(music)


def stop_music_stream(music: Music) -> None:
    # type: (Music) -> None
    '''Stop music playing

    Raylib's C API: StopMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    _StopMusicStream(music)


def pause_music_stream(music: Music) -> None:
    # type: (Music) -> None
    '''Pause music playing

    Raylib's C API: PauseMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PauseMusicStream(music)


def resume_music_stream(music: Music) -> None:
    # type: (Music) -> None
    '''Resume playing paused music

    Raylib's C API: ResumeMusicStream

    :param Music music: `Music` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ResumeMusicStream(music)


def seek_music_stream(music: Music, position: float) -> None:
    # type: (Music, float) -> None
    '''Seek music to a position (in seconds)

    Raylib's C API: SeekMusicStream

    :param Music music: `Music` in C raylib
    :param float position: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SeekMusicStream(music, float(position))


def set_music_volume(music: Music, volume: float) -> None:
    # type: (Music, float) -> None
    '''Set volume for music (1.0 is max level)

    Raylib's C API: SetMusicVolume

    :param Music music: `Music` in C raylib
    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMusicVolume(music, float(volume))


def set_music_pitch(music: Music, pitch: float) -> None:
    # type: (Music, float) -> None
    '''Set pitch for a music (1.0 is base level)

    Raylib's C API: SetMusicPitch

    :param Music music: `Music` in C raylib
    :param float pitch: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMusicPitch(music, float(pitch))


def set_music_pan(music: Music, pan: float) -> None:
    # type: (Music, float) -> None
    '''Set pan for a music (0.5 is center)

    Raylib's C API: SetMusicPan

    :param Music music: `Music` in C raylib
    :param float pan: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetMusicPan(music, float(pan))


def get_music_time_length(music: Music) -> float:
    # type: (Music) -> float
    '''Get music time length (in seconds)

    Raylib's C API: GetMusicTimeLength

    :param Music music: `Music` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _GetMusicTimeLength(music)
    return result


def get_music_time_played(music: Music) -> float:
    # type: (Music) -> float
    '''Get current music time played (in seconds)

    Raylib's C API: GetMusicTimePlayed

    :param Music music: `Music` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _GetMusicTimePlayed(music)
    return result


def load_audio_stream(sample_rate: int, sample_size: int, channels: int) -> AudioStream:
    # type: (int, int, int) -> AudioStream
    '''Load audio stream (to stream raw audio pcm data)

    Raylib's C API: LoadAudioStream

    :param int sample_rate: `unsigned int` in C raylib
    :param int sample_size: `unsigned int` in C raylib
    :param int channels: `unsigned int` in C raylib
    :return: AudioStream (`AudioStream` in C raylib)
    '''
    result = _LoadAudioStream(int(sample_rate), int(sample_size), int(channels))
    return result


def unload_audio_stream(stream: AudioStream) -> None:
    # type: (AudioStream) -> None
    '''Unload audio stream and free memory

    Raylib's C API: UnloadAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    _UnloadAudioStream(stream)


def update_audio_stream(stream: AudioStream, data: bytes, frame_count: int) -> None:
    # type: (AudioStream, bytes, int) -> None
    '''Update audio stream buffers with data

    Raylib's C API: UpdateAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :param bytes data: `const void *` in C raylib
    :param int frame_count: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    data_ref = cast(data, VoidPtr)
    _UpdateAudioStream(stream, data_ref, int(frame_count))


def is_audio_stream_processed(stream: AudioStream) -> bool:
    # type: (AudioStream) -> bool
    '''Check if any audio stream buffers requires refill

    Raylib's C API: IsAudioStreamProcessed

    :param AudioStream stream: `AudioStream` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsAudioStreamProcessed(stream)
    return result


def play_audio_stream(stream: AudioStream) -> None:
    # type: (AudioStream) -> None
    '''Play audio stream

    Raylib's C API: PlayAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PlayAudioStream(stream)


def pause_audio_stream(stream: AudioStream) -> None:
    # type: (AudioStream) -> None
    '''Pause audio stream

    Raylib's C API: PauseAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    _PauseAudioStream(stream)


def resume_audio_stream(stream: AudioStream) -> None:
    # type: (AudioStream) -> None
    '''Resume audio stream

    Raylib's C API: ResumeAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    _ResumeAudioStream(stream)


def is_audio_stream_playing(stream: AudioStream) -> bool:
    # type: (AudioStream) -> bool
    '''Check if audio stream is playing

    Raylib's C API: IsAudioStreamPlaying

    :param AudioStream stream: `AudioStream` in C raylib
    :return: bool (`bool` in C raylib)
    '''
    result = _IsAudioStreamPlaying(stream)
    return result


def stop_audio_stream(stream: AudioStream) -> None:
    # type: (AudioStream) -> None
    '''Stop audio stream

    Raylib's C API: StopAudioStream

    :param AudioStream stream: `AudioStream` in C raylib
    :return: None (`void` in C raylib)
    '''
    _StopAudioStream(stream)


def set_audio_stream_volume(stream: AudioStream, volume: float) -> None:
    # type: (AudioStream, float) -> None
    '''Set volume for audio stream (1.0 is max level)

    Raylib's C API: SetAudioStreamVolume

    :param AudioStream stream: `AudioStream` in C raylib
    :param float volume: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetAudioStreamVolume(stream, float(volume))


def set_audio_stream_pitch(stream: AudioStream, pitch: float) -> None:
    # type: (AudioStream, float) -> None
    '''Set pitch for audio stream (1.0 is base level)

    Raylib's C API: SetAudioStreamPitch

    :param AudioStream stream: `AudioStream` in C raylib
    :param float pitch: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetAudioStreamPitch(stream, float(pitch))


def set_audio_stream_pan(stream: AudioStream, pan: float) -> None:
    # type: (AudioStream, float) -> None
    '''Set pan for audio stream (0.5 is centered)

    Raylib's C API: SetAudioStreamPan

    :param AudioStream stream: `AudioStream` in C raylib
    :param float pan: `float` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetAudioStreamPan(stream, float(pan))


def set_audio_stream_buffer_size_default(size: int) -> None:
    # type: (int) -> None
    '''Default size for new audio streams

    Raylib's C API: SetAudioStreamBufferSizeDefault

    :param int size: `int` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetAudioStreamBufferSizeDefault(int(size))


def set_audio_stream_callback(stream: AudioStream, callback: AudioCallback) -> None:
    # type: (AudioStream, AudioCallback) -> None
    '''Audio thread callback to request new data

    Raylib's C API: SetAudioStreamCallback

    :param AudioStream stream: `AudioStream` in C raylib
    :param AudioCallback callback: `AudioCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _SetAudioStreamCallback(stream, callback)


def attach_audio_stream_processor(stream: AudioStream, processor: AudioCallback) -> None:
    # type: (AudioStream, AudioCallback) -> None
    '''

    Raylib's C API: AttachAudioStreamProcessor

    :param AudioStream stream: `AudioStream` in C raylib
    :param AudioCallback processor: `AudioCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _AttachAudioStreamProcessor(stream, processor)


def detach_audio_stream_processor(stream: AudioStream, processor: AudioCallback) -> None:
    # type: (AudioStream, AudioCallback) -> None
    '''

    Raylib's C API: DetachAudioStreamProcessor

    :param AudioStream stream: `AudioStream` in C raylib
    :param AudioCallback processor: `AudioCallback` in C raylib
    :return: None (`void` in C raylib)
    '''
    _DetachAudioStreamProcessor(stream, processor)


def clamp(value: float, min_: float, max_: float) -> float:
    # type: (float, float, float) -> float
    '''Clamp float value

    Raylib's C API: Clamp

    :param float value: `float` in C raylib
    :param float min_: `float` in C raylib
    :param float max_: `float` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Clamp(float(value), float(min_), float(max_))
    return result


def lerp(start: float, end: float, amount: float) -> float:
    # type: (float, float, float) -> float
    '''Calculate linear interpolation between two floats

    Raylib's C API: Lerp

    :param float start: `float` in C raylib
    :param float end: `float` in C raylib
    :param float amount: `float` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Lerp(float(start), float(end), float(amount))
    return result


def normalize(value: float, start: float, end: float) -> float:
    # type: (float, float, float) -> float
    '''Calculate linear interpolation between two floats

    Raylib's C API: Normalize

    :param float value: `float` in C raylib
    :param float start: `float` in C raylib
    :param float end: `float` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Normalize(float(value), float(start), float(end))
    return result


def remap(value: float, input_start: float, input_end: float, output_start: float, output_end: float) -> float:
    # type: (float, float, float, float, float) -> float
    '''Remap input value within input range to output range

    Raylib's C API: Remap

    :param float value: `float` in C raylib
    :param float input_start: `float` in C raylib
    :param float input_end: `float` in C raylib
    :param float output_start: `float` in C raylib
    :param float output_end: `float` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Remap(float(value), float(input_start), float(input_end), float(output_start), float(output_end))
    return result


def wrap(value: float, min_: float, max_: float) -> float:
    # type: (float, float, float) -> float
    '''Wrap input value from min to max

    Raylib's C API: Wrap

    :param float value: `float` in C raylib
    :param float min_: `float` in C raylib
    :param float max_: `float` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Wrap(float(value), float(min_), float(max_))
    return result


def float_equals(x: float, y: float) -> int:
    # type: (float, float) -> int
    '''Check whether two given floats are almost equal

    Raylib's C API: FloatEquals

    :param float x: `float` in C raylib
    :param float y: `float` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _FloatEquals(float(x), float(y))
    return result


def vector2zero() -> Vector2:
    # type: () -> Vector2
    '''Vector with components value 0.0f

    Raylib's C API: Vector2Zero

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Zero()
    return result


def vector2one() -> Vector2:
    # type: () -> Vector2
    '''Vector with components value 1.0f

    Raylib's C API: Vector2One

    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2One()
    return result


def vector2add(v1: Vector2, v2: Vector2) -> Vector2:
    # type: (Vector2, Vector2) -> Vector2
    '''Add two vectors (v1 + v2)

    Raylib's C API: Vector2Add

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Add(v1, v2)
    return result


def vector2add_value(v: Vector2, add: float) -> Vector2:
    # type: (Vector2, float) -> Vector2
    '''Add vector and float value

    Raylib's C API: Vector2AddValue

    :param Vector2 v: `Vector2` in C raylib
    :param float add: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2AddValue(v, float(add))
    return result


def vector2subtract(v1: Vector2, v2: Vector2) -> Vector2:
    # type: (Vector2, Vector2) -> Vector2
    '''Subtract two vectors (v1 - v2)

    Raylib's C API: Vector2Subtract

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Subtract(v1, v2)
    return result


def vector2subtract_value(v: Vector2, sub: float) -> Vector2:
    # type: (Vector2, float) -> Vector2
    '''Subtract vector by float value

    Raylib's C API: Vector2SubtractValue

    :param Vector2 v: `Vector2` in C raylib
    :param float sub: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2SubtractValue(v, float(sub))
    return result


def vector2length(v: Vector2) -> float:
    # type: (Vector2) -> float
    '''Calculate vector length

    Raylib's C API: Vector2Length

    :param Vector2 v: `Vector2` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector2Length(v)
    return result


def vector2length_sqr(v: Vector2) -> float:
    # type: (Vector2) -> float
    '''Calculate vector square length

    Raylib's C API: Vector2LengthSqr

    :param Vector2 v: `Vector2` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector2LengthSqr(v)
    return result


def vector2dot_product(v1: Vector2, v2: Vector2) -> float:
    # type: (Vector2, Vector2) -> float
    '''Calculate two vectors dot product

    Raylib's C API: Vector2DotProduct

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector2DotProduct(v1, v2)
    return result


def vector2distance(v1: Vector2, v2: Vector2) -> float:
    # type: (Vector2, Vector2) -> float
    '''Calculate distance between two vectors

    Raylib's C API: Vector2Distance

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector2Distance(v1, v2)
    return result


def vector2distance_sqr(v1: Vector2, v2: Vector2) -> float:
    # type: (Vector2, Vector2) -> float
    '''Calculate square distance between two vectors

    Raylib's C API: Vector2DistanceSqr

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector2DistanceSqr(v1, v2)
    return result


def vector2angle(v1: Vector2, v2: Vector2) -> float:
    # type: (Vector2, Vector2) -> float
    '''Calculate angle from two vectors

    Raylib's C API: Vector2Angle

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector2Angle(v1, v2)
    return result


def vector2scale(v: Vector2, scale: float) -> Vector2:
    # type: (Vector2, float) -> Vector2
    '''Scale vector (multiply by value)

    Raylib's C API: Vector2Scale

    :param Vector2 v: `Vector2` in C raylib
    :param float scale: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Scale(v, float(scale))
    return result


def vector2multiply(v1: Vector2, v2: Vector2) -> Vector2:
    # type: (Vector2, Vector2) -> Vector2
    '''Multiply vector by vector

    Raylib's C API: Vector2Multiply

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Multiply(v1, v2)
    return result


def vector2negate(v: Vector2) -> Vector2:
    # type: (Vector2) -> Vector2
    '''Negate vector

    Raylib's C API: Vector2Negate

    :param Vector2 v: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Negate(v)
    return result


def vector2divide(v1: Vector2, v2: Vector2) -> Vector2:
    # type: (Vector2, Vector2) -> Vector2
    '''Divide vector by vector

    Raylib's C API: Vector2Divide

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Divide(v1, v2)
    return result


def vector2normalize(v: Vector2) -> Vector2:
    # type: (Vector2) -> Vector2
    '''Normalize provided vector

    Raylib's C API: Vector2Normalize

    :param Vector2 v: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Normalize(v)
    return result


def vector2transform(v: Vector2, mat: Matrix) -> Vector2:
    # type: (Vector2, Matrix) -> Vector2
    '''Transforms a Vector2 by a given Matrix

    Raylib's C API: Vector2Transform

    :param Vector2 v: `Vector2` in C raylib
    :param Matrix mat: `Matrix` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Transform(v, mat)
    return result


def vector2lerp(v1: Vector2, v2: Vector2, amount: float) -> Vector2:
    # type: (Vector2, Vector2, float) -> Vector2
    '''Calculate linear interpolation between two vectors

    Raylib's C API: Vector2Lerp

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 v2: `Vector2` in C raylib
    :param float amount: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Lerp(v1, v2, float(amount))
    return result


def vector2reflect(v1: Vector2, normal: Vector2) -> Vector2:
    # type: (Vector2, Vector2) -> Vector2
    '''Calculate reflected vector to normal

    Raylib's C API: Vector2Reflect

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 normal: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Reflect(v1, normal)
    return result


def vector2rotate(v1: Vector2, angle: float) -> Vector2:
    # type: (Vector2, float) -> Vector2
    '''Rotate vector by angle

    Raylib's C API: Vector2Rotate

    :param Vector2 v1: `Vector2` in C raylib
    :param float angle: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Rotate(v1, float(angle))
    return result


def vector2move_towards(v1: Vector2, target: Vector2, max_distance: float) -> Vector2:
    # type: (Vector2, Vector2, float) -> Vector2
    '''Move Vector towards target

    Raylib's C API: Vector2MoveTowards

    :param Vector2 v1: `Vector2` in C raylib
    :param Vector2 target: `Vector2` in C raylib
    :param float max_distance: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2MoveTowards(v1, target, float(max_distance))
    return result


def vector2invert(v: Vector2) -> Vector2:
    # type: (Vector2) -> Vector2
    '''Invert the given vector

    Raylib's C API: Vector2Invert

    :param Vector2 v: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Invert(v)
    return result


def vector2clamp(v: Vector2, min_: Vector2, max_: Vector2) -> Vector2:
    # type: (Vector2, Vector2, Vector2) -> Vector2
    '''Clamp the components of the vector between min and max values specified by the given vectors

    Raylib's C API: Vector2Clamp

    :param Vector2 v: `Vector2` in C raylib
    :param Vector2 min_: `Vector2` in C raylib
    :param Vector2 max_: `Vector2` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2Clamp(v, min_, max_)
    return result


def vector2clamp_value(v: Vector2, min_: float, max_: float) -> Vector2:
    # type: (Vector2, float, float) -> Vector2
    '''Clamp the magnitude of the vector between two min and max values

    Raylib's C API: Vector2ClampValue

    :param Vector2 v: `Vector2` in C raylib
    :param float min_: `float` in C raylib
    :param float max_: `float` in C raylib
    :return: Vector2 (`Vector2` in C raylib)
    '''
    result = _Vector2ClampValue(v, float(min_), float(max_))
    return result


def vector2equals(p: Vector2, q: Vector2) -> int:
    # type: (Vector2, Vector2) -> int
    '''Check whether two given vectors are almost equal

    Raylib's C API: Vector2Equals

    :param Vector2 p: `Vector2` in C raylib
    :param Vector2 q: `Vector2` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _Vector2Equals(p, q)
    return result


def vector3zero() -> Vector3:
    # type: () -> Vector3
    '''Vector with components value 0.0f

    Raylib's C API: Vector3Zero

    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Zero()
    return result


def vector3one() -> Vector3:
    # type: () -> Vector3
    '''Vector with components value 1.0f

    Raylib's C API: Vector3One

    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3One()
    return result


def vector3add(v1: Vector3, v2: Vector3) -> Vector3:
    # type: (Vector3, Vector3) -> Vector3
    '''Add two vectors

    Raylib's C API: Vector3Add

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Add(v1, v2)
    return result


def vector3add_value(v: Vector3, add: float) -> Vector3:
    # type: (Vector3, float) -> Vector3
    '''Add vector and float value

    Raylib's C API: Vector3AddValue

    :param Vector3 v: `Vector3` in C raylib
    :param float add: `float` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3AddValue(v, float(add))
    return result


def vector3subtract(v1: Vector3, v2: Vector3) -> Vector3:
    # type: (Vector3, Vector3) -> Vector3
    '''Subtract two vectors

    Raylib's C API: Vector3Subtract

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Subtract(v1, v2)
    return result


def vector3subtract_value(v: Vector3, sub: float) -> Vector3:
    # type: (Vector3, float) -> Vector3
    '''Subtract vector and float value

    Raylib's C API: Vector3SubtractValue

    :param Vector3 v: `Vector3` in C raylib
    :param float sub: `float` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3SubtractValue(v, float(sub))
    return result


def vector3scale(v: Vector3, scalar: float) -> Vector3:
    # type: (Vector3, float) -> Vector3
    '''Multiply vector by scalar

    Raylib's C API: Vector3Scale

    :param Vector3 v: `Vector3` in C raylib
    :param float scalar: `float` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Scale(v, float(scalar))
    return result


def vector3multiply(v1: Vector3, v2: Vector3) -> Vector3:
    # type: (Vector3, Vector3) -> Vector3
    '''Multiply vector by vector

    Raylib's C API: Vector3Multiply

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Multiply(v1, v2)
    return result


def vector3cross_product(v1: Vector3, v2: Vector3) -> float:
    # type: (Vector3, Vector3) -> float
    '''Calculate two vectors cross product

    Raylib's C API: Vector3CrossProduct

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector3CrossProduct(v1, v2)
    return result


def vector3perpendicular(v1: Vector3) -> Vector3:
    # type: (Vector3) -> Vector3
    '''Calculate one vector perpendicular vector

    Raylib's C API: Vector3Perpendicular

    :param Vector3 v1: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Perpendicular(v1)
    return result


def vector3length(v1: Vector3) -> Vector3:
    # type: (Vector3) -> Vector3
    '''Calculate vector length

    Raylib's C API: Vector3Length

    :param Vector3 v1: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Length(v1)
    return result


def vector3length_sqr(v1: Vector3) -> Vector3:
    # type: (Vector3) -> Vector3
    '''Calculate vector square length

    Raylib's C API: Vector3LengthSqr

    :param Vector3 v1: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3LengthSqr(v1)
    return result


def vector3dot_product(v1: Vector3, v2: Vector3) -> float:
    # type: (Vector3, Vector3) -> float
    '''Calculate two vectors dot product

    Raylib's C API: Vector3DotProduct

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector3DotProduct(v1, v2)
    return result


def vector3distance(v1: Vector3, v2: Vector3) -> float:
    # type: (Vector3, Vector3) -> float
    '''Calculate distance between two vectors

    Raylib's C API: Vector3Distance

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector3Distance(v1, v2)
    return result


def vector3distance_sqr(v1: Vector3, v2: Vector3) -> float:
    # type: (Vector3, Vector3) -> float
    '''Calculate square distance between two vectors

    Raylib's C API: Vector3DistanceSqr

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector3DistanceSqr(v1, v2)
    return result


def vector3angle(v1: Vector3, v2: Vector3) -> float:
    # type: (Vector3, Vector3) -> float
    '''Calculate angle between two vectors

    Raylib's C API: Vector3Angle

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector3Angle(v1, v2)
    return result


def vector3negate(v: Vector3) -> Vector3:
    # type: (Vector3) -> Vector3
    '''Negate provided vector (invert direction)

    Raylib's C API: Vector3Negate

    :param Vector3 v: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Negate(v)
    return result


def vector3divide(v1: Vector3, v2: Vector3) -> float:
    # type: (Vector3, Vector3) -> float
    '''Divide vector by vector

    Raylib's C API: Vector3Divide

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _Vector3Divide(v1, v2)
    return result


def vector3normalize(v: Vector3) -> Vector3:
    # type: (Vector3) -> Vector3
    '''Normalize provided vector

    Raylib's C API: Vector3Normalize

    :param Vector3 v: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Normalize(v)
    return result


def vector3ortho_normalize(v1: Vector3Ptr, v2: Vector3Ptr) -> Vector3:
    # type: (Vector3Ptr, Vector3Ptr) -> Vector3
    '''Makes vectors normalized and orthogonal to each other

    Raylib's C API: Vector3OrthoNormalize

    :param Vector3Ptr v1: `Vector3 *` in C raylib
    :param Vector3Ptr v2: `Vector3 *` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3OrthoNormalize(v1, v2)
    return result


def vector3transform(v: Vector3, mat: Matrix) -> Vector3:
    # type: (Vector3, Matrix) -> Vector3
    '''Transforms a Vector3 by a given Matrix

    Raylib's C API: Vector3Transform

    :param Vector3 v: `Vector3` in C raylib
    :param Matrix mat: `Matrix` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Transform(v, mat)
    return result


def vector3rotate_by_quaternion(v: Vector3, q: Quaternion) -> Vector3:
    # type: (Vector3, Quaternion) -> Vector3
    '''Transform a vector by quaternion rotation

    Raylib's C API: Vector3RotateByQuaternion

    :param Vector3 v: `Vector3` in C raylib
    :param Quaternion q: `Quaternion` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3RotateByQuaternion(v, q)
    return result


def vector3rotate_by_axis_angle(v: Vector3, axis: Vector3, angle: float) -> Vector3:
    # type: (Vector3, Vector3, float) -> Vector3
    '''Rotates a vector around an axis

    Raylib's C API: Vector3RotateByAxisAngle

    :param Vector3 v: `Vector3` in C raylib
    :param Vector3 axis: `Vector3` in C raylib
    :param float angle: `float` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3RotateByAxisAngle(v, axis, float(angle))
    return result


def vector3lerp(v1: Vector3, v2: Vector3, amount: float) -> Vector3:
    # type: (Vector3, Vector3, float) -> Vector3
    '''Calculate linear interpolation between two vectors

    Raylib's C API: Vector3Lerp

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :param float amount: `float` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Lerp(v1, v2, float(amount))
    return result


def vector3reflect(v: Vector3, normal: Vector3) -> Vector3:
    # type: (Vector3, Vector3) -> Vector3
    '''Calculate reflected vector to normal

    Raylib's C API: Vector3Reflect

    :param Vector3 v: `Vector3` in C raylib
    :param Vector3 normal: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Reflect(v, normal)
    return result


def vector3min(v1: Vector3, v2: Vector3) -> Vector3:
    # type: (Vector3, Vector3) -> Vector3
    '''Get min value for each pair of components

    Raylib's C API: Vector3Min

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Min(v1, v2)
    return result


def vector3max(v1: Vector3, v2: Vector3) -> Vector3:
    # type: (Vector3, Vector3) -> Vector3
    '''Get max value for each pair of components

    Raylib's C API: Vector3Max

    :param Vector3 v1: `Vector3` in C raylib
    :param Vector3 v2: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Max(v1, v2)
    return result


def vector3barycenter(p: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Vector3:
    # type: (Vector3, Vector3, Vector3, Vector3) -> Vector3
    '''Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c). Assumes P is on the plane of the triangle

    Raylib's C API: Vector3Barycenter

    :param Vector3 p: `Vector3` in C raylib
    :param Vector3 a: `Vector3` in C raylib
    :param Vector3 b: `Vector3` in C raylib
    :param Vector3 c: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Barycenter(p, a, b, c)
    return result


def vector3unproject(source: Vector3, projection: Matrix, view: Matrix) -> Vector3:
    # type: (Vector3, Matrix, Matrix) -> Vector3
    '''Projects a Vector3 from screen space into object space

    Raylib's C API: Vector3Unproject

    :param Vector3 source: `Vector3` in C raylib
    :param Matrix projection: `Matrix` in C raylib
    :param Matrix view: `Matrix` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Unproject(source, projection, view)
    return result


def vector3to_float_v(v: Vector3) -> Sequence[float]:
    # type: (Vector3) -> Sequence[float]
    '''Get Vector3 as float array

    Raylib's C API: Vector3ToFloatV

    :param Vector3 v: `Vector3` in C raylib
    :return: Sequence[float] (`float[3]` in C raylib)
    '''
    result = _Vector3ToFloatV(v)
    return result


def vector3invert(v: Vector3) -> Vector3:
    # type: (Vector3) -> Vector3
    '''Invert the given vector

    Raylib's C API: Vector3Invert

    :param Vector3 v: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Invert(v)
    return result


def vector3clamp(v: Vector3, min_: Vector3, max_: Vector3) -> Vector3:
    # type: (Vector3, Vector3, Vector3) -> Vector3
    '''Clamp the components of the vector between min and max values specified by the given vectors

    Raylib's C API: Vector3Clamp

    :param Vector3 v: `Vector3` in C raylib
    :param Vector3 min_: `Vector3` in C raylib
    :param Vector3 max_: `Vector3` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3Clamp(v, min_, max_)
    return result


def vector3clamp_value(v: Vector3, min_: float, max_: float) -> Vector3:
    # type: (Vector3, float, float) -> Vector3
    '''Clamp the magnitude of the vector between two values

    Raylib's C API: Vector3ClampValue

    :param Vector3 v: `Vector3` in C raylib
    :param float min_: `float` in C raylib
    :param float max_: `float` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _Vector3ClampValue(v, float(min_), float(max_))
    return result


def vector3equals(v: Vector3, min_: float, max_: float) -> int:
    # type: (Vector3, float, float) -> int
    '''Check whether two given vectors are almost equal

    Raylib's C API: Vector3Equals

    :param Vector3 v: `Vector3` in C raylib
    :param float min_: `float` in C raylib
    :param float max_: `float` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _Vector3Equals(v, float(min_), float(max_))
    return result


def vector3refract(v: Vector3, n: Vector3, r: float) -> int:
    # type: (Vector3, Vector3, float) -> int
    '''Compute the direction of a refracted ray where v specifies the normalized direction of the incoming ray, n specifies the normalized normal vector of the interface of two optical media, and r specifies the ratio of the refractive index of the medium from where the ray comes to the refractive index of the medium on the other side of the surface

    Raylib's C API: Vector3Refract

    :param Vector3 v: `Vector3` in C raylib
    :param Vector3 n: `Vector3` in C raylib
    :param float r: `float` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _Vector3Refract(v, n, float(r))
    return result


def matrix_determinant(mat: Matrix) -> float:
    # type: (Matrix) -> float
    '''Compute matrix determinant

    Raylib's C API: MatrixDeterminant

    :param Matrix mat: `Matrix` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _MatrixDeterminant(mat)
    return result


def matrix_trace(mat: Matrix) -> float:
    # type: (Matrix) -> float
    '''Get the trace of the matrix (sum of the values along the diagonal)

    Raylib's C API: MatrixTrace

    :param Matrix mat: `Matrix` in C raylib
    :return: float (`float` in C raylib)
    '''
    result = _MatrixTrace(mat)
    return result


def matrix_transpose(mat: Matrix) -> Matrix:
    # type: (Matrix) -> Matrix
    '''Get the trace of the matrix (sum of the values along the diagonal)

    Raylib's C API: MatrixTranspose

    :param Matrix mat: `Matrix` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixTranspose(mat)
    return result


def matrix_invert(mat: Matrix) -> Matrix:
    # type: (Matrix) -> Matrix
    '''Invert provided matrix

    Raylib's C API: MatrixInvert

    :param Matrix mat: `Matrix` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixInvert(mat)
    return result


def matrix_identity() -> Matrix:
    # type: () -> Matrix
    '''Get identity matrix

    Raylib's C API: MatrixIdentity

    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixIdentity()
    return result


def matrix_add(left: Matrix, right: Matrix) -> Matrix:
    # type: (Matrix, Matrix) -> Matrix
    '''Add two matrices

    Raylib's C API: MatrixAdd

    :param Matrix left: `Matrix` in C raylib
    :param Matrix right: `Matrix` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixAdd(left, right)
    return result


def matrix_subtract(left: Matrix, right: Matrix) -> Matrix:
    # type: (Matrix, Matrix) -> Matrix
    '''Subtract two matrices (left - right)

    Raylib's C API: MatrixSubtract

    :param Matrix left: `Matrix` in C raylib
    :param Matrix right: `Matrix` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixSubtract(left, right)
    return result


def matrix_multiply(left: Matrix, right: Matrix) -> Matrix:
    # type: (Matrix, Matrix) -> Matrix
    '''Get two matrix multiplication. When multiplying matrices... the order matters!

    Raylib's C API: MatrixMultiply

    :param Matrix left: `Matrix` in C raylib
    :param Matrix right: `Matrix` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixMultiply(left, right)
    return result


def matrix_translate(x: float, y: float, z: float) -> Matrix:
    # type: (float, float, float) -> Matrix
    '''Get translation matrix

    Raylib's C API: MatrixTranslate

    :param float x: `float` in C raylib
    :param float y: `float` in C raylib
    :param float z: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixTranslate(float(x), float(y), float(z))
    return result


def matrix_rotate(axis: Vector3, angle: float) -> Matrix:
    # type: (Vector3, float) -> Matrix
    '''Create rotation matrix from axis and angle. Angle should be provided in radians

    Raylib's C API: MatrixRotate

    :param Vector3 axis: `Vector3` in C raylib
    :param float angle: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixRotate(axis, float(angle))
    return result


def matrix_rotate_x(angle: float) -> Matrix:
    # type: (float) -> Matrix
    '''Get x-rotation matrix. Angle must be provided in radians

    Raylib's C API: MatrixRotateX

    :param float angle: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixRotateX(float(angle))
    return result


def matrix_rotate_y(angle: float) -> Matrix:
    # type: (float) -> Matrix
    '''Get y-rotation matrix. Angle must be provided in radians

    Raylib's C API: MatrixRotateY

    :param float angle: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixRotateY(float(angle))
    return result


def matrix_rotate_z(angle: float) -> Matrix:
    # type: (float) -> Matrix
    '''Get z-rotation matrix. Angle must be provided in radians

    Raylib's C API: MatrixRotateZ

    :param float angle: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixRotateZ(float(angle))
    return result


def matrix_rotate_xyz(angle: Vector3) -> Matrix:
    # type: (Vector3) -> Matrix
    '''Get xyz-rotation matrix. Angle must be provided in radians

    Raylib's C API: MatrixRotateXYZ

    :param Vector3 angle: `Vector3` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixRotateXYZ(angle)
    return result


def matrix_rotate_zyx(angle: Vector3) -> Matrix:
    # type: (Vector3) -> Matrix
    '''Get zyx-rotation matrix. Angle must be provided in radians

    Raylib's C API: MatrixRotateZYX

    :param Vector3 angle: `Vector3` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixRotateZYX(angle)
    return result


def matrix_scale(x: float, y: float, z: float) -> Matrix:
    # type: (float, float, float) -> Matrix
    '''Get scaling matrix

    Raylib's C API: MatrixScale

    :param float x: `float` in C raylib
    :param float y: `float` in C raylib
    :param float z: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixScale(float(x), float(y), float(z))
    return result


def matrix_frustum(left: float, right: float, bottom: float, top: float, near: float, far: float) -> Matrix:
    # type: (float, float, float, float, float, float) -> Matrix
    '''Get perspective projection matrix

    Raylib's C API: MatrixFrustum

    :param float left: `float` in C raylib
    :param float right: `float` in C raylib
    :param float bottom: `float` in C raylib
    :param float top: `float` in C raylib
    :param float near: `float` in C raylib
    :param float far: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixFrustum(float(left), float(right), float(bottom), float(top), float(near), float(far))
    return result


def matrix_perspective(fovy: float, aspect: float, near: float, far: float) -> Matrix:
    # type: (float, float, float, float) -> Matrix
    '''Get perspective projection matrix. Fovy angle must be provided in radians

    Raylib's C API: MatrixPerspective

    :param float fovy: `float` in C raylib
    :param float aspect: `float` in C raylib
    :param float near: `float` in C raylib
    :param float far: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixPerspective(float(fovy), float(aspect), float(near), float(far))
    return result


def matrix_ortho(left: float, right: float, bottom: float, top: float, near: float, far: float) -> Matrix:
    # type: (float, float, float, float, float, float) -> Matrix
    '''Get orthographic projection matrix

    Raylib's C API: MatrixOrtho

    :param float left: `float` in C raylib
    :param float right: `float` in C raylib
    :param float bottom: `float` in C raylib
    :param float top: `float` in C raylib
    :param float near: `float` in C raylib
    :param float far: `float` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixOrtho(float(left), float(right), float(bottom), float(top), float(near), float(far))
    return result


def matrix_look_at(eye: Vector3, target: Vector3, up: Vector3) -> Matrix:
    # type: (Vector3, Vector3, Vector3) -> Matrix
    '''Get camera look-at matrix (view matrix)

    Raylib's C API: MatrixLookAt

    :param Vector3 eye: `Vector3` in C raylib
    :param Vector3 target: `Vector3` in C raylib
    :param Vector3 up: `Vector3` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _MatrixLookAt(eye, target, up)
    return result


def matrix_to_float_v(mat: Matrix) -> Sequence[float]:
    # type: (Matrix) -> Sequence[float]
    '''Get float array of matrix data

    Raylib's C API: MatrixToFloatV

    :param Matrix mat: `Matrix` in C raylib
    :return: Sequence[float] (`float[16]` in C raylib)
    '''
    result = _MatrixToFloatV(mat)
    return result


def quaternion_add(q1: Quaternion, q2: Quaternion) -> Quaternion:
    # type: (Quaternion, Quaternion) -> Quaternion
    '''Add two quaternions

    Raylib's C API: QuaternionAdd

    :param Quaternion q1: `Quaternion` in C raylib
    :param Quaternion q2: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionAdd(q1, q2)
    return result


def quaternion_add_value(q: Quaternion, add: float) -> Quaternion:
    # type: (Quaternion, float) -> Quaternion
    '''Add quaternion and float value

    Raylib's C API: QuaternionAddValue

    :param Quaternion q: `Quaternion` in C raylib
    :param float add: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionAddValue(q, float(add))
    return result


def quaternion_subtract(q1: Quaternion, q2: Quaternion) -> Quaternion:
    # type: (Quaternion, Quaternion) -> Quaternion
    '''Subtract two quaternions

    Raylib's C API: QuaternionSubtract

    :param Quaternion q1: `Quaternion` in C raylib
    :param Quaternion q2: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionSubtract(q1, q2)
    return result


def quaternion_subtract_value(q: Quaternion, sub: float) -> Quaternion:
    # type: (Quaternion, float) -> Quaternion
    '''Subtract quaternion and float value

    Raylib's C API: QuaternionSubtractValue

    :param Quaternion q: `Quaternion` in C raylib
    :param float sub: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionSubtractValue(q, float(sub))
    return result


def quaternion_identity() -> Quaternion:
    # type: () -> Quaternion
    '''Get identity quaternion

    Raylib's C API: QuaternionIdentity

    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionIdentity()
    return result


def quaternion_length(q: Quaternion) -> Quaternion:
    # type: (Quaternion) -> Quaternion
    '''Computes the length of a quaternion

    Raylib's C API: QuaternionLength

    :param Quaternion q: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionLength(q)
    return result


def quaternion_normalize(q: Quaternion) -> Quaternion:
    # type: (Quaternion) -> Quaternion
    '''Normalize provided quaternion

    Raylib's C API: QuaternionNormalize

    :param Quaternion q: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionNormalize(q)
    return result


def quaternion_invert(q: Quaternion) -> Quaternion:
    # type: (Quaternion) -> Quaternion
    '''Invert provided quaternion

    Raylib's C API: QuaternionInvert

    :param Quaternion q: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionInvert(q)
    return result


def quaternion_multiply(q1: Quaternion, q2: Quaternion) -> Quaternion:
    # type: (Quaternion, Quaternion) -> Quaternion
    '''Calculate two quaternion multiplication

    Raylib's C API: QuaternionMultiply

    :param Quaternion q1: `Quaternion` in C raylib
    :param Quaternion q2: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionMultiply(q1, q2)
    return result


def quaternion_scale(q1: Quaternion, mul: float) -> Quaternion:
    # type: (Quaternion, float) -> Quaternion
    '''Scale quaternion by float value

    Raylib's C API: QuaternionScale

    :param Quaternion q1: `Quaternion` in C raylib
    :param float mul: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionScale(q1, float(mul))
    return result


def quaternion_divide(q1: Quaternion, q2: Quaternion) -> Quaternion:
    # type: (Quaternion, Quaternion) -> Quaternion
    '''Divide two quaternions

    Raylib's C API: QuaternionDivide

    :param Quaternion q1: `Quaternion` in C raylib
    :param Quaternion q2: `Quaternion` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionDivide(q1, q2)
    return result


def quaternion_nlerp(q1: Quaternion, q2: Quaternion, amount: float) -> Quaternion:
    # type: (Quaternion, Quaternion, float) -> Quaternion
    '''Calculate slerp-optimized interpolation between two quaternions

    Raylib's C API: QuaternionNlerp

    :param Quaternion q1: `Quaternion` in C raylib
    :param Quaternion q2: `Quaternion` in C raylib
    :param float amount: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionNlerp(q1, q2, float(amount))
    return result


def quaternion_slerp(q1: Quaternion, q2: Quaternion, amount: float) -> Quaternion:
    # type: (Quaternion, Quaternion, float) -> Quaternion
    '''Calculates spherical linear interpolation between two quaternions

    Raylib's C API: QuaternionSlerp

    :param Quaternion q1: `Quaternion` in C raylib
    :param Quaternion q2: `Quaternion` in C raylib
    :param float amount: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionSlerp(q1, q2, float(amount))
    return result


def quaternion_from_vector3to_vector3(from_: Vector3, to: Vector3) -> Quaternion:
    # type: (Vector3, Vector3) -> Quaternion
    '''Calculate quaternion based on the rotation from one vector to another

    Raylib's C API: QuaternionFromVector3ToVector3

    :param Vector3 from_: `Vector3` in C raylib
    :param Vector3 to: `Vector3` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionFromVector3ToVector3(from_, to)
    return result


def quaternion_to_matrix(q: Quaternion) -> Matrix:
    # type: (Quaternion) -> Matrix
    '''Get a quaternion for a given rotation matrix

    Raylib's C API: QuaternionToMatrix

    :param Quaternion q: `Quaternion` in C raylib
    :return: Matrix (`Matrix` in C raylib)
    '''
    result = _QuaternionToMatrix(q)
    return result


def quaternion_from_matrix(mat: Matrix) -> Quaternion:
    # type: (Matrix) -> Quaternion
    '''Get a quaternion for a given rotation matrix

    Raylib's C API: QuaternionFromMatrix

    :param Matrix mat: `Matrix` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionFromMatrix(mat)
    return result


def quaternion_from_axis_angle(mat: Vector3, angle: float) -> Quaternion:
    # type: (Vector3, float) -> Quaternion
    '''Get rotation quaternion for an angle and axis. Angle must be provided in radians

    Raylib's C API: QuaternionFromAxisAngle

    :param Vector3 mat: `Vector3` in C raylib
    :param float angle: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionFromAxisAngle(mat, float(angle))
    return result


def quaternion_to_axis_angle(q: Quaternion, out_axis: Vector3Ptr, out_angle: Sequence[float]) -> None:
    # type: (Quaternion, Vector3Ptr, Sequence[float]) -> None
    '''Get the rotation angle and axis for a given quaternion

    Raylib's C API: QuaternionToAxisAngle

    :param Quaternion q: `Quaternion` in C raylib
    :param Vector3Ptr out_axis: `Vector3 *` in C raylib
    :param Sequence[float] out_angle: `float *` in C raylib
    :return: None (`void` in C raylib)
    '''
    out_angle_ref = cast(out_angle, FloatPtr)
    _QuaternionToAxisAngle(q, out_axis, out_angle_ref)


def quaternion_from_euler(pitch: float, yaw: float, roll: float) -> Quaternion:
    # type: (float, float, float) -> Quaternion
    '''Get the quaternion equivalent to Euler angles. Rotation order is ZYX

    Raylib's C API: QuaternionFromEuler

    :param float pitch: `float` in C raylib
    :param float yaw: `float` in C raylib
    :param float roll: `float` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionFromEuler(float(pitch), float(yaw), float(roll))
    return result


def quaternion_to_euler(q: Quaternion) -> Vector3:
    # type: (Quaternion) -> Vector3
    '''Get the quaternion equivalent to Euler angles. Rotation order is ZYX

    Raylib's C API: QuaternionToEuler

    :param Quaternion q: `Quaternion` in C raylib
    :return: Vector3 (`Vector3` in C raylib)
    '''
    result = _QuaternionToEuler(q)
    return result


def quaternion_transform(q: Quaternion, mat: Matrix) -> Quaternion:
    # type: (Quaternion, Matrix) -> Quaternion
    '''Transform a quaternion given a transformation matrix

    Raylib's C API: QuaternionTransform

    :param Quaternion q: `Quaternion` in C raylib
    :param Matrix mat: `Matrix` in C raylib
    :return: Quaternion (`Quaternion` in C raylib)
    '''
    result = _QuaternionTransform(q, mat)
    return result


def quaternion_equals(p: Quaternion, q: Quaternion) -> int:
    # type: (Quaternion, Quaternion) -> int
    '''Check whether two given quaternions are almost equal

    Raylib's C API: QuaternionEquals

    :param Quaternion p: `Quaternion` in C raylib
    :param Quaternion q: `Quaternion` in C raylib
    :return: int (`int` in C raylib)
    '''
    result = _QuaternionEquals(p, q)
    return result

# endregion (api)
